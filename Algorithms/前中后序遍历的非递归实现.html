<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前中后序遍历的非递归实现</title>
    <meta name="generator" content="VuePress 1.8.1">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.e4d8b86b.css" as="style"><link rel="preload" href="/assets/js/app.cdf84e36.js" as="script"><link rel="preload" href="/assets/js/2.cd603132.js" as="script"><link rel="preload" href="/assets/js/29.1084cfe5.js" as="script"><link rel="prefetch" href="/assets/js/10.fa04d7da.js"><link rel="prefetch" href="/assets/js/11.e05d5cca.js"><link rel="prefetch" href="/assets/js/12.14a6f17f.js"><link rel="prefetch" href="/assets/js/13.db4d1de1.js"><link rel="prefetch" href="/assets/js/14.899c5ca4.js"><link rel="prefetch" href="/assets/js/15.d0396fe4.js"><link rel="prefetch" href="/assets/js/16.b7711d40.js"><link rel="prefetch" href="/assets/js/17.1525986f.js"><link rel="prefetch" href="/assets/js/18.1ae3bf5c.js"><link rel="prefetch" href="/assets/js/19.6a77119a.js"><link rel="prefetch" href="/assets/js/20.236c8b53.js"><link rel="prefetch" href="/assets/js/21.2bfe940a.js"><link rel="prefetch" href="/assets/js/22.d9efe3b1.js"><link rel="prefetch" href="/assets/js/23.ebce0411.js"><link rel="prefetch" href="/assets/js/24.fabb82cb.js"><link rel="prefetch" href="/assets/js/25.c657f98a.js"><link rel="prefetch" href="/assets/js/26.32c42d96.js"><link rel="prefetch" href="/assets/js/27.1678b12c.js"><link rel="prefetch" href="/assets/js/28.8544b050.js"><link rel="prefetch" href="/assets/js/3.a98e93fb.js"><link rel="prefetch" href="/assets/js/30.a6d1035b.js"><link rel="prefetch" href="/assets/js/31.be5835b4.js"><link rel="prefetch" href="/assets/js/32.d4366367.js"><link rel="prefetch" href="/assets/js/33.2b200c99.js"><link rel="prefetch" href="/assets/js/34.f163deeb.js"><link rel="prefetch" href="/assets/js/35.0b851840.js"><link rel="prefetch" href="/assets/js/36.7ff07fed.js"><link rel="prefetch" href="/assets/js/37.2693764e.js"><link rel="prefetch" href="/assets/js/38.6d5e99f9.js"><link rel="prefetch" href="/assets/js/39.d396e830.js"><link rel="prefetch" href="/assets/js/4.c1d52a96.js"><link rel="prefetch" href="/assets/js/40.569e795b.js"><link rel="prefetch" href="/assets/js/41.23c7880d.js"><link rel="prefetch" href="/assets/js/42.099df540.js"><link rel="prefetch" href="/assets/js/43.c74e858f.js"><link rel="prefetch" href="/assets/js/44.0fc3638c.js"><link rel="prefetch" href="/assets/js/45.a3c0d604.js"><link rel="prefetch" href="/assets/js/46.2a672594.js"><link rel="prefetch" href="/assets/js/47.7e8f0cf5.js"><link rel="prefetch" href="/assets/js/48.1f54ffbe.js"><link rel="prefetch" href="/assets/js/49.e3e5f68b.js"><link rel="prefetch" href="/assets/js/5.6e3c4c72.js"><link rel="prefetch" href="/assets/js/50.4b3f35ab.js"><link rel="prefetch" href="/assets/js/51.3f804d6f.js"><link rel="prefetch" href="/assets/js/52.f125db44.js"><link rel="prefetch" href="/assets/js/6.75cdaa21.js"><link rel="prefetch" href="/assets/js/7.39046d4b.js"><link rel="prefetch" href="/assets/js/8.12f5371b.js"><link rel="prefetch" href="/assets/js/9.c3f94571.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e4d8b86b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/iOS/" class="nav-link">
  iOS
</a></div><div class="nav-item"><a href="/Algorithms/" class="nav-link router-link-active">
  Algorithms
</a></div> <a href="https://github.com/tamarous/tamarous_blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/iOS/" class="nav-link">
  iOS
</a></div><div class="nav-item"><a href="/Algorithms/" class="nav-link router-link-active">
  Algorithms
</a></div> <a href="https://github.com/tamarous/tamarous_blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="前中后序遍历的非递归实现"><a href="#前中后序遍历的非递归实现" class="header-anchor">#</a> 前中后序遍历的非递归实现</h1> <p>前、中、后序遍历是对树进行的基础操作，当使用递归来实现时代码非常简单。但是由于递归时会不断将当前状态保存下来，因此在这些状态之间进行切换也非常耗费时间。下面就介绍一下用非递归的方式如何来实现这些操作。另外在本文最后还介绍了一下层序遍历。</p> <p><img src="http://7xnyik.com1.z0.glb.clouddn.com/binaryTree.png" alt="Binary Tree Travel"></p> <p>二叉树的数据结构定义如下：</p> <div class="language- extra-class"><pre><code>struct TreeNode {
    TreeNode *left;
    TreeNode *right;
    int val;
    TreeNode(int x): val(x), left(NULL),right(NULL) {}
}
</code></pre></div><ul><li><p>前序遍历：非递归遍历通过栈来实现，并且有两种不同的实现方式。思路一是先将根节点压入栈，然后当栈不为空的时候，先将栈顶元素出栈并访问这个节点，然后依次将该节点的<strong>右孩子</strong>和<strong>左孩子</strong>入栈。代码如下：</p> <div class="language- extra-class"><pre><code>  void preOrder(TreeNode *root) {
      if(root == NULL) {
          return;
      }
      stack&lt;struct TreeNode *&gt; s;
      s.push(root);
      while(! s.empty()) {
          TreeNode *node = s.top();
          s.pop();
          cout &lt;&lt; node-&gt;val &lt;&lt; endl;
          if (node-&gt;right) {
              s.push(node-&gt;right);
          }
          if (node-&gt;left) {
              s.push(node-&gt;left);
          }
      }
  }
</code></pre></div></li></ul> <p>思路二则是使用回溯，先遍历完左子树，然后回溯遍历右子树。</p> <div class="language- extra-class"><pre><code>    void preOrder_(TreeNode *root) {
        if (root == NULL) {
            return;
        }
        stack&lt;TreeNode *&gt; s;
        TreeNode *ptr = root;
        while(ptr != NULL &amp;&amp; ! s.empty()) {
            if(ptr != NULL) {
            
                // 访问当前节点
                cout &lt;&lt; ptr-&gt;val &lt;&lt; endl;
                s.push(ptr);
                ptr = ptr-&gt;left;
            } else {
            // 当 ptr 为空的时候，说明刚刚入栈的那个节点的左子树已经遍历完了
            // 因此应该把它弹出来然后遍历它的右子树了
                ptr = s.top();
                s.pop();
                ptr = ptr-&gt;right;
            }
        }
    }
</code></pre></div><ul><li><p>中序遍历：和前序遍历的实现非常类似，只不过访问节点的时机不同。</p> <div class="language- extra-class"><pre><code>  void inOrder(TreeNode *root) {
      if (root == NULL) {
          return;
      }
      stack&lt;TreeNode *&gt; s;
      TreeNode *ptr = root;
      while(ptr != NULL &amp;&amp; ! s.empty()) {
          if (ptr != NULL) {
              s.push(ptr);
              ptr = ptr-&gt;left;
          } else {
              ptr = s.top();
              s.pop();
              cout &lt;&lt; ptr-&gt;val &lt;&lt; endl;
              ptr = ptr-&gt;right;
          }
      }
  }
</code></pre></div></li> <li><p>后序遍历：后序遍历是这几种遍历方式中比较麻烦的一种。前面的算法的规律是，当一个节点的左子树已经访问完了后，会将当前节点从栈中直接弹出并访问这个节点，然后再遍历它的右子树。但是后序遍历时，当访问完一个节点的左子树后，先得从栈顶获得这个节点，得到它的右子树并访问右子树，当右子树访问之后，再从栈顶获得这个节点，然后去访问这个节点自身，然后将该节点出栈。可以看出，访问该节点的过程发生了两次，但是只有访问了它的右子树后才可以将这个节点从栈中弹出。因此我们需要标记该节点是否被访问过。代码如下：</p> <div class="language- extra-class"><pre><code>  void postOrder(TreeNode *root) {
      if (root == NULL) {
          return NULL;
      }
      stack&lt;TreeNode *&gt; s;
      TreeNode *cur = root, *lastVisited = NULL;
      while(cur) {
          s.push(cur);
          cur = cur-&gt;left;
      }
      while(! s.empty()) {
          cur = s.top();
          s.pop(); // 将某个节点第一次从栈中 pop 出来
  
          // 如果这个节点没有右子树，或者是这个节点的右子树已经被访问过了
          // 那么就直接访问这个节点
          if (cur-&gt;right == NULL || cur-&gt;right == lastVisited) {
              cout &lt;&lt; cur-&gt;val &lt;&lt; endl;
              lastVisited = cur;
          } else {
  
              // 将这个节点再次入栈
              s.push(cur);
              cur = cur-&gt;right;
              while(cur) {
                  s.push(cur);
                  cur = cur-&gt;right;
              }
          }
      }
  }
</code></pre></div></li> <li><p>层序遍历：作为树的遍历方式的一种，虽然不如前面三种方式常见，但是也是非常有必要了解的。与前面三种方式不同的是，层序遍历使用了队列而不是栈这种结构。思路是：先将根节点入队，当队列不为空的时候，从队列头出队一个元素并访问它，然后将它的左右孩子依次入队。</p> <div class="language- extra-class"><pre><code>  void levelOrder(TreeNode *root) {
      if (root == NULL) {
          return NULL;
      }
      Queue&lt;TreeNode *&gt; queue = new Queue&lt;&gt;();
      queue.push(root);
      while (! queue.empty()) {
          TreeNode *node = queue.front();
          queue.pop();
          cout &lt;&lt; node-&gt;val &lt;&lt; endl;
          if (node-&gt;left) {
              queue.push(node-&gt;left);
          }
          if (node-&gt;right) {
              queue.push(node-&gt;right);
          }
      }
  }
</code></pre></div></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.cdf84e36.js" defer></script><script src="/assets/js/2.cd603132.js" defer></script><script src="/assets/js/29.1084cfe5.js" defer></script>
  </body>
</html>
