<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>递归在二叉树相关题目中的应用</title>
    <meta name="generator" content="VuePress 1.8.1">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/tamarous_blog/assets/css/0.styles.2918e61a.css" as="style"><link rel="preload" href="/tamarous_blog/assets/js/app.2ca14050.js" as="script"><link rel="preload" href="/tamarous_blog/assets/js/2.cd603132.js" as="script"><link rel="preload" href="/tamarous_blog/assets/js/42.7175cd4e.js" as="script"><link rel="prefetch" href="/tamarous_blog/assets/js/10.26a5b427.js"><link rel="prefetch" href="/tamarous_blog/assets/js/11.ca60f1ab.js"><link rel="prefetch" href="/tamarous_blog/assets/js/12.14a6f17f.js"><link rel="prefetch" href="/tamarous_blog/assets/js/13.db4d1de1.js"><link rel="prefetch" href="/tamarous_blog/assets/js/14.899c5ca4.js"><link rel="prefetch" href="/tamarous_blog/assets/js/15.d0396fe4.js"><link rel="prefetch" href="/tamarous_blog/assets/js/16.b7711d40.js"><link rel="prefetch" href="/tamarous_blog/assets/js/17.1525986f.js"><link rel="prefetch" href="/tamarous_blog/assets/js/18.1ae3bf5c.js"><link rel="prefetch" href="/tamarous_blog/assets/js/19.6a77119a.js"><link rel="prefetch" href="/tamarous_blog/assets/js/20.236c8b53.js"><link rel="prefetch" href="/tamarous_blog/assets/js/21.2bfe940a.js"><link rel="prefetch" href="/tamarous_blog/assets/js/22.d9efe3b1.js"><link rel="prefetch" href="/tamarous_blog/assets/js/23.ebce0411.js"><link rel="prefetch" href="/tamarous_blog/assets/js/24.fabb82cb.js"><link rel="prefetch" href="/tamarous_blog/assets/js/25.c657f98a.js"><link rel="prefetch" href="/tamarous_blog/assets/js/26.32c42d96.js"><link rel="prefetch" href="/tamarous_blog/assets/js/27.1678b12c.js"><link rel="prefetch" href="/tamarous_blog/assets/js/28.8544b050.js"><link rel="prefetch" href="/tamarous_blog/assets/js/29.1084cfe5.js"><link rel="prefetch" href="/tamarous_blog/assets/js/3.a98e93fb.js"><link rel="prefetch" href="/tamarous_blog/assets/js/30.a6d1035b.js"><link rel="prefetch" href="/tamarous_blog/assets/js/31.be5835b4.js"><link rel="prefetch" href="/tamarous_blog/assets/js/32.ed1baeea.js"><link rel="prefetch" href="/tamarous_blog/assets/js/33.1c5e69b5.js"><link rel="prefetch" href="/tamarous_blog/assets/js/34.e6785929.js"><link rel="prefetch" href="/tamarous_blog/assets/js/35.a2c5c07e.js"><link rel="prefetch" href="/tamarous_blog/assets/js/36.bf8c6fae.js"><link rel="prefetch" href="/tamarous_blog/assets/js/37.4aa9a168.js"><link rel="prefetch" href="/tamarous_blog/assets/js/38.1b71fc14.js"><link rel="prefetch" href="/tamarous_blog/assets/js/39.55b4068e.js"><link rel="prefetch" href="/tamarous_blog/assets/js/4.c1d52a96.js"><link rel="prefetch" href="/tamarous_blog/assets/js/40.0fccb135.js"><link rel="prefetch" href="/tamarous_blog/assets/js/41.69995d1e.js"><link rel="prefetch" href="/tamarous_blog/assets/js/43.ddd52948.js"><link rel="prefetch" href="/tamarous_blog/assets/js/44.2d7d9586.js"><link rel="prefetch" href="/tamarous_blog/assets/js/45.fb12614e.js"><link rel="prefetch" href="/tamarous_blog/assets/js/46.073425dd.js"><link rel="prefetch" href="/tamarous_blog/assets/js/47.844aae45.js"><link rel="prefetch" href="/tamarous_blog/assets/js/48.79b582e5.js"><link rel="prefetch" href="/tamarous_blog/assets/js/49.0c435f5a.js"><link rel="prefetch" href="/tamarous_blog/assets/js/5.6e3c4c72.js"><link rel="prefetch" href="/tamarous_blog/assets/js/50.6786a861.js"><link rel="prefetch" href="/tamarous_blog/assets/js/51.08fa9cb7.js"><link rel="prefetch" href="/tamarous_blog/assets/js/52.7bd74568.js"><link rel="prefetch" href="/tamarous_blog/assets/js/6.75cdaa21.js"><link rel="prefetch" href="/tamarous_blog/assets/js/7.39046d4b.js"><link rel="prefetch" href="/tamarous_blog/assets/js/8.12f5371b.js"><link rel="prefetch" href="/tamarous_blog/assets/js/9.682ca412.js">
    <link rel="stylesheet" href="/tamarous_blog/assets/css/0.styles.2918e61a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/tamarous_blog/" class="home-link router-link-active"></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/tamarous_blog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/tamarous_blog/iOS/" class="nav-link">
  iOS
</a></div><div class="nav-item"><a href="/tamarous_blog/Algorithms/" class="nav-link router-link-active">
  Algorithms
</a></div> <a href="https://github.com/tamarous/tamarous_blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/tamarous_blog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/tamarous_blog/iOS/" class="nav-link">
  iOS
</a></div><div class="nav-item"><a href="/tamarous_blog/Algorithms/" class="nav-link router-link-active">
  Algorithms
</a></div> <a href="https://github.com/tamarous/tamarous_blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="递归在二叉树相关题目中的应用"><a href="#递归在二叉树相关题目中的应用" class="header-anchor">#</a> 递归在二叉树相关题目中的应用</h1> <p>最近集中刷了几道和二叉树有关的题目。由于二叉树本身就是递归定义的，因此使用递归算法解决二叉树的相关问题，不仅思路清晰，算法简单，而且代码量也比非递归的解法要小很多。在此将这些题目一并总结和记录一下。在介绍一般性的做法之前，先说一下自己总结出的经验。
<strong>经验一</strong>：使用一个辅助函数，在这个辅助函数中进行递归的操作，可以使代码变得更加简单。
<strong>经验二</strong>：在递归函数的开始处先处理特殊情况，也就是所谓的递归返回点。</p> <p>下面是本文中二叉树的数据结构定义:</p> <div class="language- extra-class"><pre><code>struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x):val(x)，left(NULL)，right(NULL){}
};
</code></pre></div><ul><li><p>合并两个二叉树，<a href="https://leetcode.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener noreferrer">LeetCode-617-Merge Two Binary Trees<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。给出两个二叉树，将这个二叉树合并成一个新的二叉树。合并规则是对应位置上的值相加。最后返回新的二叉树的根节点。
思路: 使用递归算法，在合并当前节点之前，先合并当前节点的左孩子和右孩子。</p> <div class="language- extra-class"><pre><code>  class Solution {
  public:
      TreeNode *mergeTrees(TreeNode *t1, TreeNode *t2) {
          if( !t1 &amp;&amp; !t2) {
              return NULL;
          }
          struct TreeNode *node = (TreeNode *)malloc(sizeof(TreeNode));
          if (!t1 &amp;&amp; t2) {
              node-&gt;val = t2-&gt;val;
              node-&gt;left = mergeTrees(NULL, t2-&gt;left);
              node-&gt;right = mergeTrees(NULL, t2-&gt;right);
          } 
          if (t1 &amp;&amp; !t2) {
              node-&gt;val = t1-&gt;val;
              node-&gt;left = mergeTrees(t1-&gt;left, NULL);
              node-&gt;right = mergeTrees(t1-&gt;right, NULL);
          }
          if (t1 &amp;&amp; t2) {
              node-&gt;val = t1-&gt;val + t2-&gt;val;
              node-&gt;left = mergeTrees(t1-&gt;left, t2-&gt;left);
              node-&gt;right = mergeTrees(t1-&gt;right, t2-&gt;right);
          }
          return node;
      }
  };
</code></pre></div></li> <li><p>前中后各种遍历。使用递归算法时这三种遍历的思路都是一样的，区别只是访问root节点的顺序。另外这几种遍历方法也可以使用非递归的方式实现，不过需要借助栈、队列等额外的数据结构，详见我的另一篇<a href="http://www.tamarous.com/2017/10/09/several-ways-of-travel-tree/" target="_blank" rel="noopener noreferrer">博客<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p></li></ul> <ol><li><p>前序遍历</p> <div class="language- extra-class"><pre><code> class Solution {
 public:
     void preOrder(TreeNode *root) {
         if(root == NULL) {
             return;
         }
         cout &lt;&lt; root-&gt;val &lt;&lt; endl;
         preOrder(root-&gt;left);
         preOrder(root-&gt;right);
     }
 }
</code></pre></div></li> <li><p>中序遍历</p> <div class="language- extra-class"><pre><code> class Solution {
 public:
     void inOrder(TreeNode *root) {
         if(root == NULL) {
             return;
         }
         inOrder(root-&gt;left);
         cout &lt;&lt; root-&gt;val &lt;&lt; endl;
         inOrder(root-&gt;right);
     }
 }
</code></pre></div></li> <li><p>后序遍历</p> <div class="language- extra-class"><pre><code> class Solution {
 public:
     void postOrder(TreeNode *root) {
         if(root == NULL) {
             return;
         }
         postOrder(root-&gt;left);
         postOrder(root-&gt;right);
         cout &lt;&lt; root-&gt;val &lt;&lt; endl;
     }
 }
</code></pre></div></li></ol> <ul><li><p>判断两个二叉树是否是相同的，<a href="https://leetcode.com/problems/same-tree/" target="_blank" rel="noopener noreferrer">LeetCode-100-Same Tree<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。 两个二叉树相同的定义是这两个二叉树的结构相同，并且对应位置上的节点的数值也相同。</p> <div class="language- extra-class"><pre><code>  class Solution {
  public:
      bool isSameTree(TreeNode* p, TreeNode* q) {
          if (!p &amp;&amp; !q) {
              return true;
          }
          if (p == NULL || q == NULL) {
              return false;
          }
          if (p-&gt;val != q-&gt;val) {
              return false;
          }
          return isSameTree(p-&gt;left,q-&gt;left) &amp;&amp; isSameTree(p-&gt;right,q-&gt;right);
      }
  }; 
</code></pre></div></li> <li><p>判断一棵二叉树是否是对称的，<a href="https://leetcode.com/problems/symmetric-tree/description/" target="_blank" rel="noopener noreferrer">LeetCode-101-Symmetric Tree<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <div class="language- extra-class"><pre><code>  class Solution {
  public:
      bool isSymmetric(TreeNode *root) {
          if (root == NULL) {
              return true;
          }
          return isSymmetricHelper(root-&gt;left, root-&gt;right);
      }
  private:
      bool isSymmetricHelper(TreeNode *p,  TreeNode *q) {
          if (!p &amp;&amp; !q) {
              return true;
          }
          if (p == NULL || q == NULL) {
              return false;
          }
          return (p-&gt;val == q-&gt;val) &amp;&amp; isSymmetricHelper(p-&gt;left, q-&gt;right) &amp;&amp; isSymmetricHelper(p-&gt;right, q-&gt;left);
      }
  };
</code></pre></div></li> <li><p>将一棵二叉树展平成一个单链表，<a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/description/" target="_blank" rel="noopener noreferrer">Flatten Binary Tree to Linked List<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <div class="language- extra-class"><pre><code>  class Solution {
  public:
      void flatten(TreeNode* root) {
          if(root == NULL) {
              return;
          }
          flatten(root-&gt;right);
          flatten(root-&gt;left);
          root-&gt;right = prev;
          root-&gt;left = NULL;
          prev = root;
      }   
  private:
      TreeNode *prev;
  };
</code></pre></div></li> <li><p>判断一棵树上是否存在一条路径，使得该路径上的所有节点的值的和等于给定的数字，<a href="https://leetcode.com/problems/path-sum/" target="_blank" rel="noopener noreferrer">LeetCode-112-Path Sum<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <div class="language- extra-class"><pre><code>  class Solution {
      public:
          bool hasPathSum(TreeNode* root, int sum) {
              bool hasSum = false;
              helper(root, sum, hasSum);
              return hasSum;
          }
      private:
          void helper(TreeNode *root, int sum, bool &amp;flag) {
              if (root == NULL) {
                  return;
              }
              sum -= root-&gt;val;
              if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) {
                  if (sum == 0) {
                      flag = true;
                  }
              } else {
                  if (root-&gt;left != NULL) {
                      helper(root-&gt;left, sum, flag);
                  } 
                  if (root-&gt;right != NULL) {
                      helper(root-&gt;right, sum, flag);
                  }
              }
              
              sum += root-&gt;val;
          }
  };
</code></pre></div></li> <li><p>和上道题非常类似，但是要求求出所有的符合条件的路径，<a href="https://leetcode.com/problems/path-sum-ii/description/" target="_blank" rel="noopener noreferrer">LeetCode-437-Path Sum II<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <div class="language- extra-class"><pre><code>   class Solution {
   public:
       vector&lt;vector&lt;int&gt; &gt; pathSum(TreeNode *root, int sum) {
           vector&lt; vector&lt;int&gt; &gt; results;
           vector&lt;int&gt; result;
           helper(root, sum, results,result);
           return results;
       }
  
   private:
       void helper(TreeNode *root, int sum, vector&lt;vector&lt;int&gt; &gt; &amp;paths,vector&lt;int&gt;&amp; path) {
           if (root == NULL) {
               return;
           }
           sum -= root-&gt;val;
           path.push_back(root-&gt;val);
           if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) {
               if (sum == 0) {
                   paths.push_back(path);
               }
           }
           else {
               if (root-&gt;left != NULL) {
                   helper(root-&gt;left, sum, paths,path);
               }
               if (root-&gt;right != NULL) {
                   helper(root-&gt;right, sum, paths,path);
               }
           }
           sum += root-&gt;val;
           path.pop_back();
       }
   };
</code></pre></div></li> <li><p>修剪一棵二叉搜索树，<a href="https://leetcode.com/problems/trim-a-binary-search-tree/description/" target="_blank" rel="noopener noreferrer">LeetCode-669-Trim a Binary Search Tree<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。题干明确说明了该树是一棵二叉搜索树，所以具有如下的性质：某个节点的左子树上的每个节点的值都比该节点值小，而右子树上的每个节点的值都比该节点值大。因此，如果判断出当前节点的值在[L,R]之间，那么该节点就是一个子树的根节点；如果当前节点的值大于 R，那么根节点需要从它的左子树中寻找；如果当前节点的值小于 L，那么根节点需要从它的右子树中寻找。</p> <div class="language- extra-class"><pre><code>  class Solution {
  public:
     TreeNode *trimBST(TreeNode *root ,int L, int R) {
         if (root == NULL) {
             return NULL;
         }
         if (root-&gt;val &lt;= R &amp;&amp; root-&gt;val &gt;= L) {
             root-&gt;left = trimBST(root-&gt;left, L, R);
             root-&gt;right = trimBST(root-&gt;right, L, R);
             return root;
         } else {
             if(root-&gt;val &gt; R) {
                 return trimBST(root-&gt;left,L,R);
             } else if (root-&gt;val &lt; L) {
                 return trimBST(root-&gt;right, L, R);
             }
         }
     }
  };
</code></pre></div></li> <li><p>求一棵二叉树的最大深度，<a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/description/" target="_blank" rel="noopener noreferrer">LeetCode-104-Maximum Depth of Binary Tree<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <div class="language- extra-class"><pre><code>  class Solution {
  public:
      int maxDepth(TreeNode* root) {
          if (root == NULL) {
              return 0;
          }
          return 1 + max(maxDepth(root-&gt;left),maxDepth(root-&gt;right));
      }
  };
</code></pre></div></li> <li><p>求一棵二叉树的最小深度，<a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/description/" target="_blank" rel="noopener noreferrer">LeetCode-111-Minimum Depth of Binary Tree<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。
思路与上一题类似，不过要注意的是如果一个节点的左孩子或者右孩子为空的话，那么以这个节点为根节点的子树的 minDepth 为它的左孩子或右孩子的 minDepth。</p> <div class="language- extra-class"><pre><code>  class Solution {
  public:
      int minDepth(TreeNode* root) {
          if (root == NULL) {
              return 0;
          }
          int left = minDepth(root-&gt;left);
          int right = minDepth(root-&gt;right);
          return (left == 0 || right == 0) ? (left+right+1):min(left,right)+1;
      }
  };
</code></pre></div></li> <li><p>翻转一棵二叉树，<a href="https://leetcode.com/problems/invert-binary-tree/description/" target="_blank" rel="noopener noreferrer">LeetCode-226-Invert Binary Tree<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <div class="language- extra-class"><pre><code>  class Solution {
  public:
      TreeNode *invertTree(TreeNode *root) {
          if (root == NULL) {
              return NULL;
          }
          // 先递归翻转该节点的左右子树
          root-&gt;right = invertTree(root-&gt;right);
          root-&gt;left = invertTree(root-&gt;left);
          // 再交换该节点的左右孩子
          TreeNode *node = root-&gt;left;
          root-&gt;left = root-&gt;right;
          root-&gt;right = node;
          
          
          return root;
      }
  };
</code></pre></div></li> <li><p>将一棵二叉搜索树变为一棵大树，<a href="https://leetcode.com/problems/convert-bst-to-greater-tree/description/" target="_blank" rel="noopener noreferrer">LeetCode-538-Convert BST to Greater Tree<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。也就是将一个节点的值更新为所有值大于该节点的节点的值之和。</p> <div class="language- extra-class"><pre><code>  class Solution {
  public:
      TreeNode * convertBST(TreeNode *root) {
          vector&lt;int&gt; nodes;
          record(root, nodes);
          helper(root, nodes);
          return root;
      }
  
  private:
      void record(TreeNode *root, vector&lt;int&gt; &amp;result) {
          if (root == NULL) {
              return;
          }
          result.push_back(root-&gt;val);
          record(root-&gt;left, result);
          record(root-&gt;right, result);
      }
      void helper(TreeNode *root, vector&lt;int&gt; &amp;result) {
          if (root == NULL) {
              return;
          }
          int value = root-&gt;val;
          vector&lt;int&gt;::iterator iter = result.begin();
          for(iter; iter != result.end();iter++) {
              if(*iter &gt; value) {
                  root-&gt;val += *iter;
              }
          }
          helper(root-&gt;left,result);
          helper(root-&gt;right,result);
      }
  };
</code></pre></div></li> <li><p>求一棵二叉树所有左叶子节点的数值之和，<a href="https://leetcode.com/problems/sum-of-left-leaves/description/" target="_blank" rel="noopener noreferrer">LeetCode-404-Sum of Left Leaves<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <div class="language- extra-class"><pre><code>   class Solution {
   public:
       int sumOfLeftLeaves(TreeNode *root) {
           if(root == NULL) {
               return 0;
           }
           
           // 当前节点的左孩子为叶子节点
           if (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) {
               return root-&gt;left-&gt;val + sumOfLeftLeaves(root-&gt;right);
           }
           
           return sumOfLeftLeaves(root-&gt;left)+sumOfLeftLeaves(root-&gt;right);
       }
   };
</code></pre></div></li> <li><p>对一棵二叉树进行层序遍历，<a href="https://leetcode.com/problems/binary-tree-level-order-traversal/description/" target="_blank" rel="noopener noreferrer">LeetCode-102-Binary Tree Level Order Traversal<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <div class="language- extra-class"><pre><code>  class Solution {
  public:
      vector&lt;vector&lt;int&gt;  &gt; levelOrder(TreeNode *root) {
          vector&lt;vector&lt;int&gt; &gt; result;
          levelTravel(root, 1, result);
          return result;
      }
  private:
      void levelTravel(TreeNode *root, int level, vector&lt;vector&lt;int&gt; &gt; &amp;result) {
          if (root == NULL) {
              return;
          }
          if (level &gt; result.size()) {
              result.push_back(vector&lt;int&gt;());
          }
          result[level-1].push_back(root-&gt;val);
          levelTravel(root-&gt;left, level+1, result);
          levelTravel(root-&gt;right, level+1, result);
      }
  }
</code></pre></div></li> <li><p>求一棵二叉树的根节点到各个叶子节点的路径表示的值的和，<a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/description/" target="_blank" rel="noopener noreferrer">LeetCode-129-Sum Root to Leaf Numbers<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>class Solution {
public:
    int sumNumbers(TreeNode* root) {
        return dfs(root, 0);
        
    }
    int dfs(TreeNode *root, int sum) {
        if (root == NULL) {
            return 0;
        }
        if (! root-&gt;left &amp;&amp; ! root-&gt;right) {
            return sum * 10 + root-&gt;val;
        }
        return dfs(root-&gt;left, sum * 10 + root-&gt;val) + dfs(root-&gt;right, sum * 10 + root-&gt;val);
    }
};
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/tamarous_blog/assets/js/app.2ca14050.js" defer></script><script src="/tamarous_blog/assets/js/2.cd603132.js" defer></script><script src="/tamarous_blog/assets/js/42.7175cd4e.js" defer></script>
  </body>
</html>
