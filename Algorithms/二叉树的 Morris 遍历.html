<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>二叉树的 Morris 遍历</title>
    <meta name="generator" content="VuePress 1.8.1">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/tamarous_blog/assets/css/0.styles.2918e61a.css" as="style"><link rel="preload" href="/tamarous_blog/assets/js/app.269f7156.js" as="script"><link rel="preload" href="/tamarous_blog/assets/js/2.cd603132.js" as="script"><link rel="preload" href="/tamarous_blog/assets/js/28.8544b050.js" as="script"><link rel="prefetch" href="/tamarous_blog/assets/js/10.26a5b427.js"><link rel="prefetch" href="/tamarous_blog/assets/js/11.ca60f1ab.js"><link rel="prefetch" href="/tamarous_blog/assets/js/12.14a6f17f.js"><link rel="prefetch" href="/tamarous_blog/assets/js/13.db4d1de1.js"><link rel="prefetch" href="/tamarous_blog/assets/js/14.899c5ca4.js"><link rel="prefetch" href="/tamarous_blog/assets/js/15.d0396fe4.js"><link rel="prefetch" href="/tamarous_blog/assets/js/16.50b40d7f.js"><link rel="prefetch" href="/tamarous_blog/assets/js/17.62cfbe2d.js"><link rel="prefetch" href="/tamarous_blog/assets/js/18.1ae3bf5c.js"><link rel="prefetch" href="/tamarous_blog/assets/js/19.6a77119a.js"><link rel="prefetch" href="/tamarous_blog/assets/js/20.236c8b53.js"><link rel="prefetch" href="/tamarous_blog/assets/js/21.2bfe940a.js"><link rel="prefetch" href="/tamarous_blog/assets/js/22.d9efe3b1.js"><link rel="prefetch" href="/tamarous_blog/assets/js/23.ebce0411.js"><link rel="prefetch" href="/tamarous_blog/assets/js/24.fabb82cb.js"><link rel="prefetch" href="/tamarous_blog/assets/js/25.c657f98a.js"><link rel="prefetch" href="/tamarous_blog/assets/js/26.32c42d96.js"><link rel="prefetch" href="/tamarous_blog/assets/js/27.1678b12c.js"><link rel="prefetch" href="/tamarous_blog/assets/js/29.1084cfe5.js"><link rel="prefetch" href="/tamarous_blog/assets/js/3.a98e93fb.js"><link rel="prefetch" href="/tamarous_blog/assets/js/30.a6d1035b.js"><link rel="prefetch" href="/tamarous_blog/assets/js/31.be5835b4.js"><link rel="prefetch" href="/tamarous_blog/assets/js/32.d4366367.js"><link rel="prefetch" href="/tamarous_blog/assets/js/33.2b200c99.js"><link rel="prefetch" href="/tamarous_blog/assets/js/34.f163deeb.js"><link rel="prefetch" href="/tamarous_blog/assets/js/35.0b851840.js"><link rel="prefetch" href="/tamarous_blog/assets/js/36.7ff07fed.js"><link rel="prefetch" href="/tamarous_blog/assets/js/37.2693764e.js"><link rel="prefetch" href="/tamarous_blog/assets/js/38.83899c91.js"><link rel="prefetch" href="/tamarous_blog/assets/js/39.10fe7048.js"><link rel="prefetch" href="/tamarous_blog/assets/js/4.c1d52a96.js"><link rel="prefetch" href="/tamarous_blog/assets/js/40.569e795b.js"><link rel="prefetch" href="/tamarous_blog/assets/js/41.23c7880d.js"><link rel="prefetch" href="/tamarous_blog/assets/js/42.099df540.js"><link rel="prefetch" href="/tamarous_blog/assets/js/43.c74e858f.js"><link rel="prefetch" href="/tamarous_blog/assets/js/44.0fc3638c.js"><link rel="prefetch" href="/tamarous_blog/assets/js/45.a3c0d604.js"><link rel="prefetch" href="/tamarous_blog/assets/js/46.2a672594.js"><link rel="prefetch" href="/tamarous_blog/assets/js/47.7e8f0cf5.js"><link rel="prefetch" href="/tamarous_blog/assets/js/48.1f54ffbe.js"><link rel="prefetch" href="/tamarous_blog/assets/js/49.e3e5f68b.js"><link rel="prefetch" href="/tamarous_blog/assets/js/5.6e3c4c72.js"><link rel="prefetch" href="/tamarous_blog/assets/js/50.4b3f35ab.js"><link rel="prefetch" href="/tamarous_blog/assets/js/51.3f804d6f.js"><link rel="prefetch" href="/tamarous_blog/assets/js/52.f125db44.js"><link rel="prefetch" href="/tamarous_blog/assets/js/6.75cdaa21.js"><link rel="prefetch" href="/tamarous_blog/assets/js/7.39046d4b.js"><link rel="prefetch" href="/tamarous_blog/assets/js/8.12f5371b.js"><link rel="prefetch" href="/tamarous_blog/assets/js/9.682ca412.js">
    <link rel="stylesheet" href="/tamarous_blog/assets/css/0.styles.2918e61a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/tamarous_blog/" class="home-link router-link-active"></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/tamarous_blog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/tamarous_blog/iOS/" class="nav-link">
  iOS
</a></div><div class="nav-item"><a href="/tamarous_blog/Algorithms/" class="nav-link router-link-active">
  Algorithms
</a></div> <a href="https://github.com/tamarous/tamarous_blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/tamarous_blog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/tamarous_blog/iOS/" class="nav-link">
  iOS
</a></div><div class="nav-item"><a href="/tamarous_blog/Algorithms/" class="nav-link router-link-active">
  Algorithms
</a></div> <a href="https://github.com/tamarous/tamarous_blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="二叉树的-morris-遍历"><a href="#二叉树的-morris-遍历" class="header-anchor">#</a> 二叉树的 Morris 遍历</h1> <blockquote><p>转载自：<a href="https://www.cnblogs.com/AnnieKim/archive/2013/06/15/MorrisTraversal.html" target="_blank" rel="noopener noreferrer">Morris Traversal方法遍历二叉树（非递归，不用栈，O(1)空间）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，有所修改。</p></blockquote> <p>Morris 遍历是由 Joseph Morris 于1979年发明的，这种遍历方法与递归以及非递归遍历方法相比，其时间复杂度为 O(n)，而空间复杂度只要 O(1)。在某些场合下，其空间复杂度为常数的特性非常有用，因此我们有必要了解和掌握它是如何实现的。</p> <h2 id="中序遍历"><a href="#中序遍历" class="header-anchor">#</a> 中序遍历</h2> <p>过程：</p> <ol><li>如果当前节点的左孩子为空，则输出当前节点并将当前节点更新为它的右孩子。</li> <li>如果当前节点的左孩子不为空，在当前节点的左子树中找到它的最右节点。</li> <li>(a) 如果最右节点的右孩子为空，将它的右孩子设置为当前节点，而当前节点更新为当前节点的左孩子。(b) 如果最右节点的右孩子为当前节点，那么将最右节点的右孩子设置为 NULL，输出当前节点，当前节点更新为当前节点的右孩子。</li> <li>重复上述过程，直到当前节点为 NULL。</li></ol> <div class="language- extra-class"><pre class="language-text"><code>class Solution {
public:
    void MorrisInOrder(TreeNode *root) {
        TreeNode *cur = head, *prev = NULL;
        while(cur != NULL) {
            if (cur-&gt;left == NULL) { // 1
                printf(&quot;%d &quot;,cur-&gt;val);
                cur = cur-&gt;right;
            } else {
                prev = cur-&gt;left;
                // 2
                while(prev-&gt;right != NULL &amp;&amp; prev-&gt;right != cur) {
                    prev = prev-&gt;right;
                }
                if (prev-&gt;right == NULL) { // 3.a
                    prev-&gt;right = cur;
                    cur = cur-&gt;left;
                } else {
                    prev-&gt;right = NULL;   // 3.b
                    printf(&quot;%d &quot;,cur-&gt;val);
                    cur = cur-&gt;right;
                }
            }
        }
    }
};
</code></pre></div><p>借用下<a href="http://www.cnblogs.com/anniekim/archive/2013/06/15/morristraversal.html" target="_blank" rel="noopener noreferrer">这篇博客<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>中的图片：</p> <p><img src="http://images.cnitblog.com/blog/300640/201306/14214057-7cc645706e7741e3b5ed62b320000354.jpg" alt="Morris InOrder"></p> <p>我们来看下以这幅图中的树为例，对其进行 Morris 中序遍历的过程。</p> <ol><li>cur = 6，左孩子不为空所以进入步骤2，cur 的左子树的最右节点是5，5的右孩子为空，所以让5的右孩子指向6，然后让 cur = 2。</li> <li>cur = 2，左孩子不为空进入步骤2，2的最右节点为1，1的右孩子为空，所以把1的右孩子设置为2，然后让 cur = 1。</li> <li>cur = 1，1的左孩子为空，所以进入步骤1，输出1，其右孩子为2，所以重新让 cur = 2。</li> <li>2的最右节点是1，而1的右孩子为2，所以将1的右孩子重新设置为空，然后输出2，让 cur = 4。</li> <li>cur = 4，左孩子不为空进入步骤2，4的最右节点为3，3的右孩子为空，所以把3的右孩子设置为4，然后让 cur = 3。</li> <li>cur = 3，左孩子为空，所以进入步骤1，输出3，由于3的右孩子为4，所以重新让 cur = 4。</li> <li>cur = 4，最右节点为3，3的右孩子为4，所以将3的节点重新设为空，然后输出4，让 cur = 5。</li> <li>cur = 5，左孩子为空，所以输出5，5的右孩子为6，因此让 cur = 6。</li></ol> <p>经历了以上几步，这棵树的左子树已经全部遍历完了。右子树的遍历和左子树是类似的，结合图片和上述过程应该比较容易理解了，就不在解释了。</p> <h2 id="前序遍历"><a href="#前序遍历" class="header-anchor">#</a> 前序遍历</h2> <p>前序遍历和中序遍历的过程基本一样，唯一的不同点在于打印的位置不同。过程：</p> <ol><li>如果当前节点的左节点为空，那么输出当前节点并将当前节点更新为它的右孩子。</li> <li>如果当前节点的左节点不为空，在当前节点的左子树中找到它的最右节点。</li> <li>(a) 如果最右节点的右孩子为空，将它的右孩子设置为当前节点。<strong>输出当前节点(与中序遍历唯一的不同点)</strong>，将当前节点更新为当前节点的左孩子。(b) 如果最右节点的右孩子为当前节点，那么将它的右孩子重新设置为空，然后将当前节点更新为当前节点的右孩子。</li> <li>重复上述过程，直到当前节点为 NULL。</li></ol> <div class="language- extra-class"><pre class="language-text"><code>class Solution {
public:
    void MorrisPreOrder(TreeNode *root) {
        TreeNode *cur = head, *prev = NULL;
        while(cur != NULL) {
            if (cur-&gt;left == NULL) { // 1
                printf(&quot;%d &quot;,cur-&gt;val);
                cur = cur-&gt;right;
            } else {
                prev = cur-&gt;left;
                
                while(prev-&gt;right != NULL &amp;&amp; prev-&gt;right != cur) { // 2
                    prev = prev-&gt;right;
                }
                if (prev-&gt;right == NULL) { // 3.a
                    prev-&gt;right = cur;
                    printf(&quot;%d &quot;,cur-&gt;val);
                    cur = cur-&gt;left;
                } else {
                    prev-&gt;right = NULL;   // 3.b
                    cur = cur-&gt;right;
                }
            }
        }
    }
};
</code></pre></div><p><img src="http://images.cnitblog.com/blog/300640/201306/14221458-aa5f9e92cce743ccacbc735048133058.jpg" alt="Morris PreOrder"></p> <h2 id="后序遍历"><a href="#后序遍历" class="header-anchor">#</a> 后序遍历</h2> <p>后续遍历又是最为复杂的一个。我们需要建立一个额外节点 dummy，然后将根节点设置为dummy 的左孩子。过程：</p> <ol><li>建立一个额外节点 dummy，然后将根节点设置为 dummy 的左孩子。</li> <li>如果当前节点的左孩子为空，则将其右孩子作为当前节点。</li> <li>如果当前节点的左孩子不为空，在当前节点的左子树中找到它的最右节点。</li> <li>(a) 如果最右节点的右孩子为空，则将最右节点的右孩子设置为当前节点，而当前节点更新为当前节点的左孩子。(b) 如果最右节点的右孩子为当前节点，将它的右孩子重新设为空。<strong>倒序输出从当前节点的左孩子到该最右节点路径上的所有节点</strong>，然后将当前节点更新为当前节点的右孩子。</li> <li>重复以上过程，直到当前节点为NULL。</li></ol> <div class="language- extra-class"><pre class="language-text"><code>class Solution {
public:
    void MorrisPostOrder(TreeNode *root) {
        TreeNode *dummy = new TreeNode(0);
        dummy-&gt;left = root;
        TreeNode *cur = dummy, *prev = NULL;
        while(cur != NULL) {
            if (cur-&gt;left == NULL) {
                cur = cur-&gt;right;
            } else {
                prev = cur-&gt;left;
                
                while(prev-&gt;right != NULL &amp;&amp; prev-&gt;right != cur) { 
                    prev = prev-&gt;right;
                }
                if (prev-&gt;right == NULL) { 
                    prev-&gt;right = cur;
                    cur = cur-&gt;left;
                } else {
                    printReverse(cur-&gt;left, prev);
                    prev-&gt;right = NULL;
                    cur = cur-&gt;right;
                }
            }
        }
    }
    
    void reverse(TreeNode *from, TreeNode *to) {
        if (from == to) {
            return;
        }
        TreeNode *x = from, *y = from-&gt;right, *z;
        while (true) {
            z = y-&gt;right;
            y-&gt;right = x;
            x = y;
            y = z;
            if (x == to)
                break;
        }
    }

    void printReverse(TreeNode* from, TreeNode *to) {
        reverse(from, to);
        
        TreeNode *p = to;
        while (true) {
            printf(&quot;%d &quot;, p-&gt;val);
            if (p == from)
                break;
            p = p-&gt;right;
        }
        
        reverse(to, from);
    }
};
</code></pre></div><p><img src="http://images.cnitblog.com/blog/300640/201306/15165951-7991525829134fb3beefed9fbf7e0536.jpg" alt="Morris PostOrder"></p> <p>下面以图中的树为例，分析下 Morris 后序遍历的过程。</p> <ol><li>新建一个额外节点0，将它设为当前节点，然后将根节点9设置为它的左孩子。</li> <li>cur = 0，它的左孩子不为空，在0的左子树中寻找最右节点，为7。</li> <li>因为7的右孩子为空，所以将7的右孩子设置为当前节点0，然后将当前节点0更新为0的左孩子9。</li> <li>cur = 9，由于9的左孩子不为空，因此在9的左子树中寻找它的最右节点，为3。</li> <li>因为3的右孩子为空，所以将3的右孩子设置为当前节点9，然后将当前节点9更新为9的左孩子5。</li> <li>cur = 5，它的左孩子不为空，在5的左子树中找到最右节点，为1。</li> <li>因为1的右孩子为空，所以把1的右孩子设置为当前节点5，然后将当前节点5更新为5的左孩子1。</li> <li>cur = 1，当前节点1的左孩子为空，所以将1的右孩子5设置为当前节点。</li> <li>cur = 5，它的左孩子不为空，在5的左子树中寻找最后节点，为1。</li> <li>因为1的右孩子为5，是当前节点，因此将1的右孩子重新设为空，然后倒序输出从5的左孩子1到1的节点，即输出1，然后将当前节点5更新为当前节点的右孩子4。</li> <li>当前节点4的左孩子不为空，因此在4的左子树中寻找最右节点，为2。</li> <li>2的右孩子为空，因此将2的右孩子设置为当前节点4，然后将当前节点设置为当前节点的左孩子2。</li> <li>cur = 2，因为当前节点的左孩子为空，所以将2的右孩子4设置为当前节点。</li> <li>cur = 4，由11的结果，它的最右节点为2。</li> <li>因为2的右孩子为4，是当前节点，因此将2的右孩子重新设置为空，然后倒序输出从4的左孩子2到2的节点，即输出2，然后将当前节点4更新为当前节点的右孩子3。</li> <li>cur = 3，因为当前节点的左孩子为空，因此将3的右孩子9设置为当前节点。</li> <li>cur = 9，因为9的左孩子不为空，所以在它的左子树中寻找它的最右节点，为3。</li> <li>因为3的右孩子9为当前节点，因此将3的右孩子重新设置为空，然后倒序输出从9的左孩子5到3的节点，即输出3、4、5。</li> <li>至此，9的左子树已经遍历输出完毕。后续遍历右子树的过程和遍历左子树基本一样，因此不再赘述。</li></ol></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/tamarous_blog/assets/js/app.269f7156.js" defer></script><script src="/tamarous_blog/assets/js/2.cd603132.js" defer></script><script src="/tamarous_blog/assets/js/28.8544b050.js" defer></script>
  </body>
</html>
