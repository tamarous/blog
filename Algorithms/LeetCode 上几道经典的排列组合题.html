<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>LeetCode 上几道经典的排列组合题</title>
    <meta name="generator" content="VuePress 1.8.1">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/tamarous_blog/assets/css/0.styles.2918e61a.css" as="style"><link rel="preload" href="/tamarous_blog/assets/js/app.2ca14050.js" as="script"><link rel="preload" href="/tamarous_blog/assets/js/2.cd603132.js" as="script"><link rel="preload" href="/tamarous_blog/assets/js/7.39046d4b.js" as="script"><link rel="prefetch" href="/tamarous_blog/assets/js/10.26a5b427.js"><link rel="prefetch" href="/tamarous_blog/assets/js/11.ca60f1ab.js"><link rel="prefetch" href="/tamarous_blog/assets/js/12.14a6f17f.js"><link rel="prefetch" href="/tamarous_blog/assets/js/13.db4d1de1.js"><link rel="prefetch" href="/tamarous_blog/assets/js/14.899c5ca4.js"><link rel="prefetch" href="/tamarous_blog/assets/js/15.d0396fe4.js"><link rel="prefetch" href="/tamarous_blog/assets/js/16.b7711d40.js"><link rel="prefetch" href="/tamarous_blog/assets/js/17.1525986f.js"><link rel="prefetch" href="/tamarous_blog/assets/js/18.1ae3bf5c.js"><link rel="prefetch" href="/tamarous_blog/assets/js/19.6a77119a.js"><link rel="prefetch" href="/tamarous_blog/assets/js/20.236c8b53.js"><link rel="prefetch" href="/tamarous_blog/assets/js/21.2bfe940a.js"><link rel="prefetch" href="/tamarous_blog/assets/js/22.d9efe3b1.js"><link rel="prefetch" href="/tamarous_blog/assets/js/23.ebce0411.js"><link rel="prefetch" href="/tamarous_blog/assets/js/24.fabb82cb.js"><link rel="prefetch" href="/tamarous_blog/assets/js/25.c657f98a.js"><link rel="prefetch" href="/tamarous_blog/assets/js/26.32c42d96.js"><link rel="prefetch" href="/tamarous_blog/assets/js/27.1678b12c.js"><link rel="prefetch" href="/tamarous_blog/assets/js/28.8544b050.js"><link rel="prefetch" href="/tamarous_blog/assets/js/29.1084cfe5.js"><link rel="prefetch" href="/tamarous_blog/assets/js/3.a98e93fb.js"><link rel="prefetch" href="/tamarous_blog/assets/js/30.a6d1035b.js"><link rel="prefetch" href="/tamarous_blog/assets/js/31.be5835b4.js"><link rel="prefetch" href="/tamarous_blog/assets/js/32.ed1baeea.js"><link rel="prefetch" href="/tamarous_blog/assets/js/33.1c5e69b5.js"><link rel="prefetch" href="/tamarous_blog/assets/js/34.e6785929.js"><link rel="prefetch" href="/tamarous_blog/assets/js/35.a2c5c07e.js"><link rel="prefetch" href="/tamarous_blog/assets/js/36.bf8c6fae.js"><link rel="prefetch" href="/tamarous_blog/assets/js/37.4aa9a168.js"><link rel="prefetch" href="/tamarous_blog/assets/js/38.1b71fc14.js"><link rel="prefetch" href="/tamarous_blog/assets/js/39.55b4068e.js"><link rel="prefetch" href="/tamarous_blog/assets/js/4.c1d52a96.js"><link rel="prefetch" href="/tamarous_blog/assets/js/40.0fccb135.js"><link rel="prefetch" href="/tamarous_blog/assets/js/41.69995d1e.js"><link rel="prefetch" href="/tamarous_blog/assets/js/42.7175cd4e.js"><link rel="prefetch" href="/tamarous_blog/assets/js/43.ddd52948.js"><link rel="prefetch" href="/tamarous_blog/assets/js/44.2d7d9586.js"><link rel="prefetch" href="/tamarous_blog/assets/js/45.fb12614e.js"><link rel="prefetch" href="/tamarous_blog/assets/js/46.073425dd.js"><link rel="prefetch" href="/tamarous_blog/assets/js/47.844aae45.js"><link rel="prefetch" href="/tamarous_blog/assets/js/48.79b582e5.js"><link rel="prefetch" href="/tamarous_blog/assets/js/49.0c435f5a.js"><link rel="prefetch" href="/tamarous_blog/assets/js/5.6e3c4c72.js"><link rel="prefetch" href="/tamarous_blog/assets/js/50.6786a861.js"><link rel="prefetch" href="/tamarous_blog/assets/js/51.08fa9cb7.js"><link rel="prefetch" href="/tamarous_blog/assets/js/52.7bd74568.js"><link rel="prefetch" href="/tamarous_blog/assets/js/6.75cdaa21.js"><link rel="prefetch" href="/tamarous_blog/assets/js/8.12f5371b.js"><link rel="prefetch" href="/tamarous_blog/assets/js/9.682ca412.js">
    <link rel="stylesheet" href="/tamarous_blog/assets/css/0.styles.2918e61a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/tamarous_blog/" class="home-link router-link-active"></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/tamarous_blog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/tamarous_blog/iOS/" class="nav-link">
  iOS
</a></div><div class="nav-item"><a href="/tamarous_blog/Algorithms/" class="nav-link router-link-active">
  Algorithms
</a></div> <a href="https://github.com/tamarous/tamarous_blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/tamarous_blog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/tamarous_blog/iOS/" class="nav-link">
  iOS
</a></div><div class="nav-item"><a href="/tamarous_blog/Algorithms/" class="nav-link router-link-active">
  Algorithms
</a></div> <a href="https://github.com/tamarous/tamarous_blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="leetcode-上几道经典的排列组合题"><a href="#leetcode-上几道经典的排列组合题" class="header-anchor">#</a> LeetCode 上几道经典的排列组合题</h1> <p>LeetCode 上有几道题都和排列组合有关，非常经典，值得放在一起总结一下。这几道题分别是：</p> <ul><li><a href="https://leetcode.com/problems/permutations/description/" target="_blank" rel="noopener noreferrer">Permutations<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。给定一组各不相同的数字，求这些数字的所有排列。</li> <li><a href="https://leetcode.com/problems/permutations-ii/" target="_blank" rel="noopener noreferrer">Permutations II<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。给定一组数字，这些数字中可能有重复的，求这些数字的所有不重复的排列。</li> <li><a href="https://leetcode.com/problems/next-permutation/description/" target="_blank" rel="noopener noreferrer">Next Permutation<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。给定一组数字的全排列中的一个排列，求这个排列的下一个排列。</li> <li><a href="https://leetcode.com/problems/permutation-sequence/description/" target="_blank" rel="noopener noreferrer">Permutation Sequence<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。给定一组数字和一个数字 K，求这组数字的全排列中，按照字典序顺序排序的第 K 个排列。</li></ul> <h2 id="permutations"><a href="#permutations" class="header-anchor">#</a> Permutations</h2> <p>对于一个集合来说，它的全排列是指集合内元素的所有可能的排列。以输入<code>[1,2,3]</code>为例，它的全排列是<code>[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code>这六种情况。求一个集合的全排列有很多种方法，本文中将介绍一下最为常见的两种方法，字典序法和递归法。</p> <h3 id="字典序法"><a href="#字典序法" class="header-anchor">#</a> 字典序法</h3> <p>字典序法，就是将元素按照字典的顺序进行排列，而对于数字来说，就是将较小的数字排在较大的数字的前面。上面列出的<code>[1,2,3]</code>的全排列就是按照字典序的顺序排列的。由输入排列产生下一排列时，字典序法要求它与当前排列有尽可能长的公共前缀，因此针对输入的<code>1,2,3</code>，使用字典序法生成全排列，就是依次生成<code>1,3,2</code>，<code>2,1,3</code>，<code>2,3,1</code>，<code>3,1,2</code>，<code>3,2,1</code>。那么如何根据当前排列来生成下一排列呢？</p> <p>已知当前排列，求下一排列的算法过程：</p> <ol><li>对于给定排列nums,从左向右，找出第一个违反从左到右是递增顺序的数字，记为i。以<code>[6,8,7,4,3,2]</code>为例，从右向左一直是增加的，直到6的出现打破了这一规律，因此i = 6。</li> <li>从右向左，找出第一个比刚刚找到的数字大的数字，记为j。对于<code>[6,8,7,4,3,2]</code>，从右到左一次是2,3,4,7，因此这个数字是7，j=7。</li> <li>交换这两个数字。即将<code>[6,8,7,4,3,2]</code>中的6和7进行交换，变为<code>[7,8,6,4,3,2]</code>。</li> <li>将j右边的所有数字进行逆序，即将7右边的<code>[8,6,4,3,2]</code>逆序，<code>[7,8,6,4,3,2]</code>变为<code>[7,2,3,4,6,8]</code>。算法结束。</li></ol> <p>这里引用一下<a href="http://fisherlei.blogspot.com/2012/12/leetcode-next-permutation.html" target="_blank" rel="noopener noreferrer">水中的鱼<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的图片，可以对整个过程有更加直观的认识：
<img src="http://4.bp.blogspot.com/-4zN0u5JG0vs/UN0xPEkP5yI/AAAAAAAAG9Q/O48ZfwB1i_c/s1600/Picture4.png" alt="水中的鱼"></p> <div class="language- extra-class"><pre class="language-text"><code>class Solution {
public:
    void nextPermutation(vector&lt;int&gt;&amp; nums) {
        if (nums.size() &lt;= 0) {
            return;
        }
        int size = nums.size();
        int violationIndex = size-1;
        while(violationIndex &gt; 0) {
            if (nums[violationIndex] &gt; nums[violationIndex-1]) {
                break;
            } 
            violationIndex --;
        } 
        if (violationIndex &gt; 0) {
            violationIndex--;
            int changeIndex = size -1 ;
            for(;changeIndex&gt;= 0 ;changeIndex--) {
                if (nums[changeIndex] &gt; nums[violationIndex]) {
                    break;
                }
            }
            swap(nums[changeIndex],nums[violationIndex]);   
            violationIndex++;
        }
        reverse(nums.begin()+violationIndex, nums.end());
    }  
};
</code></pre></div><p>另外其实在 STL 中也有一个<code>next_permutation</code>算法，它的源代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>template &lt;class _Compare, class _BidirectionalIterator&gt;
bool
__next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{
    _BidirectionalIterator __i = __last;
    if (__first == __last || __first == --__i)
        return false;
    while (true)
    {
        _BidirectionalIterator __ip1 = __i;
        if (__comp(*--__i, *__ip1))
        {
            
            _BidirectionalIterator __j = __last;
            while (!__comp(*__i, *--__j))
                ;
            swap(*__i, *__j);
            _VSTD::reverse(__ip1, __last);
            return true;
        }
        if (__i == __first)
        {
            _VSTD::reverse(__first, __last);
            return false;
        }
    }
}
</code></pre></div><p>从代码中我们可以看出 STL 中的这个算法也是按照上述步骤来实现的。</p> <p>通过对当前排列不断调用上述算法求出其下一排列，再令求出的排列为当前排列，就可以得到一个基于字典序的全排列了。</p> <h3 id="递归法"><a href="#递归法" class="header-anchor">#</a> 递归法</h3> <p>从集合中依次选出每一个元素，作为排列的第一个元素，然后对剩余的元素进行全排列，如此递归处理，从而得到所有元素的全排列。以对<code>[1,2,3]</code>进行全排列为例，我们可以这么做：</p> <p>固定1，求后面23的排列：<code>[1,2,3]</code>，<code>[1,3,2]</code>；
固定2，求后面13的排列：<code>[2,1,3]</code>，<code>[2,3,1]</code>；
固定3，求后面21的排列：<code>[3,2,1]</code>，<code>[3,1,2]</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) {
        vector&lt;vector&lt;int&gt; &gt; result;
        if (nums.size() &lt;= 0) {
            return result;
        }
        // 从索引号为0的元素开始，到最后一个元素截止
        permutation(result,nums,0,nums.size());
        return result;
    }
    
    // p 表示从索引为 p 的元素开始逐一与后面的元素交换，q 表示最后一个元素的索引
    void permutation(vector&lt;vector&lt;int&gt; &gt; &amp;results,vector&lt;int&gt; &amp;nums, int i, int j) {
        // 如果当前元素已经是最后一个元素了，那么nums 存放了一个全新的排列，此时应该回溯返回
        if(i == j-1) {
            results.push_back(nums);
            return;
        }
        for(int k = i; k &lt; j; k++) {
            swap(nums, i, k);
            permutation(results,nums,i+1, j);
            swap(nums, i, k);
        }
    }
    
    void swap(vector&lt;int&gt; &amp;nums, int i, int k) {
        int temp = nums[i];
        nums[i] = nums[k];
        nums[k] = temp;
    }
};
</code></pre></div><h2 id="permutations-ii"><a href="#permutations-ii" class="header-anchor">#</a> Permutations II</h2> <p>我们选用递归法的框架。首先需要对输入进行排序，以将所有有重复的数字安排在相邻的位置。之后代码的处理过程就和上面的问题类似了，具体实现请看下面的代码和注释。</p> <div class="language- extra-class"><pre class="language-text"><code>class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) {
        vector&lt;vector&lt;int&gt; &gt; results;
        sort(nums.begin(), nums.end());
        permutation(results, nums, 0, nums.size()-1);
        return results;
    }
    
    // 注意 nums 的参数传递方式是值传递而非引用传递
    void permutation(vector&lt;vector&lt;int&gt; &gt; &amp;results, vector&lt;int&gt; nums, int i , int j )  {
        if (i == j) {
            results.push_back(nums);
            return;
        } else {
            for(int k = i; k &lt; j; k++) {
            
                // 因为已经对输入进行排序，将重复的数字安排在相邻的位置，所以如果nums[i] == nums[k]，就表示遇到重复数字了，可以跳过
                if (i != k &amp;&amp; nums[i] == nums[k]) {
                    continue;
                }
                swap(nums, i, k);
                backtrace(results, nums, i+1, j);
            }
        }
    }
    
    void swap(vector&lt;int&gt; &amp;nums, int i, int k) {
        int temp = nums[i];
        nums[i] = nums[k];
        nums[k] = temp;
    }

};
</code></pre></div><h2 id="next-permutation"><a href="#next-permutation" class="header-anchor">#</a> Next Permutation</h2> <p>给定一组数字的全排列中的一个排列，求这个排列的下一个排列。这个题其实就是全排列的字典序法中的一个子步骤，在上文中已经介绍过了，因此不再赘述。</p> <h2 id="permutation-sequence"><a href="#permutation-sequence" class="header-anchor">#</a> Permutation Sequence</h2> <p>对于一个集合<code>[1,2,3,...,n]</code>来说，它的全排列有n!种。现在给定n 和 k，求<code>[1,2,3,...,n]</code>的全排列中的第k个排列。</p> <p>其实这个题目的解法非常简单，直接利用利用求下一排列的算法即可：维护一个从1开始的计数器，当计数器的数值小于 K 时，就重复计算下一排列并将计数器加一，当计数器数值为 k 时停止，此时计算出的排列就是第 K 个排列。</p> <div class="language- extra-class"><pre class="language-text"><code>class Solution {
public:
	int maxOfK() {
		int result = 1;
		for(int i = 1; i &lt; 10 ;i++) {
			result *= i;
		}
		return result;
	}
	string getString(int n) {
		int i = 1;
		string s = to_string(i);
		while(++i &lt;= n) {
			s += to_string(i);
		}
		return s;
	}
	string getPermutation(int n, int k) {
		string s;
		if (k &lt;= 0 || k &gt; maxOfK()) {
			return s;
		}
		
		// 输入n,那么s=&quot;123...n&quot;
		s = getString(n);
		int i = 1;
		while(i++ &lt; k) {
		   // 通过 STL 函数来对 s 进行排列，这个排列是按照字典序进行的
			std::next_permutation(s.begin(),s.end());
		}
		return s;
	}
};
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/tamarous_blog/assets/js/app.2ca14050.js" defer></script><script src="/tamarous_blog/assets/js/2.cd603132.js" defer></script><script src="/tamarous_blog/assets/js/7.39046d4b.js" defer></script>
  </body>
</html>
