<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>单链表问题总结</title>
    <meta name="generator" content="VuePress 1.8.1">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.e4d8b86b.css" as="style"><link rel="preload" href="/assets/js/app.cdf84e36.js" as="script"><link rel="preload" href="/assets/js/2.cd603132.js" as="script"><link rel="preload" href="/assets/js/30.a6d1035b.js" as="script"><link rel="prefetch" href="/assets/js/10.fa04d7da.js"><link rel="prefetch" href="/assets/js/11.e05d5cca.js"><link rel="prefetch" href="/assets/js/12.14a6f17f.js"><link rel="prefetch" href="/assets/js/13.db4d1de1.js"><link rel="prefetch" href="/assets/js/14.899c5ca4.js"><link rel="prefetch" href="/assets/js/15.d0396fe4.js"><link rel="prefetch" href="/assets/js/16.b7711d40.js"><link rel="prefetch" href="/assets/js/17.1525986f.js"><link rel="prefetch" href="/assets/js/18.1ae3bf5c.js"><link rel="prefetch" href="/assets/js/19.6a77119a.js"><link rel="prefetch" href="/assets/js/20.236c8b53.js"><link rel="prefetch" href="/assets/js/21.2bfe940a.js"><link rel="prefetch" href="/assets/js/22.d9efe3b1.js"><link rel="prefetch" href="/assets/js/23.ebce0411.js"><link rel="prefetch" href="/assets/js/24.fabb82cb.js"><link rel="prefetch" href="/assets/js/25.c657f98a.js"><link rel="prefetch" href="/assets/js/26.32c42d96.js"><link rel="prefetch" href="/assets/js/27.1678b12c.js"><link rel="prefetch" href="/assets/js/28.8544b050.js"><link rel="prefetch" href="/assets/js/29.1084cfe5.js"><link rel="prefetch" href="/assets/js/3.a98e93fb.js"><link rel="prefetch" href="/assets/js/31.be5835b4.js"><link rel="prefetch" href="/assets/js/32.d4366367.js"><link rel="prefetch" href="/assets/js/33.2b200c99.js"><link rel="prefetch" href="/assets/js/34.f163deeb.js"><link rel="prefetch" href="/assets/js/35.0b851840.js"><link rel="prefetch" href="/assets/js/36.7ff07fed.js"><link rel="prefetch" href="/assets/js/37.2693764e.js"><link rel="prefetch" href="/assets/js/38.6d5e99f9.js"><link rel="prefetch" href="/assets/js/39.d396e830.js"><link rel="prefetch" href="/assets/js/4.c1d52a96.js"><link rel="prefetch" href="/assets/js/40.569e795b.js"><link rel="prefetch" href="/assets/js/41.23c7880d.js"><link rel="prefetch" href="/assets/js/42.099df540.js"><link rel="prefetch" href="/assets/js/43.c74e858f.js"><link rel="prefetch" href="/assets/js/44.0fc3638c.js"><link rel="prefetch" href="/assets/js/45.a3c0d604.js"><link rel="prefetch" href="/assets/js/46.2a672594.js"><link rel="prefetch" href="/assets/js/47.7e8f0cf5.js"><link rel="prefetch" href="/assets/js/48.1f54ffbe.js"><link rel="prefetch" href="/assets/js/49.e3e5f68b.js"><link rel="prefetch" href="/assets/js/5.6e3c4c72.js"><link rel="prefetch" href="/assets/js/50.4b3f35ab.js"><link rel="prefetch" href="/assets/js/51.3f804d6f.js"><link rel="prefetch" href="/assets/js/52.f125db44.js"><link rel="prefetch" href="/assets/js/6.75cdaa21.js"><link rel="prefetch" href="/assets/js/7.39046d4b.js"><link rel="prefetch" href="/assets/js/8.12f5371b.js"><link rel="prefetch" href="/assets/js/9.c3f94571.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e4d8b86b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/iOS/" class="nav-link">
  iOS
</a></div><div class="nav-item"><a href="/Algorithms/" class="nav-link router-link-active">
  Algorithms
</a></div> <a href="https://github.com/tamarous/tamarous_blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/iOS/" class="nav-link">
  iOS
</a></div><div class="nav-item"><a href="/Algorithms/" class="nav-link router-link-active">
  Algorithms
</a></div> <a href="https://github.com/tamarous/tamarous_blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="单链表问题总结"><a href="#单链表问题总结" class="header-anchor">#</a> 单链表问题总结</h1> <p>这两天比较闲，因此刷了几道HackerRank上的题目，下面就将单链表的一些题目总结一下。首先给出这些题目中通用的单链表节点定义：</p> <div class="language- extra-class"><pre><code>struct Node {
    int data;
    struct Node *next;
}
</code></pre></div><p>第一题：顺序打印单链表中的元素。
思路：从头节点处开始遍历输出，直至NULL。
代码：</p> <div class="language- extra-class"><pre><code>void Print(Node *head)
{
    if (head == NULL) {
        return;
    } 
    Node *ptr = head;
    while(ptr != NULL) {
        cout &lt;&lt; ptr-&gt;data &lt;&lt; endl;
        ptr = ptr-&gt;next;
    }
}
</code></pre></div><p>第二题：给定一个数值，生成一个新数值并插入到单链表的尾部。
思路：遍历到尾节点，然后创建一个新的节点，让尾节点的next指针指向这个新的节点。
代码：</p> <div class="language- extra-class"><pre><code>Node* Insert(Node *head,int data)
{
    Node *newCell = (Node *)malloc(sizeof(Node));
    newCell-&gt;data = data;
    newCell-&gt;next = NULL;
    if (head == NULL) {
        return newCell;
    } else {
        Node *tail = head;
        while(tail-&gt;next != NULL) {
            tail = tail-&gt;next;
        }
        tail-&gt;next = newCell;
        return head;
    }
}
</code></pre></div><p>第三题：给定一个数值，生成一个新节点插入到单链表的头部。
思路：创建一个新的节点，让这个新节点的next指针指向原来链表的头部。
代码：</p> <div class="language- extra-class"><pre><code>Node* Insert(Node *head,int data)
{
    Node *newCell = (Node *)malloc(sizeof(Node));
    newCell-&gt;data = data;
    if (head == NULL) {
        newCell-&gt;next = NULL;
        return newCell;
    } else {
        newCell-&gt;next = head;
        return newCell;
    }
}
</code></pre></div><p>第四题：给定一个位置和数值，生成一个新节点并插入到单链表的相应位置处。
思路：保持一个计数器，然后开始遍历单链表，同时计数器进行更新，当计数器的值与位置相等时，表示找到了要插入的位置了，之后的做法类似于第三题。
代码：</p> <div class="language- extra-class"><pre><code>Node* InsertNth(Node *head, int data, int position)
{ 
    Node *newCell = (Node *)malloc(sizeof(Node));
    newCell-&gt;data = data;
    if (head == NULL) {
        newCell-&gt;next = NULL;
        return newCell;
    } else {
        if (position == 0) {
            newCell-&gt;next = head;
            return newCell;
        } else {
            int i = 1;
            Node *ptr = head;
            while(ptr != NULL &amp;&amp; i != position) {
                i++;
                ptr = ptr-&gt;next;
            }
            newCell-&gt;next = ptr-&gt;next;
            ptr-&gt;next = newCell;
            return head;
        }
    }
}
</code></pre></div><p>第五题：从单链表中删除一个给定位置处的节点。
思路：很简单，不多说了。
代码：</p> <div class="language- extra-class"><pre><code>Node* Delete(Node *head, int position)
{
    if (head == NULL) {
        return NULL;
    } else {
        Node *ptrToNode;
        if (position == 0) {
            ptrToNode = head-&gt;next;
            free(head);
            return ptrToNode;
        } else {
            int i = 1;
            ptrToNode = head;
            while(ptrToNode != NULL &amp;&amp; i != position) {
                i++;
                ptrToNode = ptrToNode-&gt;next;
            }
            Node *temp = ptrToNode-&gt;next;
            ptrToNode-&gt;next = temp-&gt;next;
            free(temp);
            return head;
        }
    }
}
</code></pre></div><p>第六题：逆序打印单链表中的元素。
思路：使用递归。
代码：</p> <div class="language- extra-class"><pre><code>void ReversePrint(Node *head)
{
      if(head) {
        ReversePrint(head-&gt;next);
        cout &lt;&lt; head-&gt;data &lt;&lt; endl;
    } else {
        return;
    }
}
</code></pre></div><p>第七题：将一个单链表中的所有元素逆序。
思路：首先需要确定这个单链表是带有头节点的还是不带有头节点的，带有头节点的链表在处理起来稍微复杂一点。然后可以用三个指针，分别指向当前节点cur，前一个节点pre，后一个节点next，然后调整这三个节点之间的指向关系。
代码：</p> <div class="language- extra-class"><pre><code>Node* Reverse(Node *head)
{
    if (head == NULL) {
        return NULL;
    } else {
        Node *reverseHead = NULL;
        Node *cur = head;
        Node *pre = NULL;
        Node *next = NULL;
        while(cur != NULL) {
            next = cur-&gt;next;
            if (next == NULL) {
                reverseHead = cur;
            }
            cur-&gt;next = pre;
            pre = cur;
            cur = next;
        }
        return reverseHead;
    }
}
</code></pre></div><p>第八题：比较两个单链表中的元素是否相同
思路：用两个指针分别遍历两个链表，然后比较指针指向的节点数值是否相等。
代码：</p> <div class="language- extra-class"><pre><code>int CompareLists(Node *headA, Node* headB)
{
    if(headA == NULL &amp;&amp; headB == NULL) {
        return 0;
    } else if ((!headA &amp;&amp; headB) || (headA &amp;&amp; !headB)){
        return 0;
    } else {
            Node *ptrToA = headA, *ptrToB = headB;
            while(ptrToA &amp;&amp; ptrToB &amp;&amp; (ptrToA-&gt;data == ptrToB-&gt;data)) {
                ptrToA = ptrToA-&gt;next;
                ptrToB = ptrToB-&gt;next;
            }
            if(ptrToA == NULL &amp;&amp; ptrToB == NULL) {
                return 1;
            } else {
                return 0;
            }
    }
}
</code></pre></div><p>第九题：合并两个有序单链表，将合并的结果放在一个新链表中。
思路：用两个指针来分别遍历两个链表，比较这两个指针指向的节点的数值大小，
若A&lt;B,那么A++,拷贝A的数据到C,直到A&gt;B;若A&gt;B,则B++,拷贝B的数据到C,直到B&gt;A;若A==B,则A++,B++,拷贝A或B到C。若其中一条链表先遍历完，则将另一条链表的数据直接拷贝到C中。
代码：</p> <div class="language- extra-class"><pre><code>Node* MergeLists(Node *headA, Node* headB)
{
  if (headA == NULL &amp;&amp; headB == NULL) {
        return NULL;
    } else if (! headA &amp;&amp; headB) {
        return headB;
    } else if (headA &amp;&amp; !headB) {
        return headA;
    } else {
        Node *ptrToA = headA, *ptrToB = headB;
        Node *cur = (Node *)malloc(sizeof(Node));
        Node *head = cur;
        while(ptrToA &amp;&amp; ptrToB) {
            while(ptrToA &amp;&amp; ptrToB &amp;&amp; (ptrToA-&gt;data &lt; ptrToB-&gt;data)) {
                Node *newCell = (Node *)malloc(sizeof(Node));
                newCell-&gt;data = ptrToA-&gt;data;
                cur-&gt;next = newCell;
                cur = newCell;
                ptrToA = ptrToA-&gt;next;
            }
            while(ptrToA &amp;&amp; ptrToB &amp;&amp; (ptrToA-&gt;data &gt; ptrToB-&gt;data)) {
                Node *newCell = (Node *)malloc(sizeof(Node));
                newCell-&gt;data = ptrToB-&gt;data;
                cur-&gt;next = newCell;
                cur = newCell;
                ptrToB = ptrToB-&gt;next;
            }
            while(ptrToA &amp;&amp; ptrToB &amp;&amp; (ptrToA-&gt;data == ptrToB-&gt;data)) {
                Node *newCell = (Node *)malloc(sizeof(Node));
                newCell-&gt;data = ptrToA-&gt;data;
                cur-&gt;next = newCell;
                cur = newCell;
                ptrToA = ptrToA-&gt;next;
                ptrToB = ptrToB-&gt;next;
            }
        }
        if(!ptrToA &amp;&amp; ptrToB) {
            while(ptrToB) {
                Node *newCell = (Node *)malloc(sizeof(Node));
                newCell-&gt;data = ptrToB-&gt;data;
                cur-&gt;next = newCell;
                cur = newCell;
                ptrToB = ptrToB-&gt;next;
            }
            cur-&gt;next = NULL;
        } else if(ptrToA &amp;&amp; !ptrToB) {
            while(ptrToA) {
                Node *newCell = (Node *)malloc(sizeof(Node));
                newCell-&gt;data = ptrToA-&gt;data;
                cur-&gt;next = newCell;
                cur = newCell;
                ptrToA = ptrToA-&gt;next;
            }
            cur-&gt;next = NULL;
        } else if (!ptrToA &amp;&amp; !ptrToB ) {
            cur-&gt;next = NULL;
        }
        return head-&gt;next;
    }
}
</code></pre></div><p>第十题：获得离一个链表尾部距离为K的节点。
思路：设置两个指针，初始化时均指向头节点，然后让一个指针先往前移动K个节点，然后这两个指针再一起向前移动，当第一个指针指向链表的尾部时，第二个节点所指的位置正好就是离尾部距离为K的节点。
代码：</p> <div class="language- extra-class"><pre><code>int GetNode(Node *head,int positionFromTail)
{
  // This is a &quot;method-only&quot; submission. 
  // You only need to complete this method. 
    Node *p, *cur;
    p = cur = head;
    for(int i = 0; i &lt;= positionFromTail;i++) {
        if (p != NULL) {
            p = p-&gt;next;
        }
    }
    while(p) {
        cur = cur-&gt;next;
        p = p-&gt;next;
    }
    return cur-&gt;data;
}
</code></pre></div><p>第十一题：删除一个有序单链表中的重复元素。
思路：用两个指针分别指向当前节点cur和下一节点fol，当fol和cur的数值相等时，fol++，直到不再相等，调整cur和fol，然后cur++。
代码：</p> <div class="language- extra-class"><pre><code>Node* RemoveDuplicates(Node *head)
{
    if(head == NULL) {
        return NULL;
    } else {
        Node *cur = head, *fol = cur-&gt;next;
        while(fol != NULL) {
            while(fol &amp;&amp; (fol-&gt;data == cur-&gt;data)) {
                fol = fol-&gt;next;
            }
            cur-&gt;next = fol;
            if(fol) {
                cur = fol;
                fol = cur-&gt;next;
            }
        }
        return head;
    }
}
</code></pre></div><p>第十二题：检测链表中是否有环。
思路：使用两个指针，一个指针每次往前移动一个节点，一个指针每次往前移动两个节点，若是链表中有环的话，那么这两个指针一定会相遇，因此可以用这两个指针是否会相等来检测链表中有没有环。
代码：</p> <div class="language- extra-class"><pre><code>bool has_cycle(Node* head) {
    if(head == NULL) {
        return false;
    } else {
        Node *p = head, *q = head;
        while(p &amp;&amp; q &amp;&amp; q-&gt;next) {
            q = q-&gt;next-&gt;next;
            p = p-&gt;next;
            if(p == q) {
                return true;
            }
        }
        return false;
    }
}
</code></pre></div><p>第十三题：找到两个链表的合并点。
思路：首先计算出这两个链表的长度和长度差，然后设置两个指针分别指向这两个链表的头部，让长的那个指针先移动长度差个节点，然后两个指针再一起向前移动，当这两个指针相等的时候，所指的点就是这两个链表的合并点。
代码：</p> <div class="language- extra-class"><pre><code>int FindMergeNode(Node *headA, Node *headB)
{
    Node *ptrToA = headA,*ptrToB = headB;
    int lenA,lenB;
    lenA = lenB = 0;
    while(ptrToA) {
        lenA++;
        ptrToA = ptrToA-&gt;next;
    }
    while(ptrToB) {
        lenB++;
        ptrToB = ptrToB-&gt;next;
    }
    ptrToA = headA,ptrToB = headB;
    if(lenA &lt; lenB) {
        Node *temp = ptrToB;
        ptrToB = ptrToA;
        ptrToA = temp;
        int x = lenA;
        lenA = lenB;
        lenB = x;
    }
    for(int i = 0; i &lt; lenA-lenB;i++) {
        ptrToA = ptrToA-&gt;next;
    }
    while(ptrToA &amp;&amp; ptrToA != ptrToB) {
        ptrToA = ptrToA-&gt;next;
        ptrToB = ptrToB-&gt;next;
    }
    return ptrToA-&gt;data;
}
</code></pre></div><p>第十四题：向一个有序双向链表中插入一个节点。
思路：和向单链表中插入节点思路相同，只不过节点的前后关系设置多了几步。
代码：</p> <div class="language- extra-class"><pre><code>Node* SortedInsert(Node *head,int data)
{
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode-&gt;data = data;
    if(head == NULL) {
        newNode-&gt;next = NULL;
        newNode-&gt;prev = NULL;
        return newNode;
    } else {
        if(data &lt; head-&gt;data) {
            newNode-&gt;next = head;
            head-&gt;prev = newNode;
            newNode-&gt;prev = NULL;
            return newNode;
        } else {
            Node *ptr = head,*cur;
            while(ptr &amp;&amp; (data &gt; ptr-&gt;data)) {
                cur = ptr;
                ptr = ptr-&gt;next;
            }
            if(! ptr) {
                cur-&gt;next = newNode;
                newNode-&gt;next = NULL;
                newNode-&gt;prev = cur;
                return head;
            } else {
                cur-&gt;next = newNode;
                newNode-&gt;next = ptr;
                newNode-&gt;prev = cur;
                ptr-&gt;prev = newNode;
            }
            return head;
        }
    }
}
</code></pre></div><p>第十五题：逆序一个双向链表。
思路：和逆序一个单链表思路一致，并且由于节点中本身就有prev和next信息，因此只需要用一个指针指向当前节点即可。
代码：</p> <div class="language- extra-class"><pre><code>Node* Reverse(Node* head)
{  
    if (head == NULL) {
        return NULL;
    } 
    Node *cur = head, *next = NULL,*reversedHead = NULL;
    while(cur) {
        next = cur-&gt;next;
        if (next == NULL) {
            reversedHead = cur;
        }
        cur-&gt;next = cur-&gt;prev;
        cur-&gt;prev = next;
        cur = next;
    }
    return reversedHead;
}
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.cdf84e36.js" defer></script><script src="/assets/js/2.cd603132.js" defer></script><script src="/assets/js/30.a6d1035b.js" defer></script>
  </body>
</html>
