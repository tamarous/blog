<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Masonry 源代码剖析</title>
    <meta name="generator" content="VuePress 1.8.1">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.e4d8b86b.css" as="style"><link rel="preload" href="/assets/js/app.cdf84e36.js" as="script"><link rel="preload" href="/assets/js/2.cd603132.js" as="script"><link rel="preload" href="/assets/js/47.7e8f0cf5.js" as="script"><link rel="prefetch" href="/assets/js/10.fa04d7da.js"><link rel="prefetch" href="/assets/js/11.e05d5cca.js"><link rel="prefetch" href="/assets/js/12.14a6f17f.js"><link rel="prefetch" href="/assets/js/13.db4d1de1.js"><link rel="prefetch" href="/assets/js/14.899c5ca4.js"><link rel="prefetch" href="/assets/js/15.d0396fe4.js"><link rel="prefetch" href="/assets/js/16.b7711d40.js"><link rel="prefetch" href="/assets/js/17.1525986f.js"><link rel="prefetch" href="/assets/js/18.1ae3bf5c.js"><link rel="prefetch" href="/assets/js/19.6a77119a.js"><link rel="prefetch" href="/assets/js/20.236c8b53.js"><link rel="prefetch" href="/assets/js/21.2bfe940a.js"><link rel="prefetch" href="/assets/js/22.d9efe3b1.js"><link rel="prefetch" href="/assets/js/23.ebce0411.js"><link rel="prefetch" href="/assets/js/24.fabb82cb.js"><link rel="prefetch" href="/assets/js/25.c657f98a.js"><link rel="prefetch" href="/assets/js/26.32c42d96.js"><link rel="prefetch" href="/assets/js/27.1678b12c.js"><link rel="prefetch" href="/assets/js/28.8544b050.js"><link rel="prefetch" href="/assets/js/29.1084cfe5.js"><link rel="prefetch" href="/assets/js/3.a98e93fb.js"><link rel="prefetch" href="/assets/js/30.a6d1035b.js"><link rel="prefetch" href="/assets/js/31.be5835b4.js"><link rel="prefetch" href="/assets/js/32.d4366367.js"><link rel="prefetch" href="/assets/js/33.2b200c99.js"><link rel="prefetch" href="/assets/js/34.f163deeb.js"><link rel="prefetch" href="/assets/js/35.0b851840.js"><link rel="prefetch" href="/assets/js/36.7ff07fed.js"><link rel="prefetch" href="/assets/js/37.2693764e.js"><link rel="prefetch" href="/assets/js/38.6d5e99f9.js"><link rel="prefetch" href="/assets/js/39.d396e830.js"><link rel="prefetch" href="/assets/js/4.c1d52a96.js"><link rel="prefetch" href="/assets/js/40.569e795b.js"><link rel="prefetch" href="/assets/js/41.23c7880d.js"><link rel="prefetch" href="/assets/js/42.099df540.js"><link rel="prefetch" href="/assets/js/43.c74e858f.js"><link rel="prefetch" href="/assets/js/44.0fc3638c.js"><link rel="prefetch" href="/assets/js/45.a3c0d604.js"><link rel="prefetch" href="/assets/js/46.2a672594.js"><link rel="prefetch" href="/assets/js/48.1f54ffbe.js"><link rel="prefetch" href="/assets/js/49.e3e5f68b.js"><link rel="prefetch" href="/assets/js/5.6e3c4c72.js"><link rel="prefetch" href="/assets/js/50.4b3f35ab.js"><link rel="prefetch" href="/assets/js/51.3f804d6f.js"><link rel="prefetch" href="/assets/js/52.f125db44.js"><link rel="prefetch" href="/assets/js/6.75cdaa21.js"><link rel="prefetch" href="/assets/js/7.39046d4b.js"><link rel="prefetch" href="/assets/js/8.12f5371b.js"><link rel="prefetch" href="/assets/js/9.c3f94571.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e4d8b86b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/iOS/" class="nav-link router-link-active">
  iOS
</a></div><div class="nav-item"><a href="/Algorithms/" class="nav-link">
  Algorithms
</a></div> <a href="https://github.com/tamarous/tamarous_blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/iOS/" class="nav-link router-link-active">
  iOS
</a></div><div class="nav-item"><a href="/Algorithms/" class="nav-link">
  Algorithms
</a></div> <a href="https://github.com/tamarous/tamarous_blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="masonry-源代码剖析"><a href="#masonry-源代码剖析" class="header-anchor">#</a> Masonry 源代码剖析</h1> <p><a href="https://github.com/SnapKit/Masonry" target="_blank" rel="noopener noreferrer">Masonry<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 是一个用来代替苹果原生的AutoLayout 的自动布局框架。这个库的代码量不是很多，而且使用也很简单方便，那么就让我们深入到这个库的内部，看看它是怎么实现的。</p> <h2 id="使用范例"><a href="#使用范例" class="header-anchor">#</a> 使用范例</h2> <p>下面是一个使用Masonry 的范例：</p> <div class="language- extra-class"><pre><code>[view mas_makeConstraints: ^(MASConstraintMaker *make) {
    make.top.equalTo(superview.mas_top).with.offset(padding.top);
    make.left.equalTo(superview.mas_left).with.offset(padding.left);
    make.bottom.equalTo(superview.mas_bottom).with.offset(-padding.bottom);
    make.right.equalTo(superview.mas_right).with.offset(-padding.right);
}];
</code></pre></div><p>可以看到，view 与superview 之间的约束，是通过一个block 设置的。这个block 接受一个类型为MASConstraintMaker 的参数make，然后在block 函数体内通过make 来实现约束设置。make 看起来像是view 的一个替身，当我们写</p> <div class="language- extra-class"><pre><code>make.top.equalTo(superview.mas_top).with.offset(padding.top);
</code></pre></div><p>时，实际效果是</p> <div class="language- extra-class"><pre><code>view.top.equalTo(superview.mas_top).with.offset(padding.top);
</code></pre></div><h2 id="内部实现"><a href="#内部实现" class="header-anchor">#</a> 内部实现</h2> <h3 id="mas-makeconstraints"><a href="#mas-makeconstraints" class="header-anchor">#</a> mas_makeConstraints:</h3> <p>在Xcode 中，按住Command，在方法上点击鼠标左键就可以进入方法的内部实现。我们进入<code>mas_makeConstraints:</code>，可以看到这个方法的实现如下：</p> <div class="language- extra-class"><pre><code>- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *))block       {
    self.translatesAutoresizingMaskIntoConstraints = NO;
    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView: self];
    block(constraintMaker);
    return [constraintMaker install];
}
</code></pre></div><p>首先要将被设置的view 的<code>translatesAutoresizingMaskIntoConstraints</code>属性设置成NO，这样才可以成功添加约束。</p> <p>然后，创建一个<code>MASConstraintMaker</code>的实例。block 接受这个实例，然后执行block 块内的内容。最后返回<code>[constraintMaker install]</code>的结果。</p> <h3 id="masconstraintmaker"><a href="#masconstraintmaker" class="header-anchor">#</a> MASConstraintMaker</h3> <h4 id="初始化"><a href="#初始化" class="header-anchor">#</a> 初始化</h4> <div class="language- extra-class"><pre><code>// MASContraintMaker.m

// MAS_VIEW 是UIView 的别名
@property (nonatomic, weak) MAS_VIEW *view;

- (id) initWithView:(MAS_VIEW *) view {
    self = [super init];
    if (! self) {
        return nil;
    }
    self.view = view;
    self.constraints = NSMutableArray.new;
    return self;
}
</code></pre></div><p>在初始化方法中，<code>MASContraintMaker</code> 将要设置的视图赋值给它的属性view，因此 <code>MASContraintMaker</code> 对将要设置的视图拥有了一个弱引用。</p> <h4 id="block-的执行"><a href="#block-的执行" class="header-anchor">#</a> block 的执行</h4> <p>block 中实际进行了约束的设置工作。</p> <div class="language- extra-class"><pre><code>    make.top.equalTo(superview.mas_top).with.offset(padding.top);
    make.left.equalTo(superview.mas_left).with.offset(padding.left);
    make.bottom.equalTo(superview.mas_bottom).with.offset(-padding.bottom);
    make.right.equalTo(superview.mas_right).with.offset(-padding.right);
</code></pre></div><p>这个调用过程是链式的，即每次调用都是作用于<code>MASConstraint</code> 类型上，而本次调用的返回类型仍然是<code>MASConstraint</code> 类型。</p> <h5 id="right-left-bottom-top"><a href="#right-left-bottom-top" class="header-anchor">#</a> right,left,bottom,top</h5> <p>right，left，bottom和top 实际上是<code>MASConstraintMaker</code>中的相应属性的getter 方法，以top 为例，其定义如下：</p> <div class="language- extra-class"><pre><code>- (MASConstraint *) top {
    return [self addConstraintWithLayoutAttribute: NSLayoutAttributeTop];
}
</code></pre></div><p>这个方法中还涉及到一些其他方法：</p> <div class="language- extra-class"><pre><code>- (MASContraint *) addConstraintWithLayoutAttribute:(NSLayoutAttribute) layoutAttribute {
    return [self constraint: nil addConstraintWithLayoutAttribute: layoutAttribute];
}

- (MASConstraint *) constraint:(MASContraint *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute) layoutAttribute {
    MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] initWithView:self.view layoutAttribute:layoutAttribute]; // 1
    MASViewAttribute *newAttribute = [[MASViewAttribute alloc] initWithFirstViewAttribute:viewAttribute]; // 2
    if ([constraint isKindOfClass: MASViewConstraint.class]) {
        NSArray *children = @[constraint, newConstraint];
        MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] initWithChildren: children];
        compositeConstraint.delegate = self;
        [self constraint: constraint shouleBeReplaceWithConstraint: compositeConstraint];
        return compositeConstraint;
    }
    // 因为传入的constraint 为nil，所以直接进入下面的判断
    if (! constraint) {
        newConstraint.delegate = self;
        [self.constraints addObject: newConstraint]; // 3
    }
    return newConstraint;
}
</code></pre></div><p>在上面这个方法中：</p> <ol><li>根据传入的要设置的<code>NSLayoutAttribute</code> 生成对应的<code>MASViewAttribute</code>。</li> <li>根据<code>MASViewAttribute</code> 生成当前视图的新约束。</li> <li>将2中生成的新约束加入<code>MASContraintMaker</code> 的约束数组中。</li></ol> <h5 id="equalto-greaterthanorequalto-lessthanorequalto"><a href="#equalto-greaterthanorequalto-lessthanorequalto" class="header-anchor">#</a> equalTo, greaterThanOrEqualTo, lessThanOrEqualTo</h5> <div class="language- extra-class"><pre><code>- (MASConstraint * (^)(id attr))equalTo;
- (MASConstraint * (^)(id attr))greaterThanOrEqualTo;
- (MASConstraint * (^)(id attr))lessThanOrEqualTo; 
</code></pre></div><p>这三个方法的参数是id 类型的，因此它们既可以接受NSValue 类型的参数，如NSNumber，CGPoint，CGSize等，也可以接受<code>UIView</code> 类型的参数，还可以接受<code>MASViewConstraint</code> 类型的参数。
当接受NSValue 类型的参数时，如</p> <div class="language- extra-class"><pre><code>make.top.equalTo(@100)
</code></pre></div><p>表示当前视图的top与它的superview 的top相距100；
当接受<code>UIView</code> 类型的参数时，会和<code>UIView</code> 的对应属性做比较，如</p> <div class="language- extra-class"><pre><code>make.top.equalTo(secondView)
</code></pre></div><p>表示当前视图和secondView 的top是平齐的；
当接受<code>MASViewConstraint</code> 类型的参数时，如</p> <div class="language- extra-class"><pre><code>make.bottom.equalTo(secondView.mas_bottom)
</code></pre></div><p>表示当前视图和secondView 的bottom 是平齐的。</p> <p>这个特性的实现原理会在稍后进行介绍。</p> <p>以上方法虽然定义不同，但是内部实现相似，都是调用了<code>MASConstraint</code> 的<code>equalToWithRelation</code> 方法，但是传入了不同的参数：</p> <div class="language- extra-class"><pre><code>- (MASConstraint * (^)(id attr))equalTo 「
    return ^id(id attribute) {
        return self.equalToWithRelation(attribute, NSLayoutRelationEqual);
    };
}
- (MASConstraint * (^)(id attr))greaterThanOrEqualTo {
    return ^id(id attribute) {
        return self.equalToWithRelation(attribute, NSLayoutRelationGreaterThanOrEqual);
    };
}
- (MASConstraint * (^)(id attr)) lessThanOrEqualTo{
    return ^id(id attribute) {
        return self.equalToWithRelation(attribute,
        NSLayoutRelationLessThanOrEqual);
    };
}
</code></pre></div><p>继续向下寻找<code>equalToWithRelation</code> 的定义。使用Command + 鼠标左键，我们发现这个方法在三个地方有定义：</p> <div class="language- extra-class"><pre><code>[MASConstraint(Abstract) equalToWithRelation];
[MASViewConstraint equalToWithRelation];
[MASCompositeConstraint equalToWithRelation];
</code></pre></div><p><code>MASCompositeConstraint</code> 和<code>MASViewContraint</code> 是<code>MASConstraint</code> 的子类。在<code>MASConstraint</code> 中定义了很多抽象方法，都是需要在这两个子类中进行实现的。</p> <blockquote><p>MASCompositeConstraint: A composite with a predefined array of children.</p></blockquote> <p>从定义和名称中可以看出，<code>MASCompositeConstraint</code> 是约束的组合。按照我的理解，它的作用可以看作是一颗树的根，这个根确定了哪些节点位于这棵树上，而树的子节点的类型都是<code>MASViewConstraint</code>。</p> <p><code>equalToWithRelation</code> 是一个抽象方法，在<code>MASContraint</code> 中没有实现，如果调用此方法就会抛出一个异常：</p> <div class="language- extra-class"><pre><code>- (MASConstraint * (^)(id, NSLayoutRelation))equalToWithRelation { MASMethodNotImplemented(); }

#define MASMethodNotImplemented() \
@throw [NSException exceptionWithName:NSInternalInconsistencyException \
                               reason:[NSString stringWithFormat:@&quot;You must override %@ in a subclass.&quot;, NSStringFromSelector(_cmd)] \
                             userInfo:nil]
</code></pre></div><p><code>MASViewConstraint</code> 重载了此方法：</p> <div class="language- extra-class"><pre><code>    - (MASConstraint * (^)(id, NSLayoutRelation))equalToWithRelation {
return ^id(id attribute, NSLayoutRelation relation) {
    if ([attribute isKindOfClass:NSArray.class]) { // 1
        NSAssert(!self.hasLayoutRelation, @&quot;Redefinition of constraint relation&quot;);
        NSMutableArray *children = NSMutableArray.new;
        for (id attr in attribute) {
            MASViewConstraint *viewConstraint = [self copy];
            viewConstraint.layoutRelation = relation;
            viewConstraint.secondViewAttribute = attr;
            [children addObject:viewConstraint];
        }
        MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] initWithChildren:children];
        compositeConstraint.delegate = self.delegate;
        [self.delegate constraint:self shouldBeReplacedWithConstraint:compositeConstraint];
        return compositeConstraint;
    } else {
        NSAssert(!self.hasLayoutRelation || self.layoutRelation == relation &amp;&amp; [attribute isKindOfClass:NSValue.class], @&quot;Redefinition of constraint relation&quot;);
        self.layoutRelation = relation;
        self.secondViewAttribute = attribute;  // 2
        return self;
    }
};
}
</code></pre></div><ol><li><p>判断传入的attribute 是否为NSArray 类型。</p></li> <li><p>如果不是，则将传入的参数赋值给某些属性。注意secondViewAttribute 这个属性的setter 方法，它并不是一个简单的赋值过程，而是会根据传入的attribute 的类型进行额外的设置。</p> <div class="language- extra-class"><pre><code> - (void)setSecondViewAttribute:(id)secondViewAttribute {

     if ([secondViewAttribute isKindOfClass:NSValue.class]) {
     
     // 1 对应于上文中的equalTo(@100) 这种情况
         [self setLayoutConstantWithValue:secondViewAttribute]; 
     } else if ([secondViewAttribute isKindOfClass:MAS_VIEW.class]) {
     
     // 2 对应于上文中的equalTo(secondView) 这种情况
         _secondViewAttribute = [[MASViewAttribute alloc] initWithView:secondViewAttribute layoutAttribute:self.firstViewAttribute.layoutAttribute]; // 2
     } else if ([secondViewAttribute isKindOfClass:MASViewAttribute.class]) {
     
     // 3 对应于上文中的equalTo(secondView.mas_bottom) 这种情况
         _secondViewAttribute = secondViewAttribute;
     } else {
         NSAssert(NO, @&quot;attempting to add unsupported attribute: %@&quot;, secondViewAttribute);
     }
 }
</code></pre></div></li></ol> <p><code>MASCompositeConstraint</code> 对此方法的实现则要简单得多：</p> <div class="language- extra-class"><pre><code>- (MASConstraint * (^)(id, NSLayoutRelation))equalToWithRelation {
    return ^id(id attr, NSLayoutRelation relation) {
        for (MASConstraint *constraint in self.childConstraints.copy) {
            constraint.equalToWithRelation(attr, relation);
    }
        return self;
    };
}
</code></pre></div><p>可以看出，这个方法的实现是递归的，它对当前<code>MASCompositeConstraint</code> 的每一个childConstraint 调用对应的<code>equalToWithRelation</code> 方法，如果当前某一个constraint 的childConstraint 为空，就返回这个constraint。怎么样，是不是有点类似于后续遍历？
因为实际的工作都是由<code>MASViewConstraint</code> 类型完成的，下面我们就只关心方法在这个类中的实现。</p> <h4 id="安装约束"><a href="#安装约束" class="header-anchor">#</a> 安装约束</h4> <div class="language- extra-class"><pre><code>- (NSArray *)install {
    if (self.removeExisting) {
        NSArray *installedConstraints = [MASViewConstraint installedConstraintsForView: self.view]; // 1
        for (MASConstraint *constraint in installedConstraints) {
            [constraint uninstall]; // 2
        }
    }
    NSArray *constraints = self.constraints.copy;
    for (MASConstraint *constraint in constraints) {
        constraint.updateExisting = self.updateExisting;
        [constraint install]; // 3
    }
    [self.constraints removeAllObjects]; // 4
    return constraints;
}
</code></pre></div><p>在<code>MASConstraintMaker</code>的<code>install</code>方法中，有如下几个过程：</p> <ol><li>查看当前视图上已经安装的约束。</li> <li>对于<strong>已经</strong>安装的约束，逐一进行卸载。</li> <li>对于<strong>将要</strong>安装的约束，逐一<code>[constaint install]</code>，进行安装。</li> <li>将自身的<code>constraints</code>数组中的所有元素清除掉。</li></ol> <h3 id="masviewconstraint"><a href="#masviewconstraint" class="header-anchor">#</a> MASViewConstraint</h3> <p>我们着重来看上一节描述的<code>[constraintMaker install]</code>中的第三点。</p> <div class="language- extra-class"><pre><code>// MASViewConstraint.m
- (void)install {
if (self.hasBeenInstalled) {
    return;
}

// 1
if ([self supportsActiveProperty] &amp;&amp; self.layoutConstraint) {
    self.layoutConstraint.active = YES;
    [self.firstViewAttribute.view.mas_installedConstraints addObject:self];
    return;
}

// 2
MAS_VIEW *firstLayoutItem = self.firstViewAttribute.item;
NSLayoutAttribute firstLayoutAttribute = self.firstViewAttribute.layoutAttribute;
MAS_VIEW *secondLayoutItem = self.secondViewAttribute.item;
NSLayoutAttribute secondLayoutAttribute = self.secondViewAttribute.layoutAttribute;

// 3
// alignment attributes must have a secondViewAttribute
// therefore we assume that is refering to superview
// eg make.left.equalTo(@10)
if (!self.firstViewAttribute.isSizeAttribute &amp;&amp; !self.secondViewAttribute) {
    secondLayoutItem = self.firstViewAttribute.view.superview;
    secondLayoutAttribute = firstLayoutAttribute;
}

// 4
MASLayoutConstraint *layoutConstraint
    = [MASLayoutConstraint constraintWithItem:firstLayoutItem
                                    attribute:firstLayoutAttribute
                                    relatedBy:self.layoutRelation
                                       toItem:secondLayoutItem
                                    attribute:secondLayoutAttribute
                                   multiplier:self.layoutMultiplier
                                     constant:self.layoutConstant];

layoutConstraint.priority = self.layoutPriority;
layoutConstraint.mas_key = self.mas_key;


// 5
if (self.secondViewAttribute.view) {
    MAS_VIEW *closestCommonSuperview = [self.firstViewAttribute.view mas_closestCommonSuperview:self.secondViewAttribute.view];
    NSAssert(closestCommonSuperview,
             @&quot;couldn't find a common superview for %@ and %@&quot;,
             self.firstViewAttribute.view, self.secondViewAttribute.view);
    self.installedView = closestCommonSuperview;
} else if (self.firstViewAttribute.isSizeAttribute) {
    self.installedView = self.firstViewAttribute.view;
} else {
    self.installedView = self.firstViewAttribute.view.superview;
}


MASLayoutConstraint *existingConstraint = nil;
if (self.updateExisting) {
    existingConstraint = [self layoutConstraintSimilarTo:layoutConstraint];
}
if (existingConstraint) {
    // just update the constant
    existingConstraint.constant = layoutConstraint.constant;
    self.layoutConstraint = existingConstraint;
} else {
    [self.installedView addConstraint:layoutConstraint];
    self.layoutConstraint = layoutConstraint;
    [firstLayoutItem.mas_installedConstraints addObject:self];
}
}
</code></pre></div><p>在对代码进行分析之前，我们需要知道：因为每个约束需要处理的，是两个item 之间的关系。</p> <blockquote><p>item1.attribute1 = multiplier × item2.attribute2 + constant // 约束等式</p></blockquote> <p>所以<code>MASViewConstraint</code> 有两个属性，分别是</p> <div class="language- extra-class"><pre><code>@property (nonatomic, strong, readonly) MASViewAttribute *firstViewAttribute;
</code></pre></div><p>和</p> <div class="language- extra-class"><pre><code>@property (nonatomic, strong, readonly) MASViewAttribute *secondViewAttribute;
</code></pre></div><p>这两个属性分别描述了约束等式的左边和右边。
因此，代码的执行过程为：</p> <ol><li>将当前约束加入约束等式左边的view 的已安装约束列表中。</li> <li>获取当前约束的左右两边的item 和它们对应的layoutAttribute。</li> <li>如果item1 描述的不是数值，并且item2 为nil，则当前约束对应着前面所说的<code>equalTo(@100)</code>这种情况，所以当前的约束的item2 应该是item1中view 的superview。这和我们平时手写UI时的逻辑是相同的。</li> <li>调用系统API 来进行约束设置。</li> <li>如果item2 是一个view，那么这个约束应该被安装在item1 和item2 的共同superview 上，因此需要找到item1 和item2 的最近共同superview。其他情况同理。</li></ol> <div class="language- extra-class"><pre class="language-text"><code>- (instancetype)mas_closestCommonSuperview:(MAS_VIEW *)view {
    MAS_VIEW *closestCommonSuperview = nil;

    MAS_VIEW *secondViewSuperview = view;
    while (!closestCommonSuperview &amp;&amp; secondViewSuperview) {
        MAS_VIEW *firstViewSuperview = self;
        while (!closestCommonSuperview &amp;&amp; firstViewSuperview) {
            if (secondViewSuperview == firstViewSuperview) {
                closestCommonSuperview = secondViewSuperview;
            }
            firstViewSuperview = firstViewSuperview.superview;
        }
        secondViewSuperview = secondViewSuperview.superview;
    }
    return closestCommonSuperview;
}
</code></pre></div><h2 id="小结"><a href="#小结" class="header-anchor">#</a> 小结</h2> <p>本文简要分析了用<code>Masonry</code> 设置视图间布局约束时的代码的内部实现。从分析过程中，我感受到了写一个库的难度，也体会到了那句话的含义：“将简洁留给用户，将复杂留给自己”。无论是<code>SDWebImage</code> 的一行代码设置图片还是<code>Masonry</code> 的链式设置方法，其简洁的背后藏有复杂的逻辑，恼人的边界处理和多种策略的应用。</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.cdf84e36.js" defer></script><script src="/assets/js/2.cd603132.js" defer></script><script src="/assets/js/47.7e8f0cf5.js" defer></script>
  </body>
</html>
