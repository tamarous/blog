<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>EasyTuple 源代码分析</title>
    <meta name="generator" content="VuePress 1.8.1">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/tamarous_blog/assets/css/0.styles.2918e61a.css" as="style"><link rel="preload" href="/tamarous_blog/assets/js/app.06befc6f.js" as="script"><link rel="preload" href="/tamarous_blog/assets/js/2.cd603132.js" as="script"><link rel="preload" href="/tamarous_blog/assets/js/46.2a672594.js" as="script"><link rel="prefetch" href="/tamarous_blog/assets/js/10.26a5b427.js"><link rel="prefetch" href="/tamarous_blog/assets/js/11.ca60f1ab.js"><link rel="prefetch" href="/tamarous_blog/assets/js/12.14a6f17f.js"><link rel="prefetch" href="/tamarous_blog/assets/js/13.db4d1de1.js"><link rel="prefetch" href="/tamarous_blog/assets/js/14.899c5ca4.js"><link rel="prefetch" href="/tamarous_blog/assets/js/15.d0396fe4.js"><link rel="prefetch" href="/tamarous_blog/assets/js/16.b7711d40.js"><link rel="prefetch" href="/tamarous_blog/assets/js/17.1525986f.js"><link rel="prefetch" href="/tamarous_blog/assets/js/18.1ae3bf5c.js"><link rel="prefetch" href="/tamarous_blog/assets/js/19.6a77119a.js"><link rel="prefetch" href="/tamarous_blog/assets/js/20.236c8b53.js"><link rel="prefetch" href="/tamarous_blog/assets/js/21.2bfe940a.js"><link rel="prefetch" href="/tamarous_blog/assets/js/22.d9efe3b1.js"><link rel="prefetch" href="/tamarous_blog/assets/js/23.ebce0411.js"><link rel="prefetch" href="/tamarous_blog/assets/js/24.fabb82cb.js"><link rel="prefetch" href="/tamarous_blog/assets/js/25.c657f98a.js"><link rel="prefetch" href="/tamarous_blog/assets/js/26.644735b4.js"><link rel="prefetch" href="/tamarous_blog/assets/js/27.1678b12c.js"><link rel="prefetch" href="/tamarous_blog/assets/js/28.8544b050.js"><link rel="prefetch" href="/tamarous_blog/assets/js/29.1084cfe5.js"><link rel="prefetch" href="/tamarous_blog/assets/js/3.c426a4d7.js"><link rel="prefetch" href="/tamarous_blog/assets/js/30.a6d1035b.js"><link rel="prefetch" href="/tamarous_blog/assets/js/31.be5835b4.js"><link rel="prefetch" href="/tamarous_blog/assets/js/32.d4366367.js"><link rel="prefetch" href="/tamarous_blog/assets/js/33.2b200c99.js"><link rel="prefetch" href="/tamarous_blog/assets/js/34.f163deeb.js"><link rel="prefetch" href="/tamarous_blog/assets/js/35.0b851840.js"><link rel="prefetch" href="/tamarous_blog/assets/js/36.7ff07fed.js"><link rel="prefetch" href="/tamarous_blog/assets/js/37.2693764e.js"><link rel="prefetch" href="/tamarous_blog/assets/js/38.6d5e99f9.js"><link rel="prefetch" href="/tamarous_blog/assets/js/39.d396e830.js"><link rel="prefetch" href="/tamarous_blog/assets/js/4.c1d52a96.js"><link rel="prefetch" href="/tamarous_blog/assets/js/40.569e795b.js"><link rel="prefetch" href="/tamarous_blog/assets/js/41.23c7880d.js"><link rel="prefetch" href="/tamarous_blog/assets/js/42.099df540.js"><link rel="prefetch" href="/tamarous_blog/assets/js/43.c74e858f.js"><link rel="prefetch" href="/tamarous_blog/assets/js/44.0fc3638c.js"><link rel="prefetch" href="/tamarous_blog/assets/js/45.a3c0d604.js"><link rel="prefetch" href="/tamarous_blog/assets/js/47.7e8f0cf5.js"><link rel="prefetch" href="/tamarous_blog/assets/js/48.e6b8176d.js"><link rel="prefetch" href="/tamarous_blog/assets/js/49.e3e5f68b.js"><link rel="prefetch" href="/tamarous_blog/assets/js/5.6e3c4c72.js"><link rel="prefetch" href="/tamarous_blog/assets/js/50.4b3f35ab.js"><link rel="prefetch" href="/tamarous_blog/assets/js/51.3f804d6f.js"><link rel="prefetch" href="/tamarous_blog/assets/js/52.f125db44.js"><link rel="prefetch" href="/tamarous_blog/assets/js/53.c4ffbb43.js"><link rel="prefetch" href="/tamarous_blog/assets/js/6.75cdaa21.js"><link rel="prefetch" href="/tamarous_blog/assets/js/7.39046d4b.js"><link rel="prefetch" href="/tamarous_blog/assets/js/8.12f5371b.js"><link rel="prefetch" href="/tamarous_blog/assets/js/9.682ca412.js">
    <link rel="stylesheet" href="/tamarous_blog/assets/css/0.styles.2918e61a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/tamarous_blog/" class="home-link router-link-active"></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/tamarous_blog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/tamarous_blog/iOS/" class="nav-link router-link-active">
  iOS
</a></div><div class="nav-item"><a href="/tamarous_blog/Algorithms/" class="nav-link">
  Algorithms
</a></div> <a href="https://github.com/tamarous/tamarous_blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/tamarous_blog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/tamarous_blog/iOS/" class="nav-link router-link-active">
  iOS
</a></div><div class="nav-item"><a href="/tamarous_blog/Algorithms/" class="nav-link">
  Algorithms
</a></div> <a href="https://github.com/tamarous/tamarous_blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><a href="/tamarous_blog/" aria-current="page" class="sidebar-link">Home</a></li><li><a href="/tamarous_blog/iOS/" aria-current="page" class="sidebar-link">源码分析</a></li><li><a href="/tamarous_blog/Algorithms/" class="sidebar-link">LeetCode</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="easytuple-源代码分析"><a href="#easytuple-源代码分析" class="header-anchor">#</a> EasyTuple 源代码分析</h1> <p><a href="https://github.com/meituan/EasyTuple" target="_blank" rel="noopener noreferrer"><code>EasyTuple</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>是由美团开源的一个第三方库，它给Objective-C 添加了元组的能力，可以将几个对象包裹在一个对象中，这样我们就可以从一个函数中返回多个值。它的使用非常简单，比如我们想创建一个由两个元素组成的元组，那么可以这样写：</p> <div class="language- extra-class"><pre class="language-text"><code>EZTuple2&lt;NSNumber *, NSString *&gt; *tuple = EZTuple(@1, @&quot;string&quot;);
</code></pre></div><p>如果使用 Xcode 辅助编辑器查看预编译后的代码，那么上面的例子在预编译后，会被展开为</p> <div class="language- extra-class"><pre class="language-text"><code>EZTuple2&lt;NSNumber *, NSString *&gt; *tuple = [[EZTuple2 alloc] initWithFirst:@1 second:@&quot;string&quot;];
</code></pre></div><p>可以看到原来的宏的写法会自动被转换成 Objective-C 中的类的创建语法了，那么这个转换过程是怎样发生的呢？下面让我们一步步地去分析这个转换的过程。</p> <h2 id="eztuple"><a href="#eztuple" class="header-anchor">#</a> EZTuple</h2> <p>右边这个看起来像函数的<code>EZTuple</code>，其实是一个宏：</p> <div class="language- extra-class"><pre class="language-text"><code>#define EZTuple(...) EZTupleAs(EZ_CONCAT(EZTuple, EZ_ARG_COUNT(__VA_ARGS__)), __VA_ARGS__)
</code></pre></div><h3 id="ez-concat"><a href="#ez-concat" class="header-anchor">#</a> EZ_CONCAT</h3> <p>我们遇到的第一个宏就是 <code>EZ_CONCAT</code>，它的定义如下</p> <div class="language- extra-class"><pre class="language-text"><code>#define EZ_CONCAT(A, B) EZ_CONCAT_(A, B)
#define EZ_CONCAT_(A, B) A ## B
</code></pre></div><p>作用是把 A 和 B 两个字符串连接到一起，比如
<code>EZ_CONCAT(hello, world)</code>的结果就是<code>helloworld</code>。</p> <h3 id="ez-arg-count"><a href="#ez-arg-count" class="header-anchor">#</a> EZ_ARG_COUNT</h3> <p><code>EZ_ARG_COUNT</code>是我们遇到的第二个宏，它的定义有些复杂：</p> <div class="language- extra-class"><pre class="language-text"><code>#define EZ_ARG_COUNT(...)   _EZ_ARG_COUNT(__VA_ARGS__)
#define _EZ_ARG_COUNT(...)  EZ_ARG_AT(20, ##__VA_ARGS__, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)

#define EZ_ARG_AT(N, ...)                                    EZ_ARG_AT_(N, __VA_ARGS__)
#define EZ_ARG_AT_(N, ...)                                   EZ_CONCAT(EZ_ARG_AT, N)(__VA_ARGS__)
#define EZ_ARG_AT0(...)                                      EZ_ARG_HEAD(__VA_ARGS__)
#define EZ_ARG_AT1(_0, ...)                                  EZ_ARG_HEAD(__VA_ARGS__)
#define EZ_ARG_AT2(_0, _1, ...)                              EZ_ARG_HEAD(__VA_ARGS__)
#define EZ_ARG_AT3(_0, _1, _2, ...)                          EZ_ARG_HEAD(__VA_ARGS__)
#define EZ_ARG_AT4(_0, _1, _2, _3, ...)                      EZ_ARG_HEAD(__VA_ARGS__)
#define EZ_ARG_AT5(_0, _1, _2, _3, _4, ...)                  EZ_ARG_HEAD(__VA_ARGS__)
#define EZ_ARG_AT6(_0, _1, _2, _3, _4, _5, ...)              EZ_ARG_HEAD(__VA_ARGS__)
#define EZ_ARG_AT7(_0, _1, _2, _3, _4, _5, _6, ...)          EZ_ARG_HEAD(__VA_ARGS__)
#define EZ_ARG_AT8(_0, _1, _2, _3, _4, _5, _6, _7, ...)      EZ_ARG_HEAD(__VA_ARGS__)
#define EZ_ARG_AT9(_0, _1, _2, _3, _4, _5, _6, _7, _8, ...)  EZ_ARG_HEAD(__VA_ARGS__)
#define EZ_ARG_AT10(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, ...)                                                                \
    EZ_ARG_HEAD(__VA_ARGS__)
#define EZ_ARG_AT11(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, ...)                                                           \
    EZ_ARG_HEAD(__VA_ARGS__)
#define EZ_ARG_AT12(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, ...)                                                      \
    EZ_ARG_HEAD(__VA_ARGS__)
#define EZ_ARG_AT13(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, ...)                                                 \
    EZ_ARG_HEAD(__VA_ARGS__)
#define EZ_ARG_AT14(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, ...)                                            \
    EZ_ARG_HEAD(__VA_ARGS__)
#define EZ_ARG_AT15(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, ...)                                       \
    EZ_ARG_HEAD(__VA_ARGS__)
#define EZ_ARG_AT16(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, ...)                                  \
    EZ_ARG_HEAD(__VA_ARGS__)
#define EZ_ARG_AT17(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, ...)                             \
    EZ_ARG_HEAD(__VA_ARGS__)
#define EZ_ARG_AT18(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, ...)                        \
    EZ_ARG_HEAD(__VA_ARGS__)
#define EZ_ARG_AT19(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, ...)                   \
    EZ_ARG_HEAD(__VA_ARGS__)
#define EZ_ARG_AT20(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, ...)              \
    EZ_ARG_HEAD(__VA_ARGS__)
</code></pre></div><p><code>EZ_ARG_COUNT</code>是对<code>_EZ_ARG_COUNT</code>的一个包装。它会被展开为</p> <div class="language- extra-class"><pre class="language-text"><code>EZ_ARG_AT(20,##__VA_ARGS__, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)
</code></pre></div><p>根据</p> <div class="language- extra-class"><pre class="language-text"><code>#define EZ_ARG_AT(N, ...)   EZ_ARG_AT_(N, __VA_ARGS__)
#define EZ_ARG_AT_(N, ...)  EZ_CONCAT(EZ_ARG_AT, N)(__VA_ARGS__)
</code></pre></div><p>上面这个宏就是<code>EZ_CONCAT(EZ_ARG_AT, 20)(__VA_ARGS__)</code>，而<code>EZ_CONCAT(EZ_ARG_AT, 20)</code>也就是<code>EZ_ARG_AT20</code>，因此这个宏进而就等同于</p> <div class="language- extra-class"><pre class="language-text"><code>EZ_ARG_AT20(##__VA_ARGS__, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)
</code></pre></div><p>也就是说我们在使用<code>EZ_ARG_COUNT(...)</code>这个宏的时候，它会被最终展开为</p> <div class="language- extra-class"><pre class="language-text"><code>EZ_ARG_AT20(##__VA_ARGS__, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)
</code></pre></div><p>现在假设有这么一行代码<code>EZ_ARG_COUNT(1,2,3)</code>，那么它就会展开为</p> <div class="language- extra-class"><pre class="language-text"><code>EZ_ARG_AT20(1, 2, 3, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)
</code></pre></div><p>我们注意到</p> <div class="language- extra-class"><pre class="language-text"><code>#define EZ_ARG_AT20(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, ...)              \
    EZ_ARG_HEAD(__VA_ARGS__)
</code></pre></div><p>1占据了_0的位置，2占据了_1的位置，3占据了_3的位置，20，19，18，...，4依次占据了
_4、_5、_6、... _19的位置，剩下的3，2，1，0被当做参数传入了 <code>EZ_ARG_HEAD</code>中，
因此<code>EZ_ARG_COUNT(1,2,3)</code>会被展开为 <code>EZ_ARG_HEAD(3,2,1,0)</code>。</p> <h3 id="ez-arg-head"><a href="#ez-arg-head" class="header-anchor">#</a> EZ_ARG_HEAD</h3> <p><code>EZ_ARG_HEAD</code>的定义如下</p> <div class="language- extra-class"><pre class="language-text"><code>#define EZ_ARG_HEAD(FIRST, ...)             FIRST
</code></pre></div><p>它的作用是取出宏的第一个参数，因此</p> <div class="language- extra-class"><pre class="language-text"><code>EZ_ARG_HEAD(3,2,1,0) = 3
</code></pre></div><p>也就是</p> <div class="language- extra-class"><pre class="language-text"><code>EZ_ARG_COUNT(1,2,3) = 3
</code></pre></div><p>因此<code>EZ_ARG_COUNT</code>的作用就是<strong>获得输入的参数的个数</strong>。</p> <p>由以上三个宏的定义，<code>EZTuple(@1, @&quot;string&quot;)</code>会被展开为<code>EZTupleAs(EZTuple2, @1, @&quot;string&quot;)</code>。</p> <p>进而，根据<code>EZTupleAs</code>的定义</p> <div class="language- extra-class"><pre class="language-text"><code>#define EZTupleAs(_Class_, ...) [[_Class_ alloc] EZ_CONCAT(initWith, EZ_FOR_EACH(EZ_INIT_PARAM_CALL, ,__VA_ARGS__))]
</code></pre></div><p><code>EZTupleAs(EZTuple2, @1, @&quot;string&quot;)</code>会被展开为</p> <div class="language- extra-class"><pre class="language-text"><code>[[EZTuple2 alloc] EZ_CONCAT(initWith, EZ_FOR_EACH(EZ_INIT_PARAM_CALL, ,@1, @&quot;string&quot;))]
</code></pre></div><h3 id="ez-for-each"><a href="#ez-for-each" class="header-anchor">#</a> EZ_FOR_EACH</h3> <p><code>EZ_FOR_EACH</code>的定义如下</p> <div class="language- extra-class"><pre class="language-text"><code>#define EZ_FOR_EACH(...)    _EZ_FOR_EACH(__VA_ARGS__)
#define _EZ_FOR_EACH(MACRO, SEP, ...)   EZ_FOR_EACH_CTX(EZ_FOR_EACH_ITER_, SEP, MACRO, ##__VA_ARGS__)

#define EZ_FOR_EACH_CTX(MACRO, SEP, CTX, ...)                EZ_CONCAT(EZ_FOR_EACH_CTX, EZ_ARG_COUNT(__VA_ARGS__))(MACRO, SEP, CTX, ##__VA_ARGS__)
#define EZ_FOR_EACH_CTX0(MACRO, SEP, CTX)
#define EZ_FOR_EACH_CTX1(MACRO, SEP, CTX, _0) MACRO(0, _0, CTX)
#define EZ_FOR_EACH_CTX2(MACRO, SEP, CTX, _0, _1) \
    EZ_FOR_EACH_CTX1(MACRO, SEP, CTX, _0) SEP MACRO(1, _1, CTX)
#define EZ_FOR_EACH_CTX3(MACRO, SEP, CTX, _0, _1, _2) \
    EZ_FOR_EACH_CTX2(MACRO, SEP, CTX, _0, _1) SEP MACRO(2, _2, CTX)
#define EZ_FOR_EACH_CTX4(MACRO, SEP, CTX, _0, _1, _2, _3) \
    EZ_FOR_EACH_CTX3(MACRO, SEP, CTX, _0, _1, _2) SEP MACRO(3, _3, CTX)
#define EZ_FOR_EACH_CTX5(MACRO, SEP, CTX, _0, _1, _2, _3, _4) \
    EZ_FOR_EACH_CTX4(MACRO, SEP, CTX, _0, _1, _2, _3) SEP MACRO(4, _4, CTX)
// 中间定义都是类似的，为了节省篇幅就不列出了
    EZ_FOR_EACH_CTX18(MACRO, SEP, CTX, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17) SEP MACRO(18, _18, CTX)
#define EZ_FOR_EACH_CTX20(MACRO, SEP, CTX, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19) \
    EZ_FOR_EACH_CTX19(MACRO, SEP, CTX, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18) SEP MACRO(19, _19, CTX)
</code></pre></div><p>对于<code>EZTupleAs(EZTuple2, @1, @&quot;string&quot;)</code>展开的结果中的<code>EZ_FOR_EACH(EZ_INIT_PARAM_CALL, ,@1, @&quot;string&quot;)</code>而言，<code>MACRO</code>为<code>EZ_INIT_PARAM_CALL</code>，<code>SEP</code>为空，<code>...</code>为<code>@1, @&quot;string&quot;</code>，所以
它会被展开为</p> <div class="language- extra-class"><pre class="language-text"><code>EZ_FOR_EACH_CTX(EZ_FOR_EACH_ITER_, , EZ_INIT_PARAM_CALL, @1, @&quot;string&quot;)
</code></pre></div><p>根据</p> <div class="language- extra-class"><pre class="language-text"><code>#define EZ_FOR_EACH_CTX(MACRO, SEP, CTX, ...)   EZ_CONCAT(EZ_FOR_EACH_CTX, EZ_ARG_COUNT(__VA_ARGS__))(MACRO, SEP, CTX, ##__VA_ARGS__)
</code></pre></div><p>那么对于<code>EZ_FOR_EACH_CTX(EZ_FOR_EACH_ITER_, , EZ_INIT_PARAM_CALL, @1, @&quot;string&quot;)</code>，<code>MACRO</code>为<code>EZ_FOR_EACH_ITER_</code>，<code>SEP</code>为空，<code>CTX</code>为<code>EZ_INIT_PARAM_CALL</code>，所以它会被展开为</p> <div class="language- extra-class"><pre class="language-text"><code>EZ_FOR_EACH_CTX2(EZ_FOR_EACH_ITER_,,EZ_INIT_PARAM_CALL,@1, @&quot;string&quot;)
</code></pre></div><p>再根据</p> <div class="language- extra-class"><pre class="language-text"><code>#define EZ_FOR_EACH_CTX1(MACRO, SEP, CTX, _0) MACRO(0, _0, CTX)
#define EZ_FOR_EACH_CTX2(MACRO, SEP, CTX, _0, _1) \
    EZ_FOR_EACH_CTX1(MACRO, SEP, CTX, _0) SEP MACRO(1, _1, CTX)
</code></pre></div><p><code>MACRO</code>为<code>EZ_FOR_EACH_ITER_</code>，<code>SEP</code>为空，<code>CTX</code>为<code>EZ_INIT_PARAM_CALL</code>，_0为@1，_1为@&quot;string&quot;，所以上式首先会被展开为</p> <div class="language- extra-class"><pre class="language-text"><code>EZ_FOR_EACH_CTX1(EZ_FOR_EACH_ITER_, , EZ_INIT_PARAM_CALL, @1) EZ_FOR_EACH_ITER_(1, @&quot;string&quot;, EZ_INIT_PARAM_CALL)
</code></pre></div><p>然后</p> <div class="language- extra-class"><pre class="language-text"><code>EZ_FOR_EACH_CTX1(EZ_FOR_EACH_ITER_, ,EZ_INIT_PARAM_CALL, @1)
</code></pre></div><p>中，<code>MACRO</code>为<code>EZ_FOR_EACH_ITER_</code>，<code>SEP</code>为空，<code>CTX</code>为<code>EZ_INIT_PARAM_CALL</code>，_0为@1，所以它会被展开成</p> <div class="language- extra-class"><pre class="language-text"><code>EZ_FOR_EACH_ITER_(0,@1,EZ_INIT_PARAM_CALL)
</code></pre></div><p>所以</p> <div class="language- extra-class"><pre class="language-text"><code>EZ_FOR_EACH_CTX2(EZ_FOR_EACH_ITER_,,EZ_INIT_PARAM_CALL,@1, @&quot;string&quot;)
</code></pre></div><p>会被展开为</p> <div class="language- extra-class"><pre class="language-text"><code>EZ_FOR_EACH_ITER_(0, @1, EZ_INIT_PARAM_CALL) EZ_FOR_EACH_ITER_(1, @&quot;string&quot;, EZ_INIT_PARAM_CALL)
</code></pre></div><p>也就是说，最一开始的</p> <div class="language- extra-class"><pre class="language-text"><code>EZ_FOR_EACH(EZ_INIT_PARAM_CALL, ,@1, @&quot;string&quot;)
</code></pre></div><p>被展开为</p> <div class="language- extra-class"><pre class="language-text"><code>EZ_FOR_EACH_ITER_(0, @1, EZ_INIT_PARAM_CALL) EZ_FOR_EACH_ITER_(1, @&quot;string&quot;, EZ_INIT_PARAM_CALL)
</code></pre></div><p>我们先关注<code>EZ_FOR_EACH_ITER_(0, @1, EZ_INIT_PARAM_CALL)</code>的展开情况。<code>EZ_FOR_EACH_ITER_(1, @&quot;string&quot;, EZ_INIT_PARAM_CALL)</code>和它是类似的。
根据</p> <div class="language- extra-class"><pre class="language-text"><code>#define EZ_FOR_EACH_ITER_(INDEX, PARAM, MACRO)               MACRO(INDEX, PARAM)
#define _EZ_INIT_PARAM_CALL_FIRST(index, param)              EZ_ORDINAL_CAP_AT(index):param
#define _EZ_INIT_PARAM_CALL(index, param)                    EZ_ORDINAL_AT(index):param
#define EZ_INIT_PARAM_CALL(index, param)                     EZ_IF_EQ(0, index)(_EZ_INIT_PARAM_CALL_FIRST(index, param))(_EZ_INIT_PARAM_CALL(index, param))
</code></pre></div><p>那么<code>EZ_FOR_EACH_ITER_(0, @1, EZ_INIT_PARAM_CALL)</code>会被展开为<code>EZ_INIT_PARAM_CALL(0, @1)</code>，进而被展开为</p> <div class="language- extra-class"><pre class="language-text"><code>EZ_IF_EQ(0, 0)(_EZ_INIT_PARAM_CALL_FIRST(0, @1))(_EZ_INIT_PARAM_CALL(0, @1))
</code></pre></div><p><code>EZ_IF_EQ</code>这个宏的定义如下</p> <div class="language- extra-class"><pre class="language-text"><code>#define EZ_IF_EQ(A, B)                                       EZ_CONCAT(EZ_IF_EQ, A)(B)

#define EZ_CONSUME_(...)
#define EZ_EXPAND_(...)                                      __VA_ARGS__

#define EZ_IF_EQ0(VALUE)                                     EZ_CONCAT(EZ_IF_EQ0_, VALUE)
#define EZ_IF_EQ0_0(...)                                     __VA_ARGS__ EZ_CONSUME_
#define EZ_IF_EQ0_1(...)                                     EZ_EXPAND_
#define EZ_IF_EQ0_2(...)                                     EZ_EXPAND_
#define EZ_IF_EQ0_3(...)                                     EZ_EXPAND_
#define EZ_IF_EQ0_4(...)                                     EZ_EXPAND_
#define EZ_IF_EQ0_5(...)                                     EZ_EXPAND_
// 中间定义都是类似的，为了节省篇幅就不列出了
#define EZ_IF_EQ0_18(...)                                    EZ_EXPAND_
#define EZ_IF_EQ0_19(...)                                    EZ_EXPAND_
#define EZ_IF_EQ0_20(...)                                    EZ_EXPAND_

#define EZ_IF_EQ1(VALUE)                                        EZ_IF_EQ0(EZ_DEC(VALUE))
#define EZ_IF_EQ2(VALUE)                                     EZ_IF_EQ1(EZ_DEC(VALUE))
#define EZ_IF_EQ3(VALUE)                                     EZ_IF_EQ2(EZ_DEC(VALUE))
#define EZ_IF_EQ4(VALUE)                                     EZ_IF_EQ3(EZ_DEC(VALUE))
#define EZ_IF_EQ5(VALUE)                                     EZ_IF_EQ4(EZ_DEC(VALUE))
// 中间定义都是类似的，为了节省篇幅就不列出了
#define EZ_IF_EQ18(VALUE)                                    EZ_IF_EQ17(EZ_DEC(VALUE))
#define EZ_IF_EQ19(VALUE)                                    EZ_IF_EQ18(EZ_DEC(VALUE))
#define EZ_IF_EQ20(VALUE)                                    EZ_IF_EQ19(EZ_DEC(VALUE))
</code></pre></div><p>那么<code>EZ_IF_EQ(0, 0)</code>会被展开为<code>EZ_IF_EQ0(0)</code>，<code>EZ_IF_EQ0(0)</code>会被展开为<code>EZ_IF_EQ0_0</code>，所以</p> <div class="language- extra-class"><pre class="language-text"><code>EZ_IF_EQ(0, 0)(_EZ_INIT_PARAM_CALL_FIRST(0, @1))(_EZ_INIT_PARAM_CALL(0, @1))
</code></pre></div><p>会被展开为</p> <div class="language- extra-class"><pre class="language-text"><code>EZ_IF_EQ0_0(_EZ_INIT_PARAM_CALL_FIRST(0, @1))(_EZ_INIT_PARAM_CALL(0, @1))
</code></pre></div><p><code>_EZ_INIT_PARAM_CALL_FIRST(0, @1)</code>会被展开为<code>EZ_ORDINAL_CAP_AT(0):@1</code>，<code>_EZ_INIT_PARAM_CALL(0, @1)</code>会被展开为<code>EZ_ORDINAL_AT(0):@1</code>。
<code>EZ_ORDINAL_CAP_AT</code>和<code>EZ_ORDINAL_AT</code>的定义如下</p> <div class="language- extra-class"><pre class="language-text"><code>#define EZ_ORDINAL_AT(N)    EZ_ARG_AT(N, EZ_ORDINAL_NUMBERS)
#define EZ_ORDINAL_CAP_AT(N) EZ_ARG_AT(N, EZ_ORDINAL_CAP_NUMBERS)
#define EZ_ORDINAL_NUMBERS  first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth, eleventh, twelfth, thirteenth, fourteenth, fifteenth, sixteenth, seventeenth, eighteenth, nineteenth, twentieth
#define EZ_ORDINAL_CAP_NUMBERS  First, Second, Third, Fourth, Fifth, Sixth, Seventh, Eighth, Ninth, Tenth, Eleventh, Twelfth, Thirteenth, Fourteenth, Fifteenth, Sixteenth, Seventeenth, Eighteenth, Nineteenth, Twentieth
</code></pre></div><p>而 <code>EZ_ARG_AT(N, EZ_ORDINAL_NUMBERS)</code>这个宏是取<code>EZ_ORDINAL_NUMBERS</code>中的第 N 个参数，因此<code>EZ_ORDINAL_CAP_AT(0):@1</code>也就是<code>First:@1</code>，<code>EZ_ORDINAL_AT(0):@1</code>也就是<code>first:@1</code>。
所以</p> <div class="language- extra-class"><pre class="language-text"><code>EZ_IF_EQ0_0(_EZ_INIT_PARAM_CALL_FIRST(0, @1))(_EZ_INIT_PARAM_CALL(0, @1))
</code></pre></div><p>也就是</p> <div class="language- extra-class"><pre class="language-text"><code>EZ_IF_EQ0_0(First:@1)(first:@1)
</code></pre></div><p>由</p> <div class="language- extra-class"><pre class="language-text"><code>#define EZ_IF_EQ0_0(...)    __VA_ARGS__ EZ_CONSUME_
#define EZ_CONSUME_(...)
</code></pre></div><p>可知，</p> <div class="language- extra-class"><pre class="language-text"><code>EZ_IF_EQ0_0(First:@1)(first:@1)
</code></pre></div><p>会被展开为<code>First:@1 EZ_CONSUME_(first:@1)</code>，进而展开为<code>First:@1</code>。
同理</p> <div class="language- extra-class"><pre class="language-text"><code>EZ_FOR_EACH_ITER_(1, @&quot;string&quot;, EZ_INIT_PARAM_CALL)
</code></pre></div><p>展开后得到<code>Second:@&quot;string&quot;</code>。
那么，</p> <div class="language- extra-class"><pre class="language-text"><code>EZ_FOR_EACH(EZ_INIT_PARAM_CALL, ,@1, @&quot;string&quot;)
</code></pre></div><p>最终被展开的结果就是<code>First:@1 Second:@&quot;string&quot;</code>，所以</p> <div class="language- extra-class"><pre class="language-text"><code>EZ_CONCAT(initWith, EZ_FOR_EACH(EZ_INIT_PARAM_CALL, ,@1, @&quot;string&quot;))
</code></pre></div><p>展开的结果就是<code>initWithFirst:@1 Second:@&quot;string&quot;</code>。</p> <p>因此<code>EZTupleAs(EZTuple2, @1, @&quot;string&quot;)</code>就是</p> <div class="language- extra-class"><pre class="language-text"><code>[[EZTuple2 alloc] initWithFirst:@1 Second:@&quot;string&quot;]
</code></pre></div><p>所以最开始的<code>EZTuple(@1,@&quot;string&quot;)</code>就被转换为了 Objective-C 中的类的创建语法。</p> <h2 id="ez-tuple-classes-def"><a href="#ez-tuple-classes-def" class="header-anchor">#</a> EZ_TUPLE_CLASSES_DEF</h2> <p>回到最开始的声明：</p> <div class="language- extra-class"><pre class="language-text"><code>EZTuple2&lt;NSNumber *, NSString *&gt; *tuple = EZTuple(@1, @&quot;string&quot;);
</code></pre></div><p>左边的<code>EZTuple2</code>是一个类的名字，但是如果通过Xcode 中的<code>Go To Definition</code>来查看这个类的定义的话，会发现 Xcode 将这个类的定义定位到了一个文件中，这个文件里除了头文件外只有一行宏定义：</p> <div class="language- extra-class"><pre class="language-text"><code>// EZTupleSubClasses.h
#import &lt;Foundation/Foundation.h&gt;
#import &lt;EasyTuple/EZMetaMacros.h&gt;
EZ_TUPLE_CLASSES_DEF
</code></pre></div><p><code>EZ_TUPLE_CLASSES_DEF</code>这个宏的定义如下</p> <div class="language- extra-class"><pre class="language-text"><code>#define EZ_TUPLE_CLASSES_DEF    EZ_FOR(20, EZ_TUPLE_DEF_FOREACH, ;)
</code></pre></div><p>而 <code>EZ_FOR</code>的定义则是</p> <div class="language- extra-class"><pre class="language-text"><code>#define EZ_FOR(COUNT, MARCO, SEP)                            EZ_CONCAT(EZ_FOR, COUNT)(MARCO, SEP)
#define EZ_FOR0(MARCO, SEP)
#define EZ_FOR1(MARCO, SEP)                                  MARCO(0)
#define EZ_FOR2(MARCO, SEP)                                  EZ_FOR1(MARCO, SEP) SEP MARCO(1)
#define EZ_FOR3(MARCO, SEP)                                  EZ_FOR2(MARCO, SEP) SEP MARCO(2)
#define EZ_FOR4(MARCO, SEP)                                  EZ_FOR3(MARCO, SEP) SEP MARCO(3)
#define EZ_FOR5(MARCO, SEP)                                  EZ_FOR4(MARCO, SEP) SEP MARCO(4)
// 中间定义都是类似的，为了节省篇幅就不列出了
#define EZ_FOR19(MARCO, SEP)                                 EZ_FOR18(MARCO, SEP) SEP MARCO(18)
#define EZ_FOR20(MARCO, SEP)                                 EZ_FOR19(MARCO, SEP) SEP MARCO(19)
</code></pre></div><p>对于<code>EZ_FOR(20, EZ_TUPLE_DEF_FOREACH, ;)</code>，<code>COUNT</code>为20，<code>MACRO</code>为<code>EZ_TUPLE_DEF_FOREACH</code>，<code>SEP</code>为<code>;</code>，因此它会被展开为<code>EZ_CONCAT(EZ_FOR, COUNT)(MARCO, SEP)</code>，即<code>EZ_FOR20(EZ_TUPLE_DEF_FOREACH,;)</code>。而<code>EZ_FOR20(EZ_TUPLE_DEF_FOREACH,;)</code>展开后得到</p> <div class="language- extra-class"><pre class="language-text"><code>EZ_FOR19(EZ_TUPLE_DEF_FOREACH,;) ; EZ_TUPLE_DEF_FOREACH(19)
</code></pre></div><p><code>EZ_FOR19(EZ_TUPLE_DEF_FOREACH,;)</code>展开后得到</p> <div class="language- extra-class"><pre class="language-text"><code>EZ_FOR18(EZ_TUPLE_DEF_FOREACH,;) ; EZ_TUPLE_DEF_FOREACH(18) ; EZ_TUPLE_DEF_FOREACH(18)
</code></pre></div><p>这样一层层展开，最终的结果为</p> <div class="language- extra-class"><pre class="language-text"><code>EZ_TUPLE_DEF_FOREACH(0) ; EZ_TUPLE_DEF_FOREACH(1) ; EZ_TUPLE_DEF_FOREACH(2) ; ... EZ_TUPLE_DEF_FOREACH(18); EZ_TUPLE_DEF_FOREACH(19)
</code></pre></div><p><code>EZ_TUPLE_DEF_FOREACH(index)</code>的定义如下</p> <div class="language- extra-class"><pre class="language-text"><code>#define EZ_TUPLE_DEF_FOREACH(index) EZ_TUPLE_DEF(EZ_INC(index))
</code></pre></div><p>内层的<code>EZ_INC(index)</code>会对index进行加1操作，那么<code>EZ_TUPLE_CLASSES_DEF</code>就会展开为</p> <div class="language- extra-class"><pre class="language-text"><code>EZ_TUPLE_DEF(1) ; EZ_TUPLE_DEF(2) ; ... EZ_TUPLE_DEF(18) ; EZ_TUPLE_DEF(19) ; EZ_TUPLE_DEF(20)
</code></pre></div><p>接下来我们再看一下 <code>EZ_TUPLE_DEF(i)</code>的定义：</p> <div class="language- extra-class"><pre class="language-text"><code>#define EZ_TUPLE_DEF(i)                                                                                                         \
@interface EZ_CONCAT(EZTuple, i)&lt;EZ_FOR_COMMA(i, EZ_GENERIC_TYPE)&gt; :EZTupleBase                                                     \
                                                                                                                               \
EZ_FOR_RECURSIVE(i, EZ_PROPERTY_DEF, ;);                                                                                         \
                                                                                                                               \
@property (nonatomic, strong) EZ_CHARS_AT(EZ_DEC(i)) last;                                                                       \
                                                                                                                               \
- (instancetype)EZ_CONCAT(initWith, EZ_FOR_SPACE(i, EZ_INIT_PARAM));                                                              \
                                                                                                                               \
@end
</code></pre></div><p>可以看出<code>EZ_TUPLE_DEF(i)</code>展开后是一个类的定义，并且这个类的定义明显地可以分为三部分：第一部分是拼接出来的类名，该类继承自<code>EZTupleBase</code>，第二部分是通过<code>EZ_FOR_RECURSIVE</code>生成的属性，第三部分是拼接出来的初始化方法。</p> <h3 id="ez-for-comma"><a href="#ez-for-comma" class="header-anchor">#</a> EZ_FOR_COMMA</h3> <p>这个宏出现在类名中，</p> <div class="language- extra-class"><pre class="language-text"><code>#define EZ_FOR_COMMA(COUNT, MARCO)                           EZ_CONCAT(EZ_FOR_COMMA, COUNT)(MARCO)
#define EZ_FOR_COMMA0(MARCO)
#define EZ_FOR_COMMA1(MARCO)                                 MARCO(0)
#define EZ_FOR_COMMA2(MARCO)                                 EZ_FOR_COMMA1(MARCO), MARCO(1)
#define EZ_FOR_COMMA3(MARCO)                                 EZ_FOR_COMMA2(MARCO), MARCO(2)
#define EZ_FOR_COMMA4(MARCO)                                 EZ_FOR_COMMA3(MARCO), MARCO(3)
#define EZ_FOR_COMMA5(MARCO)                                 EZ_FOR_COMMA4(MARCO), MARCO(4)
// 中间定义都是类似的，为了节省篇幅就不列出了
#define EZ_FOR_COMMA18(MARCO)                                EZ_FOR_COMMA17(MARCO), MARCO(17)
#define EZ_FOR_COMMA19(MARCO)                                EZ_FOR_COMMA18(MARCO), MARCO(18)
#define EZ_FOR_COMMA20(MARCO)                                EZ_FOR_COMMA19(MARCO), MARCO(19)
</code></pre></div><p>这个宏和上面提过的<code>EZ_FOR</code>非常类似，所以展开的结果也是类似的。那么对于<code>EZ_FOR_COMMA(2, EZ_GENERIC_TYPE)</code>，展开的结果为</p> <div class="language- extra-class"><pre class="language-text"><code>EZ_GENERIC_TYPE(0), EZ_GENERIC_TYPE(1)
</code></pre></div><h3 id="ez-generic-type-index"><a href="#ez-generic-type-index" class="header-anchor">#</a> EZ_GENERIC_TYPE(index)</h3> <div class="language- extra-class"><pre class="language-text"><code>#define EZ_GENERIC_TYPE(index)                               __covariant EZ_CHARS_AT(index): id

#define EZ_CHARS_AT(N)  EZ_ARG_AT(N, EZ_CHARS)

#define EZ_CHARS    A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z
</code></pre></div><p><code>EZ_CHARS_AT(N)</code>的作用是从<code>EZ_CHARS</code>取出第 N 位的字符，因此<code>EZ_GENERIC_TYPE(0)</code>会被展开为<code>__covariant A: id</code>，<code>EZ_GENERIC_TYPE(1)</code>会被展开为<code>__covariant B: id</code>，</p> <p>所以</p> <div class="language- extra-class"><pre class="language-text"><code>EZ_FOR_COMMA(i, EZ_GENERIC_TYPE)
</code></pre></div><p>会被展开为</p> <div class="language- extra-class"><pre class="language-text"><code>__covariant A: id, __covariant B: id
</code></pre></div><p><code>__covariant</code>这个关键字表示协变性，即子类型可以强转到父类型，是Objective-C 新出现的一个用来表达泛型能力的关键字，与它一同出现的另一个关键字是<code>____contravariant</code>，表示逆变性，即父类型可以强转到子类型。对这两个关键字的更详细介绍，可以看一下 sunnyxx 老师的博文<a href="https://blog.sunnyxx.com/2015/06/12/objc-new-features-in-2015/" target="_blank" rel="noopener noreferrer">《2015 Objective-C 新特性》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>回到类的接口定义，根据上面的分析，</p> <div class="language- extra-class"><pre class="language-text"><code>@interface EZ_CONCAT(EZTuple, i)&lt;EZ_FOR_COMMA(i, EZ_GENERIC_TYPE)&gt; :EZTupleBase
</code></pre></div><p>会被展开为</p> <div class="language- extra-class"><pre class="language-text"><code>@interface EZTuple2&lt;__covariant A: id, __covariant B: id)&gt; :EZTupleBase
</code></pre></div><h3 id="ez-for-recursive"><a href="#ez-for-recursive" class="header-anchor">#</a> EZ_FOR_RECURSIVE</h3> <p>这个宏被用于类定义的第二部分，即类的属性的生成中。它的定义和<code>EZ_FOR</code>也是类似的：</p> <div class="language- extra-class"><pre class="language-text"><code>#define EZ_FOR_RECURSIVE(COUNT, MARCO, SEP)                  EZ_CONCAT(EZ_FOR_RECURSIVE, COUNT)(MARCO, SEP)
#define EZ_FOR_RECURSIVE0(MARCO, SEP)
#define EZ_FOR_RECURSIVE1(MARCO, SEP)                        MARCO(0)
#define EZ_FOR_RECURSIVE2(MARCO, SEP)                        EZ_FOR_RECURSIVE1(MARCO, SEP) SEP MARCO(1)
#define EZ_FOR_RECURSIVE3(MARCO, SEP)                        EZ_FOR_RECURSIVE2(MARCO, SEP) SEP MARCO(2)
#define EZ_FOR_RECURSIVE4(MARCO, SEP)                        EZ_FOR_RECURSIVE3(MARCO, SEP) SEP MARCO(3)
#define EZ_FOR_RECURSIVE5(MARCO, SEP)                        EZ_FOR_RECURSIVE4(MARCO, SEP) SEP MARCO(4)
// 中间定义都是类似的，为了节省篇幅就不列出了
#define EZ_FOR_RECURSIVE19(MARCO, SEP)                       EZ_FOR_RECURSIVE18(MARCO, SEP) SEP MARCO(18)
#define EZ_FOR_RECURSIVE20(MARCO, SEP)                       EZ_FOR_RECURSIVE19(MARCO, SEP) SEP MARCO(19)
</code></pre></div><p>所以</p> <div class="language- extra-class"><pre class="language-text"><code>EZ_FOR_RECURSIVE(2, EZ_PROPERTY_DEF, ;)
</code></pre></div><p>就会被展开为</p> <div class="language- extra-class"><pre class="language-text"><code>EZ_PROPERTY_DEF(0) ; EZ_PROPERTY_DEF(1)
</code></pre></div><h3 id="ez-property-def-index"><a href="#ez-property-def-index" class="header-anchor">#</a> EZ_PROPERTY_DEF(index)</h3> <div class="language- extra-class"><pre class="language-text"><code>#define EZ_PROPERTY_DEF(index)  @property (nonatomic, strong) EZ_CHARS_AT(index) EZ_ORDINAL_AT(index)

#define EZ_ORDINAL_NUMBERS  first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth, eleventh, twelfth, thirteenth, fourteenth, fifteenth, sixteenth, seventeenth, eighteenth, nineteenth, twentieth

#define EZ_ORDINAL_AT(N)    EZ_ARG_AT(N, EZ_ORDINAL_NUMBERS)
</code></pre></div><p>所以</p> <div class="language- extra-class"><pre class="language-text"><code>EZ_FOR_RECURSIVE(2, EZ_PROPERTY_DEF, ;)
</code></pre></div><p>首先被展开为</p> <div class="language- extra-class"><pre class="language-text"><code>EZ_PROPERTY_DEF(0) ; EZ_PROPERTY_DEF(1)
</code></pre></div><p>进而被展开为</p> <div class="language- extra-class"><pre class="language-text"><code>@property (nonatomic, strong) A first;
@property (nonatomic, strong) B second;
</code></pre></div><h3 id="ez-for-space"><a href="#ez-for-space" class="header-anchor">#</a> EZ_FOR_SPACE</h3> <p>这个宏的名字和<code>EZ_FOR_COMMA</code>类似，定义也类似，因此它的作用也是类似的，这里就不浪费篇幅了。<code>EZ_FOR_SPACE(2, EZ_INIT_PARAM)</code>会被展开为</p> <div class="language- extra-class"><pre class="language-text"><code>EZ_INIT_PARAM(0) EZ_INIT_PARAM(1)
</code></pre></div><p>这里我们也只看一下<code>EZ_INIT_PARAM(0)</code>是如何展开的，<code>EZ_INIT_PARAM(1)</code>的展开和它是类似的。</p> <div class="language- extra-class"><pre class="language-text"><code>#define _EZ_INIT_PARAM_FIRST(index)                          EZ_ORDINAL_CAP_AT(index):(EZ_CHARS_AT(index))EZ_ORDINAL_AT(index)
#define _EZ_INIT_PARAM(index)                                EZ_ORDINAL_AT(index):(EZ_CHARS_AT(index))EZ_ORDINAL_AT(index)
#define EZ_INIT_PARAM(index)                                 EZ_IF_EQ(0, index)(_EZ_INIT_PARAM_FIRST(index))(_EZ_INIT_PARAM(index))
</code></pre></div><p><code>EZ_INIT_PARAM(0)</code>首先被展开为</p> <div class="language- extra-class"><pre class="language-text"><code>EZ_IF_EQ(0,0)(_EZ_INIT_PARAM_FIRST(0))(_EZ_INIT_PARAM(0))
</code></pre></div><p><code>_EZ_INIT_PARAM_FIRST(0)</code>会被展开为</p> <div class="language- extra-class"><pre class="language-text"><code>First:(A)first
</code></pre></div><p>而<code>_EZ_INIT_PARAM(0)</code>会被展开为</p> <div class="language- extra-class"><pre class="language-text"><code>first:(A)first
</code></pre></div><p>所以</p> <div class="language- extra-class"><pre class="language-text"><code>EZ_IF_EQ(0,0)(_EZ_INIT_PARAM_FIRST(0))(_EZ_INIT_PARAM(0))
</code></pre></div><p>也就是</p> <div class="language- extra-class"><pre class="language-text"><code>EZ_IF_EQ(0,0)(First:(A)first)(first:(A)first)
</code></pre></div><p><code>EZ_IF_EQ(0,0)</code>也就是<code>EZ_IF_EQ0(0)</code>，也就是<code>EZ_IF_EQ0_0</code>，
根据</p> <div class="language- extra-class"><pre class="language-text"><code>#define EZ_IF_EQ0_0(...)                                     __VA_ARGS__ EZ_CONSUME_
</code></pre></div><p><code>EZ_IF_EQ(0,0)(First:(A)first)(first:(A)first)</code>就是</p> <div class="language- extra-class"><pre class="language-text"><code>First:(A)first EZ_CONSUME_(first:(A)first)
</code></pre></div><p>最终就是<code>First:(A)first</code>。即<code>EZ_INIT_PARAM(0)</code>最终展开的结果就是<code>First:(A)first</code>。同理，<code>EZ_INIT_PARAM(1)</code>最终展开的结果就是<code>Second:(B)second</code>。
因此，</p> <div class="language- extra-class"><pre class="language-text"><code>- (instancetype)EZ_CONCAT(initWith, EZ_FOR_SPACE(i, EZ_INIT_PARAM));   
</code></pre></div><p>展开后的结果就是</p> <div class="language- extra-class"><pre class="language-text"><code>- (instancetype)initWithFirst:(A)first Second:(B)second;
</code></pre></div><p>回到一开始的类定义</p> <div class="language- extra-class"><pre class="language-text"><code>#define EZ_TUPLE_DEF(i)                                                                                                         \
@interface EZ_CONCAT(EZTuple, i)&lt;EZ_FOR_COMMA(i, EZ_GENERIC_TYPE)&gt; :EZTupleBase                                                     \
                                                                                                                               \
EZ_FOR_RECURSIVE(i, EZ_PROPERTY_DEF, ;);                                                                                         \
                                                                                                                               \
@property (nonatomic, strong) EZ_CHARS_AT(EZ_DEC(i)) last;                                                                       \
                                                                                                                               \
- (instancetype)EZ_CONCAT(initWith, EZ_FOR_SPACE(i, EZ_INIT_PARAM));                                                              \
                                                                                                                               \
@end
</code></pre></div><p>当 i = 2的时候，上面这段宏就会被展开为</p> <div class="language- extra-class"><pre class="language-text"><code>@interface EZTuple2&lt;__covariant A: id, __covariant B: id)&gt; :EZTupleBase

@property (nonatomic, strong) A first;
@property (nonatomic, strong) B second;
@property (nonatomic, strong) B last;

- (instancetype)initWithFirst:(A)first Second:(B)second;

@end
</code></pre></div><p>我们在前面分析过，<code>EZ_TUPLE_CLASSES_DEF</code>会被展开为</p> <div class="language- extra-class"><pre class="language-text"><code>EZ_TUPLE_DEF(1) ; EZ_TUPLE_DEF(2) ; ... EZ_TUPLE_DEF(18) ; EZ_TUPLE_DEF(19) ; EZ_TUPLE_DEF(20)
</code></pre></div><p>所以在预编译时，这些宏就会被展开成<code>EZTuple1</code>、<code>EZTuple2</code>……<code>EZTuple20</code>等类的定义。也就是说，<code>EasyTuple</code>通过这个宏为我们一口气定义了20个元祖类。这样的好处是显而易见的：如果不使用宏的话，那么为了创建这么多个类，我们就要手动去书写很多重复的代码；而使用宏的话，则能够通过宏的巧妙组合在预编译的时候自动生成代码。</p> <h2 id="小结"><a href="#小结" class="header-anchor">#</a> 小结</h2> <p>宏是一门非常非常强大的技术，但是之前我一直不知道它有这么多高级的玩法和用法，看了<code>EasyTuple</code>的源代码，真是让人大开眼界。其实<code>EasyTuple</code>中还有一些上文中没有提到的宏的用法，限于篇幅这里就不一一展开分析了，不过万变不离其宗，只需要像剥洋葱一样一层一层地进行定义的替换，再加一点点耐心和细心，那么再复杂的宏也不在话下。</p> <h2 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料：</h2> <ol><li><a href="https://halfrost.com/reactivecocoa_macro/" target="_blank" rel="noopener noreferrer">ReactiveCocoa 中奇妙无比的“宏”魔法<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://blog.sunnyxx.com/2014/03/06/rac_1_macros/" target="_blank" rel="noopener noreferrer">Reactive Cocoa Tutorial [1] = 神奇的Macros<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ol></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/tamarous_blog/assets/js/app.06befc6f.js" defer></script><script src="/tamarous_blog/assets/js/2.cd603132.js" defer></script><script src="/tamarous_blog/assets/js/46.2a672594.js" defer></script>
  </body>
</html>
