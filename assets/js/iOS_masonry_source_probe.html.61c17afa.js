"use strict";(self.webpackChunktamarous_blog=self.webpackChunktamarous_blog||[]).push([[710],{2756:(t,e)=>{e.A=(t,e)=>{const n=t.__vccOpts||t;for(const[t,i]of e)n[t]=i;return n}},6345:(t,e,n)=>{n.r(e),n.d(e,{comp:()=>o,data:()=>s});var i=n(5399);const a={},o=(0,n(2756).A)(a,[["render",function(t,e){return(0,i.uX)(),(0,i.CE)("div",null,e[0]||(e[0]=[(0,i.Fv)('<h1 id="masonry-源代码剖析" tabindex="-1"><a class="header-anchor" href="#masonry-源代码剖析"><span>Masonry 源代码剖析</span></a></h1><p><a href="https://github.com/SnapKit/Masonry" target="_blank" rel="noopener noreferrer">Masonry</a> 是一个用来代替苹果原生的AutoLayout 的自动布局框架。这个库的代码量不是很多，而且使用也很简单方便，那么就让我们深入到这个库的内部，看看它是怎么实现的。</p><h2 id="使用范例" tabindex="-1"><a class="header-anchor" href="#使用范例"><span>使用范例</span></a></h2><p>下面是一个使用Masonry 的范例：</p><pre><code>[view mas_makeConstraints: ^(MASConstraintMaker *make) {\n    make.top.equalTo(superview.mas_top).with.offset(padding.top);\n    make.left.equalTo(superview.mas_left).with.offset(padding.left);\n    make.bottom.equalTo(superview.mas_bottom).with.offset(-padding.bottom);\n    make.right.equalTo(superview.mas_right).with.offset(-padding.right);\n}];\n</code></pre><p>可以看到，view 与superview 之间的约束，是通过一个block 设置的。这个block 接受一个类型为MASConstraintMaker 的参数make，然后在block 函数体内通过make 来实现约束设置。make 看起来像是view 的一个替身，当我们写</p><pre><code>make.top.equalTo(superview.mas_top).with.offset(padding.top);\n</code></pre><p>时，实际效果是</p><pre><code>view.top.equalTo(superview.mas_top).with.offset(padding.top);\n</code></pre><h2 id="内部实现" tabindex="-1"><a class="header-anchor" href="#内部实现"><span>内部实现</span></a></h2><h3 id="mas-makeconstraints" tabindex="-1"><a class="header-anchor" href="#mas-makeconstraints"><span>mas_makeConstraints:</span></a></h3><p>在Xcode 中，按住Command，在方法上点击鼠标左键就可以进入方法的内部实现。我们进入<code>mas_makeConstraints:</code>，可以看到这个方法的实现如下：</p><pre><code>- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *))block       {\n    self.translatesAutoresizingMaskIntoConstraints = NO;\n    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView: self];\n    block(constraintMaker);\n    return [constraintMaker install];\n}\n</code></pre><p>首先要将被设置的view 的<code>translatesAutoresizingMaskIntoConstraints</code>属性设置成NO，这样才可以成功添加约束。</p><p>然后，创建一个<code>MASConstraintMaker</code>的实例。block 接受这个实例，然后执行block 块内的内容。最后返回<code>[constraintMaker install]</code>的结果。</p><h3 id="masconstraintmaker" tabindex="-1"><a class="header-anchor" href="#masconstraintmaker"><span>MASConstraintMaker</span></a></h3><h4 id="初始化" tabindex="-1"><a class="header-anchor" href="#初始化"><span>初始化</span></a></h4><pre><code>// MASContraintMaker.m\n\n// MAS_VIEW 是UIView 的别名\n@property (nonatomic, weak) MAS_VIEW *view;\n\n- (id) initWithView:(MAS_VIEW *) view {\n    self = [super init];\n    if (! self) {\n        return nil;\n    }\n    self.view = view;\n    self.constraints = NSMutableArray.new;\n    return self;\n}\n</code></pre><p>在初始化方法中，<code>MASContraintMaker</code> 将要设置的视图赋值给它的属性view，因此 <code>MASContraintMaker</code> 对将要设置的视图拥有了一个弱引用。</p><h4 id="block-的执行" tabindex="-1"><a class="header-anchor" href="#block-的执行"><span>block 的执行</span></a></h4><p>block 中实际进行了约束的设置工作。</p><pre><code>    make.top.equalTo(superview.mas_top).with.offset(padding.top);\n    make.left.equalTo(superview.mas_left).with.offset(padding.left);\n    make.bottom.equalTo(superview.mas_bottom).with.offset(-padding.bottom);\n    make.right.equalTo(superview.mas_right).with.offset(-padding.right);\n</code></pre><p>这个调用过程是链式的，即每次调用都是作用于<code>MASConstraint</code> 类型上，而本次调用的返回类型仍然是<code>MASConstraint</code> 类型。</p><h5 id="right-left-bottom-top" tabindex="-1"><a class="header-anchor" href="#right-left-bottom-top"><span>right,left,bottom,top</span></a></h5><p>right，left，bottom和top 实际上是<code>MASConstraintMaker</code>中的相应属性的getter 方法，以top 为例，其定义如下：</p><pre><code>- (MASConstraint *) top {\n    return [self addConstraintWithLayoutAttribute: NSLayoutAttributeTop];\n}\n</code></pre><p>这个方法中还涉及到一些其他方法：</p><pre><code>- (MASContraint *) addConstraintWithLayoutAttribute:(NSLayoutAttribute) layoutAttribute {\n    return [self constraint: nil addConstraintWithLayoutAttribute: layoutAttribute];\n}\n\n- (MASConstraint *) constraint:(MASContraint *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute) layoutAttribute {\n    MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] initWithView:self.view layoutAttribute:layoutAttribute]; // 1\n    MASViewAttribute *newAttribute = [[MASViewAttribute alloc] initWithFirstViewAttribute:viewAttribute]; // 2\n    if ([constraint isKindOfClass: MASViewConstraint.class]) {\n        NSArray *children = @[constraint, newConstraint];\n        MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] initWithChildren: children];\n        compositeConstraint.delegate = self;\n        [self constraint: constraint shouleBeReplaceWithConstraint: compositeConstraint];\n        return compositeConstraint;\n    }\n    // 因为传入的constraint 为nil，所以直接进入下面的判断\n    if (! constraint) {\n        newConstraint.delegate = self;\n        [self.constraints addObject: newConstraint]; // 3\n    }\n    return newConstraint;\n}\n</code></pre><p>在上面这个方法中：</p><ol><li>根据传入的要设置的<code>NSLayoutAttribute</code> 生成对应的<code>MASViewAttribute</code>。</li><li>根据<code>MASViewAttribute</code> 生成当前视图的新约束。</li><li>将2中生成的新约束加入<code>MASContraintMaker</code> 的约束数组中。</li></ol><h5 id="equalto-greaterthanorequalto-lessthanorequalto" tabindex="-1"><a class="header-anchor" href="#equalto-greaterthanorequalto-lessthanorequalto"><span>equalTo, greaterThanOrEqualTo, lessThanOrEqualTo</span></a></h5><pre><code>- (MASConstraint * (^)(id attr))equalTo;\n- (MASConstraint * (^)(id attr))greaterThanOrEqualTo;\n- (MASConstraint * (^)(id attr))lessThanOrEqualTo; \n</code></pre><p>这三个方法的参数是id 类型的，因此它们既可以接受NSValue 类型的参数，如NSNumber，CGPoint，CGSize等，也可以接受<code>UIView</code> 类型的参数，还可以接受<code>MASViewConstraint</code> 类型的参数。 当接受NSValue 类型的参数时，如</p><pre><code>make.top.equalTo(@100)\n</code></pre><p>表示当前视图的top与它的superview 的top相距100； 当接受<code>UIView</code> 类型的参数时，会和<code>UIView</code> 的对应属性做比较，如</p><pre><code>make.top.equalTo(secondView)\n</code></pre><p>表示当前视图和secondView 的top是平齐的； 当接受<code>MASViewConstraint</code> 类型的参数时，如</p><pre><code>make.bottom.equalTo(secondView.mas_bottom)\n</code></pre><p>表示当前视图和secondView 的bottom 是平齐的。</p><p>这个特性的实现原理会在稍后进行介绍。</p><p>以上方法虽然定义不同，但是内部实现相似，都是调用了<code>MASConstraint</code> 的<code>equalToWithRelation</code> 方法，但是传入了不同的参数：</p><pre><code>- (MASConstraint * (^)(id attr))equalTo 「\n    return ^id(id attribute) {\n        return self.equalToWithRelation(attribute, NSLayoutRelationEqual);\n    };\n}\n- (MASConstraint * (^)(id attr))greaterThanOrEqualTo {\n    return ^id(id attribute) {\n        return self.equalToWithRelation(attribute, NSLayoutRelationGreaterThanOrEqual);\n    };\n}\n- (MASConstraint * (^)(id attr)) lessThanOrEqualTo{\n    return ^id(id attribute) {\n        return self.equalToWithRelation(attribute,\n        NSLayoutRelationLessThanOrEqual);\n    };\n}\n</code></pre><p>继续向下寻找<code>equalToWithRelation</code> 的定义。使用Command + 鼠标左键，我们发现这个方法在三个地方有定义：</p><pre><code>[MASConstraint(Abstract) equalToWithRelation];\n[MASViewConstraint equalToWithRelation];\n[MASCompositeConstraint equalToWithRelation];\n</code></pre><p><code>MASCompositeConstraint</code> 和<code>MASViewContraint</code> 是<code>MASConstraint</code> 的子类。在<code>MASConstraint</code> 中定义了很多抽象方法，都是需要在这两个子类中进行实现的。</p><blockquote><p>MASCompositeConstraint: A composite with a predefined array of children.</p></blockquote><p>从定义和名称中可以看出，<code>MASCompositeConstraint</code> 是约束的组合。按照我的理解，它的作用可以看作是一颗树的根，这个根确定了哪些节点位于这棵树上，而树的子节点的类型都是<code>MASViewConstraint</code>。</p><p><code>equalToWithRelation</code> 是一个抽象方法，在<code>MASContraint</code> 中没有实现，如果调用此方法就会抛出一个异常：</p><pre><code>- (MASConstraint * (^)(id, NSLayoutRelation))equalToWithRelation { MASMethodNotImplemented(); }\n\n#define MASMethodNotImplemented() \\\n@throw [NSException exceptionWithName:NSInternalInconsistencyException \\\n                               reason:[NSString stringWithFormat:@&quot;You must override %@ in a subclass.&quot;, NSStringFromSelector(_cmd)] \\\n                             userInfo:nil]\n</code></pre><p><code>MASViewConstraint</code> 重载了此方法：</p><pre><code>    - (MASConstraint * (^)(id, NSLayoutRelation))equalToWithRelation {\nreturn ^id(id attribute, NSLayoutRelation relation) {\n    if ([attribute isKindOfClass:NSArray.class]) { // 1\n        NSAssert(!self.hasLayoutRelation, @&quot;Redefinition of constraint relation&quot;);\n        NSMutableArray *children = NSMutableArray.new;\n        for (id attr in attribute) {\n            MASViewConstraint *viewConstraint = [self copy];\n            viewConstraint.layoutRelation = relation;\n            viewConstraint.secondViewAttribute = attr;\n            [children addObject:viewConstraint];\n        }\n        MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] initWithChildren:children];\n        compositeConstraint.delegate = self.delegate;\n        [self.delegate constraint:self shouldBeReplacedWithConstraint:compositeConstraint];\n        return compositeConstraint;\n    } else {\n        NSAssert(!self.hasLayoutRelation || self.layoutRelation == relation &amp;&amp; [attribute isKindOfClass:NSValue.class], @&quot;Redefinition of constraint relation&quot;);\n        self.layoutRelation = relation;\n        self.secondViewAttribute = attribute;  // 2\n        return self;\n    }\n};\n}\n</code></pre><ol><li><p>判断传入的attribute 是否为NSArray 类型。</p></li><li><p>如果不是，则将传入的参数赋值给某些属性。注意secondViewAttribute 这个属性的setter 方法，它并不是一个简单的赋值过程，而是会根据传入的attribute 的类型进行额外的设置。</p><pre><code> - (void)setSecondViewAttribute:(id)secondViewAttribute {\n\n     if ([secondViewAttribute isKindOfClass:NSValue.class]) {\n     \n     // 1 对应于上文中的equalTo(@100) 这种情况\n         [self setLayoutConstantWithValue:secondViewAttribute]; \n     } else if ([secondViewAttribute isKindOfClass:MAS_VIEW.class]) {\n     \n     // 2 对应于上文中的equalTo(secondView) 这种情况\n         _secondViewAttribute = [[MASViewAttribute alloc] initWithView:secondViewAttribute layoutAttribute:self.firstViewAttribute.layoutAttribute]; // 2\n     } else if ([secondViewAttribute isKindOfClass:MASViewAttribute.class]) {\n     \n     // 3 对应于上文中的equalTo(secondView.mas_bottom) 这种情况\n         _secondViewAttribute = secondViewAttribute;\n     } else {\n         NSAssert(NO, @&quot;attempting to add unsupported attribute: %@&quot;, secondViewAttribute);\n     }\n }\n</code></pre></li></ol><p><code>MASCompositeConstraint</code> 对此方法的实现则要简单得多：</p><pre><code>- (MASConstraint * (^)(id, NSLayoutRelation))equalToWithRelation {\n    return ^id(id attr, NSLayoutRelation relation) {\n        for (MASConstraint *constraint in self.childConstraints.copy) {\n            constraint.equalToWithRelation(attr, relation);\n    }\n        return self;\n    };\n}\n</code></pre><p>可以看出，这个方法的实现是递归的，它对当前<code>MASCompositeConstraint</code> 的每一个childConstraint 调用对应的<code>equalToWithRelation</code> 方法，如果当前某一个constraint 的childConstraint 为空，就返回这个constraint。怎么样，是不是有点类似于后续遍历？ 因为实际的工作都是由<code>MASViewConstraint</code> 类型完成的，下面我们就只关心方法在这个类中的实现。</p><h4 id="安装约束" tabindex="-1"><a class="header-anchor" href="#安装约束"><span>安装约束</span></a></h4><pre><code>- (NSArray *)install {\n    if (self.removeExisting) {\n        NSArray *installedConstraints = [MASViewConstraint installedConstraintsForView: self.view]; // 1\n        for (MASConstraint *constraint in installedConstraints) {\n            [constraint uninstall]; // 2\n        }\n    }\n    NSArray *constraints = self.constraints.copy;\n    for (MASConstraint *constraint in constraints) {\n        constraint.updateExisting = self.updateExisting;\n        [constraint install]; // 3\n    }\n    [self.constraints removeAllObjects]; // 4\n    return constraints;\n}\n</code></pre><p>在<code>MASConstraintMaker</code>的<code>install</code>方法中，有如下几个过程：</p><ol><li>查看当前视图上已经安装的约束。</li><li>对于<strong>已经</strong>安装的约束，逐一进行卸载。</li><li>对于<strong>将要</strong>安装的约束，逐一<code>[constaint install]</code>，进行安装。</li><li>将自身的<code>constraints</code>数组中的所有元素清除掉。</li></ol><h3 id="masviewconstraint" tabindex="-1"><a class="header-anchor" href="#masviewconstraint"><span>MASViewConstraint</span></a></h3><p>我们着重来看上一节描述的<code>[constraintMaker install]</code>中的第三点。</p><pre><code>// MASViewConstraint.m\n- (void)install {\nif (self.hasBeenInstalled) {\n    return;\n}\n\n// 1\nif ([self supportsActiveProperty] &amp;&amp; self.layoutConstraint) {\n    self.layoutConstraint.active = YES;\n    [self.firstViewAttribute.view.mas_installedConstraints addObject:self];\n    return;\n}\n\n// 2\nMAS_VIEW *firstLayoutItem = self.firstViewAttribute.item;\nNSLayoutAttribute firstLayoutAttribute = self.firstViewAttribute.layoutAttribute;\nMAS_VIEW *secondLayoutItem = self.secondViewAttribute.item;\nNSLayoutAttribute secondLayoutAttribute = self.secondViewAttribute.layoutAttribute;\n\n// 3\n// alignment attributes must have a secondViewAttribute\n// therefore we assume that is refering to superview\n// eg make.left.equalTo(@10)\nif (!self.firstViewAttribute.isSizeAttribute &amp;&amp; !self.secondViewAttribute) {\n    secondLayoutItem = self.firstViewAttribute.view.superview;\n    secondLayoutAttribute = firstLayoutAttribute;\n}\n\n// 4\nMASLayoutConstraint *layoutConstraint\n    = [MASLayoutConstraint constraintWithItem:firstLayoutItem\n                                    attribute:firstLayoutAttribute\n                                    relatedBy:self.layoutRelation\n                                       toItem:secondLayoutItem\n                                    attribute:secondLayoutAttribute\n                                   multiplier:self.layoutMultiplier\n                                     constant:self.layoutConstant];\n\nlayoutConstraint.priority = self.layoutPriority;\nlayoutConstraint.mas_key = self.mas_key;\n\n\n// 5\nif (self.secondViewAttribute.view) {\n    MAS_VIEW *closestCommonSuperview = [self.firstViewAttribute.view mas_closestCommonSuperview:self.secondViewAttribute.view];\n    NSAssert(closestCommonSuperview,\n             @&quot;couldn&#39;t find a common superview for %@ and %@&quot;,\n             self.firstViewAttribute.view, self.secondViewAttribute.view);\n    self.installedView = closestCommonSuperview;\n} else if (self.firstViewAttribute.isSizeAttribute) {\n    self.installedView = self.firstViewAttribute.view;\n} else {\n    self.installedView = self.firstViewAttribute.view.superview;\n}\n\n\nMASLayoutConstraint *existingConstraint = nil;\nif (self.updateExisting) {\n    existingConstraint = [self layoutConstraintSimilarTo:layoutConstraint];\n}\nif (existingConstraint) {\n    // just update the constant\n    existingConstraint.constant = layoutConstraint.constant;\n    self.layoutConstraint = existingConstraint;\n} else {\n    [self.installedView addConstraint:layoutConstraint];\n    self.layoutConstraint = layoutConstraint;\n    [firstLayoutItem.mas_installedConstraints addObject:self];\n}\n}\n</code></pre><p>在对代码进行分析之前，我们需要知道：因为每个约束需要处理的，是两个item 之间的关系。</p><blockquote><p>item1.attribute1 = multiplier × item2.attribute2 + constant // 约束等式</p></blockquote><p>所以<code>MASViewConstraint</code> 有两个属性，分别是</p><pre><code>@property (nonatomic, strong, readonly) MASViewAttribute *firstViewAttribute;\n</code></pre><p>和</p><pre><code>@property (nonatomic, strong, readonly) MASViewAttribute *secondViewAttribute;\n</code></pre><p>这两个属性分别描述了约束等式的左边和右边。 因此，代码的执行过程为：</p><ol><li>将当前约束加入约束等式左边的view 的已安装约束列表中。</li><li>获取当前约束的左右两边的item 和它们对应的layoutAttribute。</li><li>如果item1 描述的不是数值，并且item2 为nil，则当前约束对应着前面所说的<code>equalTo(@100)</code>这种情况，所以当前的约束的item2 应该是item1中view 的superview。这和我们平时手写UI时的逻辑是相同的。</li><li>调用系统API 来进行约束设置。</li><li>如果item2 是一个view，那么这个约束应该被安装在item1 和item2 的共同superview 上，因此需要找到item1 和item2 的最近共同superview。其他情况同理。</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>- (instancetype)mas_closestCommonSuperview:(MAS_VIEW *)view {</span></span>\n<span class="line"><span>    MAS_VIEW *closestCommonSuperview = nil;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    MAS_VIEW *secondViewSuperview = view;</span></span>\n<span class="line"><span>    while (!closestCommonSuperview &amp;&amp; secondViewSuperview) {</span></span>\n<span class="line"><span>        MAS_VIEW *firstViewSuperview = self;</span></span>\n<span class="line"><span>        while (!closestCommonSuperview &amp;&amp; firstViewSuperview) {</span></span>\n<span class="line"><span>            if (secondViewSuperview == firstViewSuperview) {</span></span>\n<span class="line"><span>                closestCommonSuperview = secondViewSuperview;</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span>            firstViewSuperview = firstViewSuperview.superview;</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>        secondViewSuperview = secondViewSuperview.superview;</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>    return closestCommonSuperview;</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结"><span>小结</span></a></h2><p>本文简要分析了用<code>Masonry</code> 设置视图间布局约束时的代码的内部实现。从分析过程中，我感受到了写一个库的难度，也体会到了那句话的含义：“将简洁留给用户，将复杂留给自己”。无论是<code>SDWebImage</code> 的一行代码设置图片还是<code>Masonry</code> 的链式设置方法，其简洁的背后藏有复杂的逻辑，恼人的边界处理和多种策略的应用。</p>',73)]))}]]),s=JSON.parse('{"path":"/iOS/masonry_source_probe.html","title":"Masonry 源代码剖析","lang":"en-US","frontmatter":{"category":"iOS","tags":["源码分析"]},"git":{"createdTime":1740927530000,"updatedTime":1740927530000,"contributors":[{"name":"Tamarous","username":"Tamarous","email":"hiwangzewei@qq.com","commits":1,"url":"https://github.com/Tamarous"}]},"readingTime":{"minutes":7.51,"words":2253},"filePathRelative":"iOS/masonry_source_probe.md","localizedDate":"March 2, 2025","excerpt":"\\n<p><a href=\\"https://github.com/SnapKit/Masonry\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">Masonry</a> 是一个用来代替苹果原生的AutoLayout 的自动布局框架。这个库的代码量不是很多，而且使用也很简单方便，那么就让我们深入到这个库的内部，看看它是怎么实现的。</p>\\n<h2>使用范例</h2>\\n<p>下面是一个使用Masonry 的范例：</p>\\n<pre><code>[view mas_makeConstraints: ^(MASConstraintMaker *make) {\\n    make.top.equalTo(superview.mas_top).with.offset(padding.top);\\n    make.left.equalTo(superview.mas_left).with.offset(padding.left);\\n    make.bottom.equalTo(superview.mas_bottom).with.offset(-padding.bottom);\\n    make.right.equalTo(superview.mas_right).with.offset(-padding.right);\\n}];\\n</code></pre>"}')}}]);