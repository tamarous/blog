(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{490:function(e,n,l){"use strict";l.r(n);var t=l(1),s=Object(t.a)({},(function(){var e=this,n=e.$createElement,l=e._self._c||n;return l("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[l("h1",{attrs:{id:"leetcode-21-merge-two-sorted-lists"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#leetcode-21-merge-two-sorted-lists"}},[e._v("#")]),e._v(" LeetCode-21-Merge Two Sorted Lists")]),e._v(" "),l("p",[e._v("这道题的要求是合并两个有序单链表。描述很简单，思路更加简单，就是先创建一个新的链表节点，然后用两个指针指向这两个单链表，比较这两个指针指向元素的大小，将较小的一个的值赋给新节点的元素，如果这两个元素相同，那随便赋谁的值都可以。当这两个链表有一个已经遍历完之后，就直接把另一条链表的其余元素复制到新链表中去。\n代码如下：")]),e._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",[l("code",[e._v("class Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n        if (l1 == NULL && l2 == NULL) {\n        return NULL;\n    } else if (! l1 && l2) {\n        return l2;\n    } else if (l1 && !l2) {\n        return l1;\n    } else {\n        ListNode *ptrToA = l1, *ptrToB = l2;\n        ListNode *cur = (ListNode *)malloc(sizeof(ListNode));\n        ListNode *head = cur;\n        while(ptrToA && ptrToB) {\n            while(ptrToA && ptrToB && (ptrToA->val < ptrToB->val)) {\n                ListNode *newCell = (ListNode *)malloc(sizeof(ListNode));\n                newCell->val = ptrToA->val;\n                cur->next = newCell;\n                cur = newCell;\n                ptrToA = ptrToA->next;\n            }\n            while(ptrToA && ptrToB && (ptrToA->val > ptrToB->val)) {\n                ListNode *newCell = (ListNode *)malloc(sizeof(ListNode));\n                newCell->val = ptrToB->val;\n                cur->next = newCell;\n                cur = newCell;\n                ptrToB = ptrToB->next;\n            }            \n            while(ptrToA && ptrToB && (ptrToA->val == ptrToB->val)) {\n                ListNode *newCellA = (ListNode *)malloc(sizeof(ListNode));\n                newCellA->val = ptrToA->val;\n                cur->next = newCellA;\n                cur = newCellA;\n                ListNode *newCellB = (ListNode *)malloc(sizeof(ListNode));\n                newCellB->val = ptrToB->val;\n                cur->next = newCellB;\n                cur = newCellB;\n                ptrToA = ptrToA->next;\n                ptrToB = ptrToB->next;\n            }\n        }\n        if(!ptrToA && ptrToB) {\n            while(ptrToB) {\n                ListNode *newCell = (ListNode *)malloc(sizeof(ListNode));\n                newCell->val = ptrToB->val;\n                cur->next = newCell;\n                cur = newCell;\n                ptrToB = ptrToB->next;\n            }\n            cur->next = NULL;\n        } else if(ptrToA && !ptrToB) {\n            while(ptrToA) {\n                ListNode *newCell = (ListNode *)malloc(sizeof(ListNode));\n                newCell->val = ptrToA->val;\n                cur->next = newCell;\n                cur = newCell;\n                ptrToA = ptrToA->next;\n            }\n            cur->next = NULL;\n        } else if (!ptrToA && !ptrToB ) {\n            cur->next = NULL;\n        }\n        return head->next;\n    }\n    }\n};\n")])])]),l("p",[l("strong",[e._v("Update")]),e._v(": 在讨论区中看到了这道题的另外两种解法，并且附上了很详细的分析，"),l("a",{attrs:{href:"https://leetcode.com/articles/merged-two-sorted-lists/",target:"_blank",rel:"noopener noreferrer"}},[e._v("传送门"),l("OutboundLink")],1),e._v("。相比于我自己的方法，下面的方法显得更加优美简单，并且在时间和空间复杂度上都更有优势。\n递归法：")]),e._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",[l("code",[e._v("class Solution {\npublic:\n    ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {\n        if (l1 == NULL) {\n            return l2;\n        } else if (l2 == NULL) {\n            return l1;\n        } else if (l1->val < l2->val) {\n            l1->next = mergeTwoLists(l1->next,l2);\n            return l1;\n        } else {\n            l2->next = mergeTwoLists(l1, l2->next);\n            return l2;\n        }\n    }\n};\n")])])]),l("p",[e._v("时间复杂度上，合并的总次数显然与L1和L2的长度有关，因此是O(m+n)；空间复杂度上，由于这是递归调用的，而第一次调用mergeTwoLists的返回条件是l1和l2均为NULL，也就是说返回时递归调用了"),l("code",[e._v("mergeTwoLists")]),e._v(" (m+n)次，所以空间复杂度也为O(m+n)。")]),e._v(" "),l("p",[e._v("迭代法：")]),e._v(" "),l("div",{staticClass:"language- line-numbers-mode"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[e._v("class Solution {\npublic:\n    ListNode * mergeTwoLists(ListNode *l1, ListNode *l2) {\n        ListNode *prehead = new ListNode(-1);\n        ListNode *prev = prehead;\n    \n        while(l1 != NULL && l2 != NULL) {\n            if (l1->val <= l2->val) {\n                prev->next = l1;\n                l1 = l1->next;\n            } else {\n                prev->next = l2;\n                l2 = l2->next;\n            }\n            prev = prev->next;\n        }\n    \n        prev->next = l1 == NULL ? l2:l1;\n        return prehead->next;\n    }\n};\n")])]),e._v(" "),l("div",{staticClass:"line-numbers-wrapper"},[l("span",{staticClass:"line-number"},[e._v("1")]),l("br"),l("span",{staticClass:"line-number"},[e._v("2")]),l("br"),l("span",{staticClass:"line-number"},[e._v("3")]),l("br"),l("span",{staticClass:"line-number"},[e._v("4")]),l("br"),l("span",{staticClass:"line-number"},[e._v("5")]),l("br"),l("span",{staticClass:"line-number"},[e._v("6")]),l("br"),l("span",{staticClass:"line-number"},[e._v("7")]),l("br"),l("span",{staticClass:"line-number"},[e._v("8")]),l("br"),l("span",{staticClass:"line-number"},[e._v("9")]),l("br"),l("span",{staticClass:"line-number"},[e._v("10")]),l("br"),l("span",{staticClass:"line-number"},[e._v("11")]),l("br"),l("span",{staticClass:"line-number"},[e._v("12")]),l("br"),l("span",{staticClass:"line-number"},[e._v("13")]),l("br"),l("span",{staticClass:"line-number"},[e._v("14")]),l("br"),l("span",{staticClass:"line-number"},[e._v("15")]),l("br"),l("span",{staticClass:"line-number"},[e._v("16")]),l("br"),l("span",{staticClass:"line-number"},[e._v("17")]),l("br"),l("span",{staticClass:"line-number"},[e._v("18")]),l("br"),l("span",{staticClass:"line-number"},[e._v("19")]),l("br"),l("span",{staticClass:"line-number"},[e._v("20")]),l("br"),l("span",{staticClass:"line-number"},[e._v("21")]),l("br")])]),l("p",[e._v("这种方法的时间复杂度仍为O(m+n)；由于只分配了两个额外的指针，因此空间复杂度为O(1)。")])])}),[],!1,null,null,null);n.default=s.exports}}]);