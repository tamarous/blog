(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{376:function(e,t,n){"use strict";n.r(t);var s=n(42),i=Object(s.a)({},(function(){var e=this.$createElement,t=this._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[t("h1",{attrs:{id:"leetcode-347-top-k-frequent-elements"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#leetcode-347-top-k-frequent-elements"}},[this._v("#")]),this._v(" LeetCode-347-Top K Frequent Elements")]),this._v(" "),t("p",[this._v("这道题的题意是：给出一个数组和一个数字k，返回一个由输入数组中出现次数排在前K位的元素组成的数组。\n思路：由题意，显然我们要将数组中的每个元素出现的次数记录下来，而这可以用哈希表来实现。在C++的标准库里，unordered_map是实现这一功能的库。于是我们可以先将每个元素出现的次数记录下来，然后把所有次数装进一个vector里面并排序。之后我们就可以从这个vector的末尾出发，去哈希表中找对应的键是什么，如果找到的话就把键加入到最终的结果数组中，直到遍历完vector的后K个元素。\n代码如下：")]),this._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("class Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        vector<int> result;\n        unordered_map<int,int> set;\n        for(int i = 0; i < nums.size(); i++) {\n            if (set.find(nums[i]) != set.end()) {\n                set[nums[i]] ++;\n            } else {\n                set.insert({nums[i],1});\n            }\n        }\n        vector<int> indexs;\n        for(auto &index: set) {\n            indexs.push_back(index.second);\n        }\n        sort(indexs.begin(), indexs.end());\n        size_t j = indexs.size();\n        for(int i = 0; i < k; i++) {\n            int x = indexs[j-1];\n            j--;\n            unordered_map<int,int>::iterator it = set.begin();\n            for(; it != set.end();it++) {\n                if (it->second == x) {\n                    result.push_back(it->first);\n                    set.erase(it);\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n};\n")])])])])}),[],!1,null,null,null);t.default=i.exports}}]);