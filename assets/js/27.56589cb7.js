(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{383:function(e,n,t){"use strict";t.r(n);var a=t(42),r=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"按层打印二叉树"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#按层打印二叉树"}},[e._v("#")]),e._v(" 按层打印二叉树")]),e._v(" "),t("p",[e._v("题意：给定一棵二叉树，将同一层上的节点打印在同一行上。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('class Solution {\npublic:\n    void printByLevel(TreeNode *head) {\n        if (head == NULL) {\n            return;\n        }\n        queue<TreeNode *> queue;\n        \n        // 当前层的节点个数\n        int current = 1;\n        queue.push(head);\n        // 下一层的节点个数\n        int next = 0;\n        \n        while(! queue.empty()) {\n            head = queue.front();\n            queue.pop();\n            current--;\n            printf("%d ",head->val);\n            if (head->left != NULL) {\n                queue.push(head->left);\n                next++;\n            }\n            if (head->right != NULL) {\n                queue.push(head->right);\n                next++;\n            }\n            if (current == 0) {\n                printf("\\n");\n                current = next;\n                next = 0;\n            }\n        }\n    }\n};\n')])])]),t("h2",{attrs:{id:"zigzag-打印二叉树"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#zigzag-打印二叉树"}},[e._v("#")]),e._v(" ZigZag 打印二叉树")]),e._v(" "),t("p",[e._v("代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('class Solution {\npublic:\n    void printZigZag(TreeNode *head) {\n        if (head == NULL) {\n            return NULL;\n        }\n        deque<TreeNode *> deque;\n        int level = 1;\n        bool lr = true;\n        TreeNode *last = head;\n        TreeNode *nLast = NULL;\n        deque.push_front(last);\n        printLevel(level++,last);\n        while(! deque.empty()) {\n            if (lr) {\n                head = deque.pop_front();\n                if (head->left != NULL) {\n                    nLast = nLast == NULL ? head->left : nLast;\n                    duque.push_back(head->left);\n                } \n                if (head->right != NULL) {\n                    nLast = nLast == NULL ? head->right: nLast;\n                    deque.push_back(head->right);\n                }\n            } else {\n                head = deque.pop_back();\n                if (head->right != NULL) {\n                    nLast = nLast == NULL ? head->right: nLast;\n                    deque.push_front(head->right);\n                }\n                if (head->left != NULL) {\n                    nLast = nLast == NULL? head->left: nLast;\n                    deque.push_front(head->left);\n                }\n            }\n            printf("%d ",head->val);\n            if (head == last && !deque.empty()) {\n                lr = !lr;\n                last = nLast;\n                nLast = NULL;\n                printf("\\n");\n                printLevel(level++,lr);\n            }   \n        }\n        printf("\\n");\n    }\n    \n    void printLevel(int level, bool lr) {\n        printf("level %d from ",level);\n        printf(lr?"left to right: ":"right to left: ");\n    }\n} \n')])])])])}),[],!1,null,null,null);n.default=r.exports}}]);