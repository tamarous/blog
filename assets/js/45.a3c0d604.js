(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{401:function(e,s,t){"use strict";t.r(s);var n=t(42),o=Object(n.a)({},(function(){var e=this,s=e.$createElement,t=e._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"aspects-源码分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aspects-源码分析"}},[e._v("#")]),e._v(" Aspects 源码分析")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://github.com/steipete/Aspects",target:"_blank",rel:"noopener noreferrer"}},[e._v("Aspects"),t("OutboundLink")],1),e._v("是一个用于实现面向切片编程（AOP, Aspect-oriented programming ）思想的第三方库。面向切片编程，指的是在运行时，动态地将代码切入到类的指定方法、指定位置上，从而得到改变方法的实现的目的。由于 Objective-C 本身是一门非常动态的语言，因此 AOP 在 Objective-C 这门语言中很容易利用 Runtime 进行实现。\n这个库里的代码不多，只有"),t("code",[e._v("Aspects.h")]),e._v("和"),t("code",[e._v("Aspects.m")]),e._v("两个文件。头文件里定义了一个 NSObject 的分类，给所有 NSObject 的子类添加了如下两个方法：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("+ (id<AspectToken>)aspect_hookSelector:(SEL)selector\n                           withOptions:(AspectOptions)options\n                            usingBlock:(id)block\n                                 error:(NSError **)error;\n\n/// Adds a block of code before/instead/after the current `selector` for a specific instance.\n- (id<AspectToken>)aspect_hookSelector:(SEL)selector\n                           withOptions:(AspectOptions)options\n                            usingBlock:(id)block\n                                 error:(NSError **)error;\n")])])]),t("p",[e._v("第一个是类方法，而另一个是实例方法，其实内部都调用了同样的方法，只不过传给那个方法的参数稍微有些区别。\n下面我们就结合着"),t("code",[e._v("Aspects")]),e._v("给出的一个 Demo 来分析它的内部做了什么事情。Demo 的核心代码是下面这么一段，也就是当我们点击 button 后，会出现照片选取的 "),t("code",[e._v("UIImagePickerController")]),e._v("，而在"),t("code",[e._v("UIImagePickerController")]),e._v("的"),t("code",[e._v("viewWillDisappear")]),e._v("方法被调用时，程序此时就会调用我们设置的钩子函数，显示一个 UIAlertView。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('- (IBAction)buttonPressed:(id)sender {\n    UIViewController *testController = [[UIImagePickerController alloc] init];\n\n    testController.modalPresentationStyle = UIModalPresentationFormSheet;\n    [self presentViewController:testController animated:YES completion:NULL];\n\n    // We are interested in being notified when the controller is being dismissed.\n    [testController aspect_hookSelector:@selector(viewWillDisappear:) withOptions:0 usingBlock:^(id<AspectInfo> info, BOOL animated) {\n        UIViewController *controller = [info instance];\n        if (controller.isBeingDismissed || controller.isMovingFromParentViewController) {\n            [[[UIAlertView alloc] initWithTitle:@"Popped" message:@"Hello from Aspects" delegate:nil cancelButtonTitle:nil otherButtonTitles:@"Ok", nil] show];\n        }\n    } error:NULL];\n\n    // Hooking dealloc is delicate, only AspectPositionBefore will work here.\n    [testController aspect_hookSelector:NSSelectorFromString(@"dealloc") withOptions:AspectPositionBefore usingBlock:^(id<AspectInfo> info) {\n        NSLog(@"Controller is about to be deallocated: %@", [info instance]);\n    } error:NULL];\n}\n')])])]),t("p",[t("code",[e._v("testController")]),e._v(" Hook 了两个"),t("code",[e._v("viewWillDisappear:")]),e._v("和"),t("code",[e._v("dealloc")]),e._v("这两个方法。options 指定了 Hook 的时机，可以在指定的时机执行 block 内的方法：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("typedef NS_OPTIONS(NSUInteger, AspectOptions) {\n    AspectPositionAfter   = 0,            /// 在原始方法执行后生效（默认）        \n    AspectPositionInstead = 1,            /// 替换原始方法\n    AspectPositionBefore  = 2,            /// 在原始方法执行前生效\n    AspectOptionAutomaticRemoval = 1 << 3 /// 只执行一次\n};\n")])])]),t("p",[e._v("所以 "),t("code",[e._v("testController")]),e._v("会在"),t("code",[e._v("viewWillDisappear")]),e._v("调用后以及"),t("code",[e._v("dealloc")]),e._v("调用前执行block 中的方法。\n下面我们看下 hook 这个方法究竟做了什么。进入")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("- (id<AspectToken>)aspect_hookSelector:(SEL)selector\n                      withOptions:(AspectOptions)options\n                       usingBlock:(id)block\n                            error:(NSError **)error {\n    return aspect_add(self, selector, options, block, error);\n}\n")])])]),t("p",[e._v("其实它调用了 "),t("code",[e._v("aspect_add")]),e._v(" 这个静态函数：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("static id aspect_add(id self, SEL selector, AspectOptions options, id block, NSError **error) {\n    NSCParameterAssert(self);\n    NSCParameterAssert(selector);\n    NSCParameterAssert(block);\n\n    __block AspectIdentifier *identifier = nil;\n    \n    // 1. 在执行 block 前加锁，在执行完 block 后解锁\n    aspect_performLocked(^{\n    \n        // 2. \n        if (aspect_isSelectorAllowedAndTrack(self, selector, options, error)) {\n            // 3\n            AspectsContainer *aspectContainer = aspect_getContainerForObject(self, selector);\n            // 4. \n            identifier = [AspectIdentifier identifierWithSelector:selector object:self options:options block:block error:error];\n            if (identifier) {\n                // 5. \n                [aspectContainer addAspect:identifier withOptions:options];\n\n                // 6.  \n                // Modify the class to allow message interception.\n                aspect_prepareClassAndHookSelector(self, selector, error);\n            }\n        }\n    });\n    return identifier;\n}\n")])])]),t("p",[e._v("第1步，"),t("code",[e._v("aspect_performLocked")]),e._v("这个方法在执行作为参数的 block 前会进行加锁操作，而在 block 执行完后进行解锁：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("static void aspect_performLocked(dispatch_block_t block) {\n    static OSSpinLock aspect_lock = OS_SPINLOCK_INIT;\n    OSSpinLockLock(&aspect_lock);\n    block();\n    OSSpinLockUnlock(&aspect_lock);\n}\n")])])]),t("p",[e._v("第2步中调用了"),t("code",[e._v("aspect_isSelectorAllowedAndTrack(self, selector, options, error)")]),e._v("这个方法：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('static BOOL aspect_isSelectorAllowedAndTrack(NSObject *self, SEL selector, AspectOptions options, NSError **error) {\n\n    // `retain`，`release`，`autorelease`和`forwardInvocation`都是不允许被 hook ，它们会被加入黑名单中\n    static NSSet *disallowedSelectorList;\n    static dispatch_once_t pred;\n    dispatch_once(&pred, ^{\n        disallowedSelectorList = [NSSet setWithObjects:@"retain", @"release", @"autorelease", @"forwardInvocation:", nil];\n    });\n\n    // 如果要 Hook 的方法是以上黑名单中的四个方法中的一个，会打印出错误信息并且返回 NO\n    NSString *selectorName = NSStringFromSelector(selector);\n    if ([disallowedSelectorList containsObject:selectorName]) {\n        NSString *errorDescription = [NSString stringWithFormat:@"Selector %@ is blacklisted.", selectorName];\n        AspectError(AspectErrorSelectorBlacklisted, errorDescription);\n        return NO;\n    }\n\n    // 如果 Hook 的是 dealloc 方法，并且 Hook 时机不是在 dealloc 方法执行之前，也会打印出错误信息，并且返回 NO\n    AspectOptions position = options&AspectPositionFilter;\n    if ([selectorName isEqualToString:@"dealloc"] && position != AspectPositionBefore) {\n        NSString *errorDesc = @"AspectPositionBefore is the only valid position when hooking dealloc.";\n        AspectError(AspectErrorSelectorDeallocPosition, errorDesc);\n        return NO;\n    }\n \n // 如果被 Hook 的类本身不能响应被 Hook 的方法，那么这里也会报错并且返回 NO\n    if (![self respondsToSelector:selector] && ![self.class instancesRespondToSelector:selector]) {\n        NSString *errorDesc = [NSString stringWithFormat:@"Unable to find selector -[%@ %@].", NSStringFromClass(self.class), selectorName];\n        AspectError(AspectErrorDoesNotRespondToSelector, errorDesc);\n        return NO;\n    }\n\n    // Search for the current class and the class hierarchy IF we are modifying a class object\n    \n    if (class_isMetaClass(object_getClass(self))) {\n        // 如果 self 所属的类是一个元类\n    \n        Class klass = [self class];\n        \n        // aspect_getSwizzledClassesDict会返回一个全局唯一的`swizzledClassesDict`，以 Class 为键，以`AspectTracker`实例为值，下文中会介绍这个 dictionary 内的键值对是怎么添加的\n        NSMutableDictionary *swizzledClassesDict = aspect_getSwizzledClassesDict();\n        Class currentClass = [self class];\n\n        AspectTracker *tracker = swizzledClassesDict[currentClass];\n        if ([tracker subclassHasHookedSelectorName:selectorName]) {\n            // 如果self 所属类的子类已经 Hook 了 selectorName 代表的 SEL，那么在这里就会打印出错误信息并且返回 NO\n            NSSet *subclassTracker = [tracker subclassTrackersHookingSelectorName:selectorName];\n            NSSet *subclassNames = [subclassTracker valueForKey:@"trackedClassName"];\n            NSString *errorDescription = [NSString stringWithFormat:@"Error: %@ already hooked subclasses: %@. A method can only be hooked once per class hierarchy.", selectorName, subclassNames];\n            AspectError(AspectErrorSelectorAlreadyHookedInClassHierarchy, errorDescription);\n            return NO;\n        }\n\n        // 从 self 所属类的继承链上进行查找\n        do {\n            tracker = swizzledClassesDict[currentClass];\n            // 如果继承链上的某个类的被交换的方法列表中有当前这个 SEL\n            if ([tracker.selectorNames containsObject:selectorName]) {\n            \n                // 继承链上的这个类就是被 Hook 的那个类，说明之前已经 Hook 过它了，因此这里直接返回 YES\n                if (klass == currentClass) {\n                    // Already modified and topmost!\n                    return YES;\n                }\n                \n                // 继承链上的这个类不是被 Hook 的那个类，而是它的父类，那么这个方法已经被 Hook 过了，我们就不能再次进行 Hook 了，所以这里需要打印出一条错误信息，并且返回 NO\n                NSString *errorDescription = [NSString stringWithFormat:@"Error: %@ already hooked in %@. A method can only be hooked once per class hierarchy.", selectorName, NSStringFromClass(currentClass)];\n                AspectError(AspectErrorSelectorAlreadyHookedInClassHierarchy, errorDescription);\n                return NO;\n            }\n        } while ((currentClass = class_getSuperclass(currentClass)));\n\n        // Add the selector as being modified.\n        currentClass = klass;\n        AspectTracker *subclassTracker = nil;\n        do {\n            tracker = swizzledClassesDict[currentClass];\n            if (!tracker) {\n                // 为 self 所属的这个类创建对应的 AspectTracker\n                tracker = [[AspectTracker alloc] initWithTrackedClass:currentClass];\n                \n                // 以 self 所属的类为键，以tracker 为值，添加到swizzledClassesDict中\n                swizzledClassesDict[(id<NSCopying>)currentClass] = tracker;\n            }\n            if (subclassTracker) {\n                [tracker addSubclassTracker:subclassTracker hookingSelectorName:selectorName];\n            } else {\n                [tracker.selectorNames addObject:selectorName];\n            }\n\n            // All superclasses get marked as having a subclass that is modified.\n            subclassTracker = tracker;\n        }while ((currentClass = class_getSuperclass(currentClass)));\n\t} else {\n\t\n\t   // 如果 self 所属的类不是元类，那么直接返回 YES\n\t\treturn YES;\n\t}\n\n    return YES;\n}\n')])])]),t("p",[e._v("第3步，我们以self 和 selector 为参数，调用"),t("code",[e._v("aspect_getContainerForObject")]),e._v("函数，返回一个"),t("code",[e._v("AspectsContainer")]),e._v("：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("AspectsContainer *aspectContainer = aspect_getContainerForObject(self, selector);\n\nstatic AspectsContainer *aspect_getContainerForObject(NSObject *self, SEL selector) {\n    NSCParameterAssert(self);\n    SEL aliasSelector = aspect_aliasForSelector(selector);\n    AspectsContainer *aspectContainer = objc_getAssociatedObject(self, aliasSelector);\n    if (!aspectContainer) {\n        aspectContainer = [AspectsContainer new];\n        objc_setAssociatedObject(self, aliasSelector, aspectContainer, OBJC_ASSOCIATION_RETAIN);\n    }\n    return aspectContainer;\n}\n")])])]),t("p",[e._v("AspectsContainer 和 SEL 是通过关联对象技术关联在一起的，因此这个方法里就是通过 SEL 取出对应的 AspectsContainer 实例。\n第4步是创建出一个"),t("code",[e._v("AspectsIdentifier")]),e._v("实例：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("+ (instancetype)identifierWithSelector:(SEL)selector object:(id)object options:(AspectOptions)options block:(id)block error:(NSError **)error {\n    NSCParameterAssert(block);\n    NSCParameterAssert(selector);\n    NSMethodSignature *blockSignature = aspect_blockMethodSignature(block, error); // TODO: check signature compatibility, etc.\n    if (!aspect_isCompatibleBlockSignature(blockSignature, object, selector, error)) {\n        return nil;\n    }\n\n    AspectIdentifier *identifier = nil;\n    if (blockSignature) {\n        identifier = [AspectIdentifier new];\n        identifier.selector = selector;\n        identifier.block = block;\n        identifier.blockSignature = blockSignature;\n        identifier.options = options;\n        identifier.object = object; // weak\n    }\n    return identifier;\n}\n")])])]),t("p",[e._v("第5步是将上一步中创建的"),t("code",[e._v("AspectIdentifier")]),e._v("实例添加到第3步创建的"),t("code",[e._v("AspectsContainer")]),e._v("中：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("- (void)addAspect:(AspectIdentifier *)aspect withOptions:(AspectOptions)options {\n    NSParameterAssert(aspect);\n    NSUInteger position = options&AspectPositionFilter;\n    \n    // 根据options的设置，AspectIdentifier实例会被添加到AspectsContainer对应的数组里\n    switch (position) {\n        case AspectPositionBefore:  self.beforeAspects  = [(self.beforeAspects ?:@[]) arrayByAddingObject:aspect]; break;\n        case AspectPositionInstead: self.insteadAspects = [(self.insteadAspects?:@[]) arrayByAddingObject:aspect]; break;\n        case AspectPositionAfter:   self.afterAspects   = [(self.afterAspects  ?:@[]) arrayByAddingObject:aspect]; break;\n    }\n}\n")])])]),t("p",[e._v("第6步是整个方法 Hook 的核心：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('aspect_prepareClassAndHookSelector(self, selector, error);\n\nstatic void aspect_prepareClassAndHookSelector(NSObject *self, SEL selector, NSError **error) {\n    NSCParameterAssert(selector);\n    \n    // (1)\n    Class klass = aspect_hookClass(self, error);\n    Method targetMethod = class_getInstanceMethod(klass, selector);\n    IMP targetMethodIMP = method_getImplementation(targetMethod);\n    \n    // (2)\n    if (!aspect_isMsgForwardIMP(targetMethodIMP)) {\n        // Make a method alias for the existing method implementation, it not already copied.\n        const char *typeEncoding = method_getTypeEncoding(targetMethod);\n        \n        // (3)\n        SEL aliasSelector = aspect_aliasForSelector(selector);\n        if (![klass instancesRespondToSelector:aliasSelector]) {\n            // 如果第(1)步中创建出来的类不能响应第(3)步中新创建的 SEL，那么就通过class_addMethod 来给新创建出来的类添加一个方法，这个方法的 SEL 就是新创建的 SEL，IMP 和类型编码则是要被替换的方法的 IMP 和类型编码\n            __unused BOOL addedAlias = class_addMethod(klass, aliasSelector, method_getImplementation(targetMethod), typeEncoding);\n            NSCAssert(addedAlias, @"Original implementation for %@ is already copied to %@ on %@", NSStringFromSelector(selector), NSStringFromSelector(aliasSelector), klass);\n        }\n\n        // We use forwardInvocation to hook in.\n        // (4)\n        class_replaceMethod(klass, selector, aspect_getMsgForwardIMP(self, selector), typeEncoding);\n        AspectLog(@"Aspects: Installed hook for -[%@ %@].", klass, NSStringFromSelector(selector));\n    }\n}\n')])])]),t("p",[e._v("这个方法也比较复杂，因此我们将它分成四个小步骤来分析。\n第(1)步，调用"),t("code",[e._v("aspect_hookClass")]),e._v("：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('static Class aspect_hookClass(NSObject *self, NSError **error) {\n    NSCParameterAssert(self);\n    \n   // 这里是比较容易混淆的地方\n   // .class 方法，当 self 是一个 instance 的时候，返回 self 的类对象;\n   // 当 self 是一个类对象的时候，返回它自身\n   // object_getClass 方法则是获取 self 的 isa 指针指向的对象，如果self 是一个\n   // instance，那么返回一个类对象;如果 self 是一个类对象，则返回一个元类\n\n    \n\tClass statedClass = self.class;\n\tClass baseClass = object_getClass(self);\n\tNSString *className = NSStringFromClass(baseClass);\n\n    // Already subclassed\n    \n\tif ([className hasSuffix:AspectsSubclassSuffix]) {\n\t   // AspectsSubclassSuffix是个 static 字符串常量，也就是_Aspects_\n\t\treturn baseClass;\n\n        // We swizzle a class object, not a single object.\n\t}else if (class_isMetaClass(baseClass)) {\n        return aspect_swizzleClassInPlace((Class)self);\n        // Probably a KVO\'ed class. Swizzle in place. Also swizzle meta classes in place.\n    }else if (statedClass != baseClass) {\n        return aspect_swizzleClassInPlace(baseClass);\n    }\n\n    // Default case. Create dynamic subclass.\n    // 在原来的类名后加上_Aspects_后缀\n\tconst char *subclassName = [className stringByAppendingString:AspectsSubclassSuffix].UTF8String;\n\tClass subclass = objc_getClass(subclassName);\n\n\tif (subclass == nil) {\n\t   // 创建出一个新的 Class 出来，基本步骤有下面几个：\n\t   // 1. 通过objc_allocateClassPair来创建一个新的子类\n\t   // 2. 通过class_addMethod, class_addIvar来向新的子类添加方法和实例变量\n\t   // 3. 通过objc_registerClassPair来向运行时系统注册这个新类\n\t   // 完成以上3步后就可以使用这个新建的类了\n\t   \n\t   // subclass是 baseClass 的子类，类名是subclassName\n\t\tsubclass = objc_allocateClassPair(baseClass, subclassName, 0);\n\t\tif (subclass == nil) {\n            NSString *errrorDesc = [NSString stringWithFormat:@"objc_allocateClassPair failed to allocate class %s.", subclassName];\n            AspectError(AspectErrorFailedToAllocateClassPair, errrorDesc);\n            return nil;\n        }\n    \n      // 将新创建出来的类的forwardInvocation:方法替换成__ASPECTS_ARE_BEING_CALLED__方法，详见下面的注释\n\t\taspect_swizzleForwardInvocation(subclass);\n\t\t// 替换subclass 的class 方法\n\t\taspect_hookedGetClass(subclass, statedClass);\n\t\t// 替换subclass 的元类的class 方法\n\t\taspect_hookedGetClass(object_getClass(subclass), statedClass);\n\t\t// 注册新创建出来的子类，现在可以使用了\n\t\tobjc_registerClassPair(subclass);\n\t}\n\n    // 将 self 所属类的类型改为我们刚刚创建出来的带有_Aspects_后缀的类\n    // 这里可以通过在 Xcode 中打断点来进行验证\n\tobject_setClass(self, subclass);\n\t// 返回这个子类\n\treturn subclass;\n}\n\nstatic void aspect_swizzleForwardInvocation(Class klass) {\n    NSCParameterAssert(klass);\n    \n    // class_replaceMethod的第一个参数是要进行方法替换的 Class，第二个参数是被替换方法的 SEL，第三个参数是进行替换的方法的 IMP，第四个参数是类型编码，返回值是被替换的方法原来的 IMP。\n    // 如果 Class 中没有要被替换的SEL，那么这个方法和class_addMethod 就是一样的\n    IMP originalImplementation = class_replaceMethod(klass, @selector(forwardInvocation:), (IMP)__ASPECTS_ARE_BEING_CALLED__, "v@:@");\n    if (originalImplementation) {\n        // 向 Class 中添加一个新的方法AspectsForwardInvocationSelectorName，也就是__aspects_forwardInvocation:，而它的IMP就是原来的forwardInvocation:的 IMP\n        class_addMethod(klass, NSSelectorFromString(AspectsForwardInvocationSelectorName), originalImplementation, "v@:@");\n    }\n    AspectLog(@"Aspects: %@ is now aspect aware.", NSStringFromClass(klass));\n}\n\nstatic void aspect_hookedGetClass(Class class, Class statedClass) {\n    NSCParameterAssert(class);\n    NSCParameterAssert(statedClass);\n    \n   // 获得class 原来的 class 方法\n\tMethod method = class_getInstanceMethod(class, @selector(class));\n\t// 创建一个新的 IMP\n\tIMP newIMP = imp_implementationWithBlock(^(id self) {\n\t\treturn statedClass;\n\t});\n\t// 将class 的实现用我们新创建的 IMP 来替换\n\tclass_replaceMethod(class, @selector(class), newIMP, method_getTypeEncoding(method));\n}\n')])])]),t("p",[e._v("第(2)步，调用了"),t("code",[e._v("aspect_isMsgForwardIMP")]),e._v("来判断我们要替换的 SEL 的 IMP 是不是"),t("code",[e._v("_objc_msgForward")]),e._v("，如果不是才会进行第(3)、(4)步的操作")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("static BOOL aspect_isMsgForwardIMP(IMP impl) {\n    return impl == _objc_msgForward\n#if !defined(__arm64__)\n    || impl == (IMP)_objc_msgForward_stret\n#endif\n    ;\n}\n")])])]),t("p",[e._v("第(3)步，创建出一个新的 SEL，这个新的 SEL 是由被替换的 SEL 的字符串加上一个特定前缀字符串生成的，然后将它添加到上面新创建的类中：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('static SEL aspect_aliasForSelector(SEL selector) {\n    NSCParameterAssert(selector);\n\treturn NSSelectorFromString([AspectsMessagePrefix stringByAppendingFormat:@"_%@", NSStringFromSelector(selector)]);\n}\n')])])]),t("p",[e._v("第(4)步，将selector 对应的实现 IMP 替换为"),t("code",[e._v("_objc_msgForward")]),e._v("：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("class_replaceMethod(klass, selector, aspect_getMsgForwardIMP(self, selector), typeEncoding);\n\nstatic IMP aspect_getMsgForwardIMP(NSObject *self, SEL selector) {\n    IMP msgForwardIMP = _objc_msgForward;\n#if !defined(__arm64__)\n    // As an ugly internal runtime implementation detail in the 32bit runtime, we need to determine of the method we hook returns a struct or anything larger than id.\n    // https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/LowLevelABI/000-Introduction/introduction.html\n    // https://github.com/ReactiveCocoa/ReactiveCocoa/issues/783\n    // http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042e/IHI0042E_aapcs.pdf (Section 5.4)\n    Method method = class_getInstanceMethod(self.class, selector);\n    const char *encoding = method_getTypeEncoding(method);\n    BOOL methodReturnsStructValue = encoding[0] == _C_STRUCT_B;\n    if (methodReturnsStructValue) {\n        @try {\n            NSUInteger valueSize = 0;\n            NSGetSizeAndAlignment(encoding, &valueSize, NULL);\n\n            if (valueSize == 1 || valueSize == 2 || valueSize == 4 || valueSize == 8) {\n                methodReturnsStructValue = NO;\n            }\n        } @catch (__unused NSException *e) {}\n    }\n    if (methodReturnsStructValue) {\n        msgForwardIMP = (IMP)_objc_msgForward_stret;\n    }\n#endif\n    return msgForwardIMP;\n}\n")])])]),t("p",[e._v("所以我们可以总结下第6步这个方法做了什么事情：\n(1) 创建了一个新的类，然后将这个新类的"),t("code",[e._v("forwardInvocation:")]),e._v(" 实现替换为了"),t("code",[e._v("__ASPECTS_ARE_BEING_CALLED__")]),e._v("，并且将这个新类的类对象和元类的 class 修改为原来的类，最后将 self 所属的类修改为新类。\n(2) 将 selector 对应的 IMP 实现替换为"),t("code",[e._v("forwardInvocation:")]),e._v("。\n以上介绍的1~6步，完成了 Hook 的动作。那么在被 Hook 的对象执行被替换的方法时，运行时就会转而执行"),t("code",[e._v("__ASPECTS_ARE_BEING_CALLED__")]),e._v("这个方法。接下来我们看下这个方法里有什么奥秘。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("static void __ASPECTS_ARE_BEING_CALLED__(__unsafe_unretained NSObject *self, SEL selector, NSInvocation *invocation) {\n    NSCParameterAssert(self);\n    NSCParameterAssert(invocation);\n    SEL originalSelector = invocation.selector;\n    // 给invocation.selector 的 name 添加了aspects_前缀\n\tSEL aliasSelector = aspect_aliasForSelector(invocation.selector);\n\t\n    invocation.selector = aliasSelector;\n    \n    // AspectsContainer 和 SEL 是在第3步中通过关联对象技术关联到一起的\n    AspectsContainer *objectContainer = objc_getAssociatedObject(self, aliasSelector);\n    AspectsContainer *classContainer = aspect_getContainerForClass(object_getClass(self), aliasSelector);\n    AspectInfo *info = [[AspectInfo alloc] initWithInstance:self invocation:invocation];\n    NSArray *aspectsToRemove = nil;\n\n    // 在第5步中，根据options的设置，AspectIdentifier 会被加入到container 的beforeAspects、insteadAspects或afterAspects中\n    \n    \n    // Before hooks.\n    // 先执行 Hook 时机为调用原方法之前的方法\n    aspect_invoke(classContainer.beforeAspects, info);\n    aspect_invoke(objectContainer.beforeAspects, info);\n\n    // Instead hooks.\n    BOOL respondsToAlias = YES;\n    if (objectContainer.insteadAspects.count || classContainer.insteadAspects.count) {\n    \n        //如果 option 为替代原方法，那么这里执行替代方法，原方法不执行\n        aspect_invoke(classContainer.insteadAspects, info);\n        aspect_invoke(objectContainer.insteadAspects, info);\n    }else {\n    \n        // 如果 option 不是替代原方法，那么在这里去执行原来的方法\n        Class klass = object_getClass(invocation.target);\n        do {\n            // 我们在第6步的第(3)步中向新创建出的类通过class_addMethod添加了aliasSelector\n            if ((respondsToAlias = [klass instancesRespondToSelector:aliasSelector])) {\n                [invocation invoke];\n                break;\n            }\n        }while (!respondsToAlias && (klass = class_getSuperclass(klass)));\n    }\n\n    // After hooks.\n    // 原方法已经执行完了，在这里执行 Hook 时机为调用原方法之后的方法\n    aspect_invoke(classContainer.afterAspects, info);\n    aspect_invoke(objectContainer.afterAspects, info);\n\n    // If no hooks are installed, call original implementation (usually to throw an exception)\n    // 如果没有安装任何钩子函数（也就是没有进行方法 Hook），那么就调用原来的方法\n    if (!respondsToAlias) {\n        invocation.selector = originalSelector;\n        SEL originalForwardInvocationSEL = NSSelectorFromString(AspectsForwardInvocationSelectorName);\n        if ([self respondsToSelector:originalForwardInvocationSEL]) {\n            ((void( *)(id, SEL, NSInvocation *))objc_msgSend)(self, originalForwardInvocationSEL, invocation);\n        }else {\n            [self doesNotRecognizeSelector:invocation.selector];\n        }\n    }\n\n    // Remove any hooks that are queued for deregistration.\n    [aspectsToRemove makeObjectsPerformSelector:@selector(remove)];\n}\n")])])]),t("p",[e._v("所以这个方法的作用就是根据 option 的设置，在合适的时机调用原来的方法实现以及我们的钩子函数。\n以上就是 Aspects这个库进行方法 Hook 的基本原理了。")])])}),[],!1,null,null,null);s.default=o.exports}}]);