"use strict";(self.webpackChunktamarous_blog=self.webpackChunktamarous_blog||[]).push([[6611],{4332:(i,s,a)=>{a.r(s),a.d(s,{comp:()=>l,data:()=>t});var e=a(641);const n={},l=(0,a(6262).A)(n,[["render",function(i,s){const a=(0,e.g2)("Mermaid"),n=(0,e.g2)("RouteLink");return(0,e.uX)(),(0,e.CE)("div",null,[s[3]||(s[3]=(0,e.Fv)('<h1 id="react-native-新架构学习" tabindex="-1"><a class="header-anchor" href="#react-native-新架构学习"><span>React Native 新架构学习</span></a></h1><h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h2><p>React Native 是一个用于构建跨平台移动应用的开源框架，它允许开发者使用 JavaScript 和 React 语法来编写应用，然后将其编译为原生平台的代码，如 iOS 和 Android。随着移动应用复杂度的不断提升，React Native 的架构设计也在不断演进。在 0.68 版本中，React Native 团队引入了全新的架构设计，从根本上解决了旧架构中的性能瓶颈，并带来了诸多创新特性。本文将深入探讨 React Native 新架构的设计理念和实现原理，帮助开发者更好地理解和应用这一重要升级。</p><h2 id="react-native-旧架构解析" tabindex="-1"><a class="header-anchor" href="#react-native-旧架构解析"><span>React Native 旧架构解析</span></a></h2><p>在介绍新架构之前，自然需要先了解下什么是 React Native 的旧架构，它有哪些问题，这样才能理解为什么需要引入新架构。</p><p>React Native 旧架构采用分层设计，实现了 JavaScript 代码在原生平台上的运行。旧架构包含三个主要部分：JavaScript 引擎、Bridge 通信层和原生渲染引擎。</p>',6)),(0,e.bF)(a,{id:"mermaid-18",code:"eJyFVEFvEkEUvvdXTNL0JjGFIJaDB9QDpJhYysFsPAzsLKxudsnuUtRwqNKYGi2Y0IJaFUlswglbbSotrfwZZrb8C3dnltndSmUvu/Pm+773vfdmVlK0Sr4IdROsri0A+1laAuTbAI9qpNfFX9o0ZpRzBR2WiiCVwed7pFkXUnADZvK6XDIBi4CQvWmdjaze28eU4zyirKO8KWsqWE/wYCpzV9ORT8FZepw1BPM0JNAv14y3z+ggFLrjQekmUsWFoNuELosFJLAXmGx+Go+6+OjVHH9pZBiwgB6WURkJ5GSbvPwx+dDB222Pl0G6DBX5BXS4Aj5r2Lv4XesmbuzwhYdOQDNfdL2QN6f4+5b1/jXpHpD6gQfyZ6XFBXLMzkxxPvVr2vDABm8gAdc71m6HDH6STpPNbE4juECmCEWtIrAXuDpkaoturesITVHOdxCzCp9rZfO+WpBVJDzSChDgQQ0fbV71EtSjNfqpHOcU+o/VbFIYD4azLGaTaajaHdaFbBJY/a49A/yxF8SwTqU1sawgY9oweg1m4excDGJrA2u4NR6eeDC/O56aDZbXxgH++ihmmiA4UedqUjeT9jE7zTTMr4FDrdpeyP4xaR36bmQ1cLxmkJjs5WHN2u39n+c7bjxdc2d88dmm8c5XvZJnkkjrlPza4+l8vMAEKDcQoWy8/9WmBmz6L4H3F/uNzxuX/T/WRZ/G8go0jHtIAk8Mt9WSrCjxRRSRwpJ4wzB17SmKLy6vxG6JYXcZqsiiWYyHS8+CEjlWDBOQIigqRblALLcswXkCKi1r6uC2FEUrXCCMYmLkGgFPhf+MeT2+PbfZzKYvzrrpZl/4CzaYNE4="}),s[4]||(s[4]=(0,e.Fv)('<h3 id="javascript-引擎" tabindex="-1"><a class="header-anchor" href="#javascript-引擎"><span>JavaScript 引擎</span></a></h3><p>JavaScript 引擎负责执行 React 组件代码和业务逻辑。在 iOS 平台使用系统自带的 JavaScriptCore，Android 平台使用打包的 JSC 静态库。这确保了 JavaScript 代码在不同平台上的执行一致性。</p><h3 id="bridge-通信层" tabindex="-1"><a class="header-anchor" href="#bridge-通信层"><span>Bridge 通信层</span></a></h3><p>Bridge 通信层负责 JavaScript 和原生代码之间的数据传输，主要通过以下步骤实现：</p><ol><li>JavaScript 代码调用 UI 更新或原生功能时，将调用放入消息队列</li><li>将消息队列中的调用序列化为 JSON 字符串</li><li>通过 Bridge 将序列化后的消息发送到原生端</li><li>原生代码接收消息并反序列化</li><li>执行对应操作，必要时将结果返回给 JavaScript 端</li></ol><h3 id="原生渲染引擎" tabindex="-1"><a class="header-anchor" href="#原生渲染引擎"><span>原生渲染引擎</span></a></h3><p>原生渲染引擎将 JavaScript 端的 UI 结构转换为原生界面。它使用 Shadow Tree 作为中间层，负责协调 JavaScript 端的视图更新和原生 UI 组件的渲染。</p><h3 id="旧架构的性能问题" tabindex="-1"><a class="header-anchor" href="#旧架构的性能问题"><span>旧架构的性能问题</span></a></h3><p>随着应用复杂度的不断提升，React Native 旧架构的性能瓶颈逐渐显现。首先，Bridge 通信机制的设计导致了严重的性能开销。每次 JavaScript 和原生代码之间的通信都需要经过序列化和反序列化的过程，而且消息队列采用串行处理方式，无法支持并发操作，这在数据量较大时会造成明显的性能下降。</p><p>其次，旧架构的多线程模型也带来了显著的性能损耗。应用在运行过程中需要在 JavaScript 线程、UI 线程和原生模块线程之间频繁切换，这种频繁的线程切换在复杂的交互场景下会引起明显的界面卡顿，影响用户体验。</p><p>最后，布局计算也会带来效率问题。旧架构使用 Yoga 引擎进行布局计算，JavaScript 层和原生层之间需要频繁同步布局信息。这个过程不仅计算量大，而且同步操作本身也会消耗大量时间，从而影响整体渲染性能。</p><p>这些性能问题促使 React Native 团队推出了新的架构。</p><h2 id="react-native-新架构解析" tabindex="-1"><a class="header-anchor" href="#react-native-新架构解析"><span>React Native 新架构解析</span></a></h2><p>React Native 新架构在 0.68 版本引入，它解决了旧架构的性能问题，同时也引入了一些新的特性和优化。</p><h3 id="关键模块" tabindex="-1"><a class="header-anchor" href="#关键模块"><span>关键模块</span></a></h3>',15)),(0,e.bF)(a,{id:"mermaid-88",code:"eJyNVE1P2zAYvvMrIk3chgTtugKHHeg0PqRuE1Rcoh3cxG7DSlI5KQypl4HGxqigE2wIxloqhuiF7oNpYyuwP4OT7F/MsZ0mgVVdcohjP8/zvs/r10YFY1HJA2xJmbE+iT79/ZJ9cEZ+r9jNBvmww+bMUjaHQTEvTc1MylNgAcwoWCta0qRuQYyAAp8wmPeoGoaKpRm6r+c9lDaGNTUHZTqS+DCgTBim9Sg7R2mm7I0l8RMgOnxpYOBeGM8QUFf7omk+AFmsKTL/SPbZV7u+5Zy2nXa9R6LTVAtiiGXOIbvNgJA2Srql6bk00EHOg1SW3YsLp9VwqqsR4EweqMZiBkMo86HkjYN1Pwgzc021WzSGDYS7+M6UcNZIG2qpAE05/CP9l3sOnoY5zbTwkswbwD5tktWK2wgZfAgsbQH6cchG3dmuc3C4WmEtln6E1sVBylBhDuryVfvQOXju6b6q9sj6McAm3Q7nS5vU1t3jQ7tWjWzHONQhBpaBI6IRSGapCO9DZAoR0tq7+rkWLPMIzENH7AaXLXNkF28TEM/TevGPRM7f2lsbPbzNpmV3d89er9v7vwJoypgvagXqmZzsuK+XPU/n79xPb6K2UzKprZD9S/K+Zm9/j6zNplm2vs71+fFU1IF3JbDt/bPzjbw4pb3Epr2zTOFlUq3YJ0fu5xVnu1mO9GAExo+UXXl51f5YFkeUAcSeMxDfHHvjiGwelj1qNwTL5x/RRHVZwLVjt1GhIlwouN1+kPNNt3XpXLTYnFIApkm3UFIhAqWCJSGtUBi9hUa89zZtX+MpHL0Vj8fFeGBRU638aKz4LEqfMzVBhXEUQ2qHOjSSvKvGerARv6xE7DhMoERHIJkdQqCXgOWVwk9gGCVgkHsMJtV4L74iiiwyQDSHwY4CSiSVQf+3m0Ke114IKPAOVDoCSmxoOJG9KRAosEahNQzNiAuclyY0H7namO/Qot8swk9oRfQGT7PvL2zKfzo="}),s[5]||(s[5]=(0,e.Fv)('<p>在新架构中，引入了几个关键模块：<code>JSI</code>、<code>Fabric</code>、<code>TurboModules</code>、<code>Codegen</code>以及<code>Hermes</code>。</p><p>1.<strong>JavaScript Interface (JSI)</strong></p><ul><li>取代了旧架构中的 Bridge</li><li>提供 JavaScript 和原生代码的直接通信能力</li><li>支持同步调用，无需序列化和反序列化</li><li>允许 JavaScript 持有原生对象的引用</li></ul><p>2.<strong>Fabric 渲染系统</strong></p><ul><li>新的渲染器实现，替代旧的 Virtual DOM</li><li>支持优先级调度的并发渲染</li><li>使用 C++ 重写了渲染核心，提供跨平台一致性</li><li>引入 React Suspense 机制处理异步渲染</li></ul><p>3.<strong>TurboModules</strong></p><ul><li>按需加载原生模块，减少启动时间</li><li>支持类型安全的原生模块调用</li><li>通过 JSI 实现同步通信</li><li>优化内存占用和模块生命周期管理</li></ul><p>4.<strong>Codegen</strong></p><ul><li>静态代码生成工具</li><li>在编译时生成类型安全的接口代码</li><li>支持 TypeScript 类型定义</li><li>提前发现类型错误，增强代码健壮性</li></ul><p>5.<strong>Hermes 引擎</strong></p><ul><li>专为 React Native 优化的 JavaScript 引擎</li><li>通过字节码预编译提升启动性能</li><li>减少内存占用和包体积</li><li>与 JSI 无缝集成，支持同步操作</li><li>提供更好的调试和性能分析工具</li></ul><h3 id="javascript-interface" tabindex="-1"><a class="header-anchor" href="#javascript-interface"><span>Javascript Interface</span></a></h3><p>在新架构中，JSI 取代了旧架构中的 Bridge 通信层，实现了 JavaScript 和原生代码之间的直接通信。</p>',13)),(0,e.bF)(a,{id:"mermaid-228",code:"eJyFUz1P40AQ7fkVKyE6J5I3F6JLccXpiiM6gQ6XEcXG3iULVhLZDlC44KNJAQSJCBAgEoRAFHwJIUAQ4M9k7fAvWK83TgIBtrE9s2/evHljYhbn9TyyHPBvcgjwMzICflvUmMbgdXG39XLo7T+wyq1I2eXctIVKeXkhGz6mRC44BrWw7tBioVMrOBlNzWbQHNJ0i5Yc0Ho88htLUyAW+wVcNc6ay975cftqxa+duuB/GZdx1ruteEuXrzt1VtnuFhe5AObCOHuo8hxb3XKBhi2KzGxGmxgH7HzbPztp3V93UWFawBKSrNVstJ83XSlC/aBCxgXmR5xV13rYxpFD5ziGrdf9Wl1qiZAyK5BJycb2Dri6iG0gy+hHQfAbRVAAU+/a47MW93DBGOp3LKON9bowVnCwRZD+vXm8kYHmce/8vRtv/ZhtrPY4yHnkcvC3bvEoLA38W7QdMJGb4Yx2Z6rwy6mGghOStP1S44MN6GC/YL69XuOONavti2f/6ULEdBPZ9h9MQC5sgVDTTA+TBE6SpGI7VnEWp4dTOZUgKD9j89Rw8mlYWugvMGNTicYJAokRodWfqVHjE3S3ROfHCvvoifPxBLX7IqoiNl4J/Vbkvihyx2QYDqoFlWjc8joU1d8APqR16A=="}),s[6]||(s[6]=(0,e.Fv)('<h4 id="实现细节" tabindex="-1"><a class="header-anchor" href="#实现细节"><span>实现细节</span></a></h4><p>JSI 是通过 C++ 实现的一个轻量级抽象层，它提供了 JavaScript 引擎和原生代码之间的直接通信能力。选择 C++ 作为实现语言主要有以下几个原因：</p><p>1.<strong>跨平台一致性</strong>：C++ 作为底层语言，可以在不同平台（iOS、Android）上提供一致的接口和行为，确保了 JSI 的跨平台特性。</p><p>2.<strong>性能优势</strong>：C++ 可以直接与系统底层交互，避免了额外的语言绑定开销，同时其高效的内存管理和指针操作特性也有助于提升性能。</p><p>3.<strong>与 JavaScript 引擎的集成</strong>：主流的 JavaScript 引擎（如 V8、JavaScriptCore）都提供了 C++ API，使用 C++ 实现 JSI 可以更好地与这些引擎集成。</p><h4 id="工作原理" tabindex="-1"><a class="header-anchor" href="#工作原理"><span>工作原理</span></a></h4><p>JSI 的工作原理主要包含以下几个方面：</p><p>1.<strong>Host 函数注册</strong>：通过 C++ 实现的 JSI，原生模块可以直接将函数注册到 JavaScript 运行时，这些函数可以被 JavaScript 代码同步调用。</p><p>2.<strong>对象引用管理</strong>：JSI 维护了一个对象引用系统，使 JavaScript 代码可以安全地持有和操作原生对象，同时确保内存安全和正确的生命周期管理。</p><p>3.<strong>类型转换</strong>：JSI 提供了高效的类型转换机制，可以在 JavaScript 和原生类型之间进行快速转换，而无需经过序列化过程。</p><h4 id="与其他新架构组件的协同" tabindex="-1"><a class="header-anchor" href="#与其他新架构组件的协同"><span>与其他新架构组件的协同</span></a></h4><p>JSI 作为新架构的基础设施，与其他组件紧密协作：</p><p>1.<strong>Fabric 渲染系统</strong>：JSI 使 JavaScript 可以直接调用 Fabric 的 C++ 渲染核心，实现高效的 UI 更新。</p><p>2.<strong>TurboModules</strong>：基于 JSI 的同步调用能力，TurboModules 可以实现原生模块的按需加载和高效调用。</p><p>3.<strong>Codegen</strong>：通过代码生成工具，可以自动生成类型安全的 JSI 绑定代码，简化了开发过程并提高了代码质量。</p><h3 id="fabric-渲染系统" tabindex="-1"><a class="header-anchor" href="#fabric-渲染系统"><span>Fabric 渲染系统</span></a></h3><p>Fabric 是 React Native 新架构中的渲染系统，它通过重新设计渲染流程和线程模型，解决了旧架构中的性能瓶颈。</p>',17)),(0,e.bF)(a,{id:"mermaid-280",code:"eJyNkstKw0AUhvd9igFxZVrI1At24UJFUPAC1VVwMc1M7GBoShqNiyyUqgiKRRQrCFYXUldFxUutt5dxJn0Mk+mktULF2Qwz53yH8//nGKbl6llkO2BxPAaCU1jLrNgonwXzJtZ4ucovnvjFNq/f88oxf9zyb/aXRV54MLWJ7lArF8HhmUmr2gxaR2ndpnkH+I3PkAHx+JinJpamAT9/4Ke3Hhi3KV4hqta6O0XlvwBggjVKbK/MDk49kM4ibLmq1rqjwm1OhgWXTLB6kd1tNmtXfq3sgVlEc6r2VX/9DYmAQAZFb0KmB+aQQ9eD3thhxT+pNKu77PyjBZEcjnX7NEdcbQplbKpL/J8uwd4u+YFFh9fN26J/cuOBiYUFbWJgIKp+WWefxU71IBpZ9fLESkeRhFAZ7CUZSpe+3s7Yzp7fqHYLh38J7+8H/PKZvZWatQ//vSb+dBMVCpPEAJaJgUFNM9VnJMmQMaQUHNtaJam+kYxqICifcZdiJ5uC+Y1uOkdcSZOkAQ3cptXRkWHcg+6UCFdWCdZPkSukyJVQxJQVOdSwxx9MML6AgUrgo8iDMg+G3cS+Aa0jNtE="}),s[7]||(s[7]=(0,e.Lk)("h4",{id:"渲染过程",tabindex:"-1"},[(0,e.Lk)("a",{class:"header-anchor",href:"#渲染过程"},[(0,e.Lk)("span",null,"渲染过程")])],-1)),s[8]||(s[8]=(0,e.Lk)("p",null,"Fabric 的渲染过程分为三个主要阶段：渲染阶段（Render Phase）、提交阶段（Commit Phase）和挂载阶段（Mount Phase）。每个阶段都有其特定的职责和优化机制。",-1)),(0,e.bF)(a,{id:"mermaid-287",code:"eJyNkstO20AUhvd5ipEQu0YVidKULCq1ZUmrKmVTjVgM9gy26sSWPWmK5EWgKKA2glSkFykSASkINrVK1UIUEvoymbH7FnV8nAsIBLPw5Z9z/vnOOcMMs6xoxOZoMZ9A4XJKK6s2sTSUp0WV2lh2fsnW3r/vZ9L7sxxFDJeq21ThullES8/GYp4ShePoiWTzt/z6cxklk09csd0UF92HILnotUZUs4zhhZZsSie+sTjMCrxD3/smTvdl5dhFr2zTcrBob/r1KmiQFEImrnI/NwsFnWO5Wx902/fiXiRrZolj0fkgTitwLIC/MVeJ6H2RezsuWtAZw+LcE72NOGScP9yK4v1GS27Xg8OjQWc9RCZc0aiDoW5Qb4N+YZaKIXNtI+j378X81LKMNSy6Db9xMt3rQefC7/71Tz656CXh+juKxU4r5AqOq6J5OTGFTaD+eCYr66Jekz+OwulwwmnMLLxaWM81ZrgXMNhoXx58lvub4YTduPdRGHxC2FZVtLdG449KBavZWSQPzkVvN/Au/b4XaYpBHGeBMmTDOUw3jNwMTbMUUx843Dbf0tzM3Hz2kZqKf5NlXeVaLmW9v2qgAAEYsDTNsMzYILsyx8hdBoUh6QjgMcvQ+XF+imbV9A35E4NRn6CMKT1uDNBN6VFf4MzEf27Tcto="}),s[9]||(s[9]=(0,e.Fv)('<p>1.<strong>渲染阶段（Render Phase）</strong></p><ul><li>负责创建和更新 Shadow Tree</li><li>处理组件的属性和状态变化</li><li>在 JavaScript 线程中执行，与 React 的调和过程同步</li><li>通过 JSI 直接与 C++ 层通信，避免序列化开销</li></ul><p>2.<strong>提交阶段（Commit Phase）</strong></p><ul><li>使用 Yoga 引擎进行布局计算</li><li>对比新旧 Shadow Tree，计算需要更新的内容</li><li>生成高效的更新补丁</li><li>可以在后台线程并发执行，提高性能</li></ul><p>3.<strong>挂载阶段（Mount Phase）</strong></p><ul><li>在主线程上执行实际的 UI 更新</li><li>将更新补丁应用到原生视图</li><li>确保视图状态的同步</li><li>支持优先级调度，保证关键更新的及时性</li></ul><p>这种三阶段的设计带来了几个重要优势：</p><ul><li>通过 JSI 实现的直接通信减少了线程切换和序列化开销</li><li>后台线程的布局计算和差异对比提高了性能</li><li>优先级调度机制确保了重要更新的响应速度</li><li>统一的 C++ 渲染核心保证了跨平台的一致性</li></ul><h4 id="统一的渲染核心" tabindex="-1"><a class="header-anchor" href="#统一的渲染核心"><span>统一的渲染核心</span></a></h4><p>Fabric 最显著的特点是采用 C++ 重写了渲染核心。在旧架构中，渲染逻辑分散在 JavaScript、Bridge 和原生层，这种分散的设计不仅增加了维护难度，还容易导致不同平台的渲染行为不一致。Fabric 通过 C++ 实现了一个统一的渲染核心，确保了跨平台的一致性，同时也提供了更好的性能优化空间。</p><p>渲染核心直接与 JSI 集成，使得 JavaScript 和原生代码之间的通信更加高效。当发生 UI 更新时，渲染指令可以直接从 JavaScript 传递到 C++ 层，无需经过序列化和反序列化的过程。这种设计不仅减少了通信开销，还提供了更细粒度的渲染控制。</p><h4 id="优化的线程模型" tabindex="-1"><a class="header-anchor" href="#优化的线程模型"><span>优化的线程模型</span></a></h4><p>旧架构采用了三线程模型：JavaScript 线程负责业务逻辑，Shadow 线程处理布局计算，主线程执行 UI 渲染。这种设计虽然实现了职责分离，但线程间频繁的通信和同步操作成为了性能瓶颈。</p><p>Fabric 重新设计了线程模型，引入了优先级调度机制。它允许渲染工作在多个线程上并发执行，而不是严格按照线程边界划分任务。更重要的是，Fabric 可以根据任务的优先级动态调整执行顺序，确保关键的 UI 更新能够优先处理。</p>',14)),(0,e.bF)(a,{id:"mermaid-406",code:"eJx1kU9LAkEYxu9+ioHwloQrZXrokB46WIR0Wzxs7qwOra6MKxZ4KKMwskyEsjyoEHkQFqnQ8l9fxpldv0W6uq6Kzm3e95nf+7zPCKKUDIY5LAOf3wJGJ544DWEuFgbHGEkYyRfsoFskNxm1XdMa16T9EdBl48MjDIMykqLgZH9WPEChMDusF2evaOmbPjcCwGbbS6n1e/LwRe9qWjWbAn4Y5SG2s/Tnk5YLqlIdXhVM+pGEI5zI0ldlePk2D5nYWIQwayA+KckOeo8rzZBOU/srL3IcKzijhmUpGhSDIorCNUNX5uLBkJMhSzIl0mlvTXzQSl63ArxIEFjSUkg3rSlVVXkxYeOWrvFIkQiSWZp7GrTfp3uYdL2p6w6lRHQky6a1Xk+r3ZJSf2kN42MnIfw2SS5vhGAsNhFarYBWWqSb05S+2lP0WlDk4nEvFEDMoAhIFN0b0CEwAr8Zl7F0Bt0bdpdzh2emV1sS8XLYzcTOlxDTaQZiV9iGrhmCgU7esQZhcsxtDEPzPWOAMcnyD8InPEY="}),s[10]||(s[10]=(0,e.Fv)('<h4 id="性能优化机制" tabindex="-1"><a class="header-anchor" href="#性能优化机制"><span>性能优化机制</span></a></h4><p>Fabric 引入了多项性能优化机制。首先是 React Suspense 的支持，它允许组件在渲染过程中「暂停」，等待异步数据加载完成。这种机制避免了旧架构中频繁的渲染中断和重试，提供了更流畅的用户体验。</p><p>其次，Fabric 实现了新的挂载系统。在旧架构中，视图的创建和更新需要在不同线程间来回传递信息，而 Fabric 的挂载系统允许在同一个线程中完成大部分操作，显著减少了线程切换的开销。</p><p>最后，Fabric 优化了内存管理。通过共享内存池和智能的内存回收策略，减少了内存分配和回收的频率。这不仅提升了性能，还降低了内存占用。</p><p>这些优化使得 Fabric 能够更好地处理复杂的 UI 场景，特别是在列表滚动、动画过渡等高性能要求的场景下，表现出明显的优势。同时，由于采用了统一的渲染核心，这些优化在不同平台上都能得到一致的效果。</p><h3 id="turbomodules" tabindex="-1"><a class="header-anchor" href="#turbomodules"><span>TurboModules</span></a></h3><p>TurboModules 是 React Native 新架构中负责原生模块管理的核心系统，它通过重新设计模块加载机制和生命周期管理，解决了旧架构中原生模块调用的性能问题。</p><h4 id="按需加载与同步调用" tabindex="-1"><a class="header-anchor" href="#按需加载与同步调用"><span>按需加载与同步调用</span></a></h4><p>在旧架构中，所有原生模块都会在应用启动时被加载和初始化，这导致了启动时间的延长和内存的浪费。而 TurboModules 采用了按需加载的策略，只有当 JavaScript 代码首次访问某个原生模块时，该模块才会被加载到内存中。</p>',9)),(0,e.bF)(a,{id:"mermaid-434",code:"eJyNkj9PwkAYxnc+xSWErQyUIJHBwbiqibI1DECv0FgpaUsqCQODSCBFHKowIH8mq4k4mCARCl+GO9pvYf+KGEx8t7u8v+d9nnuP4Xg5m08LEkgeBoBVYimTE9LFPDjlaAp3nnB/gvvXWBuhxw5qDg1dTzl9dtGsALMSyxd82K5zyVKLUOhTXasauntDTS0FwuGDCqppZr3talTAMU+XOChGKNyo4l4D3Q7W6sAdsxngN7l8a2gr3tTQa9fi4SUvlK05zhlNp+bzzAVhgQ5sRzmBMpUsCRne0wP/D0LuCjKbGMuBH+QM5lhREsqUax6/WxYVY6Rt1P0OB8ZKw+xVt1+BQq371fRld3qHWulL28RYMetNrC78+JY7J/5q3kXKw6/4oRDAww80bxvjxVofO3dZLi2KR5ABPEcDhuW4RJCJwhgTIyyD/AVMBOOZCJMmvWNYZmkpnyCLV9t0AcoeDaMMydDfdGQ/vkf/QW8k7L9FuP+E8FdMeAu1nf3otFbndpKE/4we4gGkbSbwBcZRJrE="}),s[11]||(s[11]=(0,e.Fv)('<p>此外，得益于 JSI 的引入，TurboModules 实现了 JavaScript 和原生代码之间的同步调用。在旧架构中，原生模块的调用必须通过异步的 Bridge 进行，这不仅增加了调用延迟，还导致了回调地狱的问题。而在新架构中，JavaScript 代码可以直接通过 JSI 同步调用原生方法，获得立即的返回值，这大大简化了代码逻辑，提升了执行效率。</p><h4 id="生命周期管理" tabindex="-1"><a class="header-anchor" href="#生命周期管理"><span>生命周期管理</span></a></h4><p>TurboModules 对模块的生命周期进行了精细化管理。在旧架构中，原生模块一旦加载就会常驻内存，直到应用退出。这种设计虽然简单，但在大型应用中会导致严重的内存浪费。TurboModules 引入了更智能的生命周期管理机制：</p><p>1.<strong>延迟初始化</strong>：模块只在首次使用时才会被初始化 2.<strong>按需释放</strong>：不再使用的模块可以被释放，释放内存资源 3.<strong>重用机制</strong>：频繁使用的模块会被缓存，避免重复初始化的开销</p><p>这些精细化的生命周期管理不仅优化了内存使用，还提升了应用的整体性能。特别是在内存受限的设备上，这种优化的效果更为明显。</p><h4 id="类型安全与开发体验" tabindex="-1"><a class="header-anchor" href="#类型安全与开发体验"><span>类型安全与开发体验</span></a></h4><p>TurboModules 与 Codegen 紧密集成，在编译时就能发现类型错误，这是对旧架构的重要改进。在旧架构中，原生模块的类型错误只能在运行时被发现，这不仅增加了调试难度，还会导致应用不稳定。</p>',7)),(0,e.bF)(a,{id:"mermaid-456",code:"eJyFkT1PwkAYx3c+xSXGrQxifGNwUBaJOtBuDUPhrtBYaFMKaNIBgyYSDS8JUcMAGEJkqmgixgD6Zbhe+RaWtkAxMd5097z87/97Hl6U8vEkp6jgOOID1slkYwmFk5MghHIsHhVwpTZ9HBj6e9ROzw4UFBRXBSkNmINFkKFZ5kJGdFwRZBVgvTH5LEWB37+vkdG9+VIzHgZGp2C0uho4lCBKoDQ7GXZI+5LUW8ZNdanuZp1WO0deh7h5i/USvu6RxpVR7uJKRwOnnCrkEIvLLavM0XJUUBr6Vlki2bQqpBBrflfNpzvLyj8wYZoNcznOhXG1HUceL2a/SOo9DTBZJSadSDArItZzX/7hCdoiRunZsjEnOErJokuB9SYp939RWIuwu6bFHhm/aXMYJ7m+Doz2Bx5VTP2LjHU7Fhe5TCaEeACtTl4QxeAa2uQDPKQyqiKdoeDaxt7ONgy4T39egGoyGJDPV7sV55+5wi6/hfYWCgG0Azf/UFjKzLxTDE25O6Uc4JkvT43LQ4VpyjMot3Y2nLkT3w9v6hAe"}),s[12]||(s[12]=(0,e.Fv)('<p>通过与 Codegen 的配合，TurboModules 提供了：</p><p>1.<strong>静态类型检查</strong>：在编译时发现类型错误 2.<strong>IDE 智能提示</strong>：更好的代码补全和文档提示 3.<strong>接口一致性</strong>：确保 JavaScript 和原生代码的接口定义匹配</p><h3 id="hermes-引擎" tabindex="-1"><a class="header-anchor" href="#hermes-引擎"><span>Hermes 引擎</span></a></h3><p>Hermes 是 Facebook 专门为 React Native 开发的 JavaScript 引擎，它与旧架构中使用的 JavaScriptCore 有着显著的区别和优势。</p><h4 id="工作流程" tabindex="-1"><a class="header-anchor" href="#工作流程"><span>工作流程</span></a></h4><p>Hermes 引擎的工作流程可以分为三个主要阶段：编译阶段、加载阶段和执行阶段。</p>',6)),(0,e.bF)(a,{id:"mermaid-475",code:"eJyNkk1L40Acxu/9FAPibXtoSrdrDwtbd1lWLCxb8TJ4SDMz22BsSpL6clTxrVZU0PpeKwr10oqICmr9NM50/BYmM2nTiqJzSv7/53nml4cQw5zSsqrlgOF/IeAeu5D5b6n5LEgWdAPB1kOZX2w+796wxvWYEHgH6RbWHN3MgZFkZziUhkPqpJrWLD3vAHa30arOjoFw+Dv4q1o2tiCvnbLKBt07D4LkRoh+pEcgKzb55Qm/qLOrbVbdDHTuUoiSMw7WTIQHzYm8briZtL7Di3PuTRK0J/y1uCchcLLy0tP9jbThHAr11jBsqgjSYpU3m59qoZ3v+br5ZITHJzBGUxHI9/bZ6jE7vKPLR7S2SkvlINvdC10KT5jWDKSLC7S+S5cXnxfW3iP9NY21goMhW6nxk9KnYEdTSkAhfRLvT852rILQ25CV3ILO/HXH2y0Rnt+DkFbm6eEjPaiwrdeFit9J6LxmxMh7EBOfXAr7+wGr3tKHdd54bDUbYqYZqm3/xARkRArRDSPRh6NEIeiLS2GO40RfZCD+FSn+a3hKR042oeSne/2Gd6W0kyiOkVjHHs9EiPqRHUvQNsA3EsMDnQQFx1H0jYQgwi9BfETXVPTgkXXN/EraN4ZeAH1eZEA="}),s[13]||(s[13]=(0,e.Fv)('<h5 id="编译阶段-构建时" tabindex="-1"><a class="header-anchor" href="#编译阶段-构建时"><span>编译阶段（构建时）</span></a></h5><p>在应用构建阶段，Hermes 引擎采用高效的预编译策略处理 JavaScript 源代码。首先将源代码解析成抽象语法树（AST），进行静态分析和优化，然后将优化后的 AST 编译为 Hermes 专有的字节码，最终打包到应用中。这种预编译策略避免了运行时解析 JavaScript 源码的开销，显著提升了应用的启动性能。</p><h5 id="加载阶段-启动时" tabindex="-1"><a class="header-anchor" href="#加载阶段-启动时"><span>加载阶段（启动时）</span></a></h5><p>当应用启动时，Hermes 引擎会高效地完成初始化过程。它首先从应用包中加载预编译好的字节码文件，同时初始化 Hermes 虚拟机运行环境，并为即将执行的字节码预分配必要的内存空间。由于这些字节码已经过预编译处理，整个加载过程的耗时远低于传统 JavaScript 引擎在启动时需要进行即时编译的时间。</p><h5 id="执行阶段-运行时" tabindex="-1"><a class="header-anchor" href="#执行阶段-运行时"><span>执行阶段（运行时）</span></a></h5><p>在运行过程中，Hermes 引擎通过精心设计的机制保证应用的性能和稳定性。虚拟机直接执行预编译的字节码指令，同时进行实时的内存分配和回收。Hermes 采用增量式垃圾回收器，有效减少性能抖动。引擎还持续进行运行时的动态优化和性能监控，确保应用保持最佳状态。这种基于字节码的执行方式不仅性能卓越，还能实现更精确的内存管理和更低的内存占用。</p><h3 id="codegen" tabindex="-1"><a class="header-anchor" href="#codegen"><span>Codegen</span></a></h3><p>Codegen 作为 React Native 新架构中的核心模块，通过创新的静态类型检测和接口代码生成机制，从根本上解决了旧架构中的类型安全问题。在深入了解 Codegen 的工作原理之前，让我们先回顾一下旧架构中的类型处理痛点。</p><p>在旧架构中，开发者经常会遇到类型相关的挑战。由于缺乏统一的类型系统，JavaScript 和原生代码之间的类型转换需要手动处理，这不仅增加了开发工作量，还容易引入错误。更糟糕的是，这些类型错误往往要等到运行时才能被发现，这大大增加了应用的不稳定性。此外，由于工具支持的缺失，开发者在编写代码时无法获得准确的类型提示，这也影响了开发效率和代码质量。</p><p>Codegen 的出现彻底改变了这一状况。它通过一个精心设计的三阶段处理流程，将类型安全从运行时提前到了编译时：</p>',10)),(0,e.bF)(a,{id:"mermaid-506",code:"eJyNk8tO20AUhvd5ipEQu0YVidKULCr1olZh0SKS3YjFYJ9pLKzYmplAu2tVWnpToOqNdkGCTAQb0qKWa4CnicfmLYg9voSLBLOyz/znm//MOUNNa16rESZQ9UEGDRZvzDxnxK6hct1uCOyffHXfdk5XdmV3ZzoUBEs3GGjCsOpxVrAmKo8NEzieIHOkojHDFrerL21Qn0j+WOz3dqdRNnsPBeFHQDn2tnvu6ie3+7t/8CGlV2zQOPY3FvzPb65KC4VQ1zPnDU8ySwPOsbu+4C2/u5HlScI4sMiGv+HI1WX316Y67X6liuXHY397zf+zJf99l+0vKW2wmVh6WANtNqFI55VsdQJKIh4ShUnlKdzf3zr9+d9f2/TWD5Xwcj3PGiLuwOLhjcp5AnVgRFgM93uO137tfWvJ92lFT4kw5gC7zVaw0ey4S47SpdiEkFSn2oeHOhk1zfkrV5oXvMcdCrPV5Ybx8lQYSehKPTqKZHvPPVryuyfecTeMaSbhfIBARjB+iBqmWRqBPM1R/RYXzJqF0sjYePGOnot+s/OGLmqlnP3ifL6tpiEi0DwUaCEhFGfGKLmOYIX3H1u4SwswngByUNTzVwBSgno/qoyhaDSksb2hHdXu6NTMGceoX5A="}),s[14]||(s[14]=(0,e.Fv)('<p>在输入阶段，Codegen 会收集并分析项目中的 JavaScript/TypeScript 文件和规范文件，提取所有的类型信息和接口定义。这些信息随后在处理阶段被转换为抽象语法树（AST），并经过严格的类型检查。最后，在输出阶段，Codegen 会生成类型安全的原生接口代码和 TypeScript 类型声明文件。</p><p>这种设计带来了显著的改进。首先，在开发体验方面，开发者可以享受到现代 IDE 带来的智能提示和自动补全功能，这大大提升了开发效率。其次，在代码质量方面，由于类型错误能够在编译阶段就被发现，这显著减少了运行时崩溃的可能性。</p><p>在性能方面，Codegen 通过优化类型转换过程和减少运行时类型检查，生成了更高效的原生代码。同时，它还提供了统一的类型系统，确保了不同平台之间接口的一致性，这对于跨平台应用的开发和维护都带来了极大便利。</p><p>此外，Codegen 还为代码维护带来了显著优势。接口变更能够被及时发现，文档能够自动保持最新，这不仅降低了维护成本，还提高了代码的可维护性。通过统一的类型系统，它还减少了平台特定的类型错误，使得跨平台开发更加顺畅。</p><h2 id="新旧架构对比" tabindex="-1"><a class="header-anchor" href="#新旧架构对比"><span>新旧架构对比</span></a></h2><p>本节中，我们将在新旧两套架构下来实现同样一个原生模块，这样可以直观对比出来新旧架构的一些差异。</p><h3 id="示例-计算器模块" tabindex="-1"><a class="header-anchor" href="#示例-计算器模块"><span>示例：计算器模块</span></a></h3><p>我们以一个简单的计算器模块为例，实现一个加法运算功能。这个示例将展示如何在两种架构下定义和实现原生模块，以及如何处理与 JavaScript 端的通信。</p><h4 id="旧架构实现" tabindex="-1"><a class="header-anchor" href="#旧架构实现"><span>旧架构实现</span></a></h4><p>在旧架构中，实现一个原生模块需要遵循以下步骤：</p><p>1.<strong>定义原生模块类</strong></p><p>首先需要创建一个继承自 <code>NSObject</code> 并遵循 <code>RCTBridgeModule</code> 协议的类。通过在头文件中声明接口，我们定义了一个可以被 React Native 识别的原生模块。</p><div class="language-objc line-numbers-mode" data-highlighter="shiki" data-ext="objc" data-title="objc" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// CalcModule.h</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#import</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &lt;React/RCTBridgeModule.h&gt;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">@interface</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> CalcModule</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> : </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">NSObject</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;RCTBridgeModule&gt;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">@end</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2.<strong>实现模块方法</strong></p><p>在实现文件中，我们使用 <code>RCT_EXPORT_MODULE()</code> 宏来导出模块，并通过 <code>RCT_EXPORT_METHOD</code> 宏来导出具体的方法。</p><div class="language-objc line-numbers-mode" data-highlighter="shiki" data-ext="objc" data-title="objc" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// CalcModule.m</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#import</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;CalcModule.h&quot;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">@implementation</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> CalcModule</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">RCT_EXPORT_MODULE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">RCT_EXPORT_METHOD</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(add:(</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">NSInteger</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)a</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">                  b:(</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">NSInteger</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)b</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">                  callback:(RCTResponseSenderBlock)</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">callback</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>\n<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">    NSInteger</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> result </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a + b;</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    callback</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(@[@(result)]);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">@end</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3.<strong>导出模块到 JavaScript</strong></p><p>最后，我们在 JavaScript 端封装这个原生模块。通过 React Native 提供的 <code>NativeModules</code> API 获取原生模块的引用，并将回调式的 API 封装成返回 Promise 的现代 JavaScript 接口，使其更易于使用。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// Calculator.js</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">NativeModules</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;react-native&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;">CalcModule</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> } </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> NativeModules</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">export</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> const</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> add</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">b</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  return</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Promise</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">((</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">resolve</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">    CalcModule</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">b</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, (</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">result</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">      resolve</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">result</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    });</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  });</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="新架构实现" tabindex="-1"><a class="header-anchor" href="#新架构实现"><span>新架构实现</span></a></h4><p>在新架构中，实现一个原生模块需要遵循以下步骤：</p><p>1.<strong>定义模块规范（TypeScript）</strong></p><p>首先，我们需要使用 TypeScript 定义模块的接口规范。通过继承 <code>TurboModule</code> 接口，我们可以声明模块的方法签名，包括参数类型和返回值类型。</p><div class="language-typescript line-numbers-mode" data-highlighter="shiki" data-ext="typescript" data-title="typescript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// NativeCalcModule.ts</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> type</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">TurboModule</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;react-native/Libraries/TurboModule/RCTExport&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">TurboModuleRegistry</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;react-native&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">export</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> interface</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Spec</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> extends</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> TurboModule</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">a</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;"> number</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">b</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;"> number</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Promise</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">number</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">export</span><span style="--shiki-light:#E45649;--shiki-dark:#C678DD;"> default</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> TurboModuleRegistry</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Spec</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;CalcModule&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2.<strong>使用 Codegen 生成接口代码</strong></p><p>有了 TypeScript 定义后，我们使用 Codegen 工具自动生成类型安全的接口代码。Codegen 会分析 TypeScript 定义，生成对应的原生代码（包括 C++ 和 Objective-C 的接口文件），确保 JavaScript 和原生代码之间的类型一致性。由于篇幅较长，我们将在下一篇中给出 Codegen 生成代码的示例。</p><p>3.<strong>实现原生模块</strong></p><p>最后，我们实现原生模块的具体功能。</p><div class="language-objc line-numbers-mode" data-highlighter="shiki" data-ext="objc" data-title="objc" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">@interface</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> CalcModule</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> : </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">NSObject</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;NativeCalcSpec&gt;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">@end</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">@implementation</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> CalcModule</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">RCT_EXPORT_MODULE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">- (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">add:</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">double</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#ABB2BF;--shiki-dark-font-style:italic;">a</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> b:</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">double</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#ABB2BF;--shiki-dark-font-style:italic;">b</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> resolve:</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(RCTPromiseResolveBlock)</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#ABB2BF;--shiki-dark-font-style:italic;">resolve</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> reject:</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(RCTPromiseRejectBlock)</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#ABB2BF;--shiki-dark-font-style:italic;">reject</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    NSNumber</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> *result </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> @(a + b);</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    resolve</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(result);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">@end</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',29)),(0,e.Lk)("p",null,[s[1]||(s[1]=(0,e.eW)("完整的过程我们将在")),(0,e.bF)(n,{to:"/iOS/react_native_message_new.html"},{default:(0,e.k6)((()=>s[0]||(s[0]=[(0,e.eW)("后续文章")]))),_:1}),s[2]||(s[2]=(0,e.eW)("中详细介绍。"))]),s[15]||(s[15]=(0,e.Lk)("h2",{id:"总结",tabindex:"-1"},[(0,e.Lk)("a",{class:"header-anchor",href:"#总结"},[(0,e.Lk)("span",null,"总结")])],-1)),s[16]||(s[16]=(0,e.Lk)("p",null,"本文详细介绍了 React Native 架构的演进历程。在旧架构中，由于 Bridge 通信机制的局限性，导致了序列化开销大、线程切换频繁、布局计算效率低等性能问题。为了解决这些问题，React Native 团队推出了全新的架构设计，引入了五个核心组件：JSI 提供了 JavaScript 和原生代码的直接通信能力，消除了序列化开销；Fabric 重写了渲染核心，实现了跨平台的一致性和高效的并发渲染；TurboModules 优化了原生模块的加载和执行机制；Codegen 通过静态代码生成提供了类型安全保证；Hermes 引擎则通过字节码预编译和运行时优化提升了整体性能。这些改进不仅显著提升了 React Native 应用的性能，还为开发者提供了更好的开发体验。",-1))])}]]),t=JSON.parse('{"path":"/iOS/react_native_new_arch.html","title":"React Native 新架构学习","lang":"en-US","frontmatter":{"category":"iOS","star":true,"tags":["技术原理"]},"git":{"createdTime":1742112620000,"updatedTime":1742112620000,"contributors":[{"name":"Tamarous","username":"Tamarous","email":"hiwangzewei@qq.com","commits":1,"url":"https://github.com/Tamarous"}]},"readingTime":{"minutes":23.11,"words":6932},"filePathRelative":"iOS/react_native_new_arch.md","localizedDate":"March 16, 2025","excerpt":"\\n<h2>前言</h2>\\n<p>React Native 是一个用于构建跨平台移动应用的开源框架，它允许开发者使用 JavaScript 和 React 语法来编写应用，然后将其编译为原生平台的代码，如 iOS 和 Android。随着移动应用复杂度的不断提升，React Native 的架构设计也在不断演进。在 0.68 版本中，React Native 团队引入了全新的架构设计，从根本上解决了旧架构中的性能瓶颈，并带来了诸多创新特性。本文将深入探讨 React Native 新架构的设计理念和实现原理，帮助开发者更好地理解和应用这一重要升级。</p>\\n<h2>React Native 旧架构解析</h2>"}')},6262:(i,s)=>{s.A=(i,s)=>{const a=i.__vccOpts||i;for(const[i,e]of s)a[i]=e;return a}}}]);