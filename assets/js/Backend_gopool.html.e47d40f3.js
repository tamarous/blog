"use strict";(self.webpackChunktamarous_blog=self.webpackChunktamarous_blog||[]).push([[249],{6262:(s,n)=>{n.A=(s,n)=>{const a=s.__vccOpts||s;for(const[s,i]of n)a[s]=i;return a}},7648:(s,n,a)=>{a.r(n),a.d(n,{comp:()=>l,data:()=>p});var i=a(641);const e={},l=(0,a(6262).A)(e,[["render",function(s,n){const a=(0,i.g2)("Mermaid");return(0,i.uX)(),(0,i.CE)("div",null,[n[0]||(n[0]=(0,i.Fv)('<h1 id="gopool-实现分析" tabindex="-1"><a class="header-anchor" href="#gopool-实现分析"><span>Gopool 实现分析</span></a></h1><p>Gopool 是字节跳动开源项目 <a href="https://github.com/bytedance/gopkg" target="_blank" rel="noopener noreferrer">gopkg</a> 中的一个小工具，作用是以池化的思想来实现 goroutine 的复用，限制应用中 goutine 数量的无限增长。</p><h2 id="使用介绍" tabindex="-1"><a class="header-anchor" href="#使用介绍"><span>使用介绍</span></a></h2><p>Gopool 使用起来非常简单，只需要将项目中的 go 关键字替换为 gopool.Go：</p><div class="language-go line-numbers-mode" data-highlighter="shiki" data-ext="go" data-title="go" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">go</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> func</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">\t// do your job</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}()</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>替换成</p><div class="language-go line-numbers-mode" data-highlighter="shiki" data-ext="go" data-title="go" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">gopool</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Go</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">func</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(){</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">\t/// do your job</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">})</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="文件目录" tabindex="-1"><a class="header-anchor" href="#文件目录"><span>文件目录</span></a></h2><p>Gopool 目录下共有 6 个文件，非常简洁：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>.</span></span>\n<span class="line"><span>├── README.md</span></span>\n<span class="line"><span>├── config.go</span></span>\n<span class="line"><span>├── gopool.go</span></span>\n<span class="line"><span>├── pool.go</span></span>\n<span class="line"><span>├── pool_test.go</span></span>\n<span class="line"><span>└── worker.go</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="gopool" tabindex="-1"><a class="header-anchor" href="#gopool"><span>gopool</span></a></h3><p>首先来看 gopool.go 这个文件。在这个文件的 init 方法中创建了 defaultPool:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>func init() {</span></span>\n<span class="line"><span>\tdefaultPool = NewPool(&quot;gopool.DefaultPool&quot;, math.MaxInt32, NewConfig())</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>示例中的 gopool.Go 实际上是在调用 defaultPool 的同名方法：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>func Go(f func()) {</span></span>\n<span class="line"><span>\tCtxGo(context.Background(), f)</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>// CtxGo is preferred than Go.</span></span>\n<span class="line"><span>func CtxGo(ctx context.Context, f func()) {</span></span>\n<span class="line"><span>\tdefaultPool.CtxGo(ctx, f)</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="pool" tabindex="-1"><a class="header-anchor" href="#pool"><span>pool</span></a></h3><p>defaultPool 实现了 Pool 接口，其定义位于 pool.go 中：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>type Pool interface {</span></span>\n<span class="line"><span>\t// 返回当前 pool 的名称</span></span>\n<span class="line"><span>\tName() string</span></span>\n<span class="line"><span>\t// 设置 pool 中 goroutine 的最大数量</span></span>\n<span class="line"><span>\tSetCap(cap int32)</span></span>\n<span class="line"><span>\t// 执行用户传入的 func</span></span>\n<span class="line"><span>\tGo(f func())</span></span>\n<span class="line"><span>\t// 在用户指定的 context 中执行用户传入的 func</span></span>\n<span class="line"><span>\tCtxGo(ctx context.Context, f func())</span></span>\n<span class="line"><span>\t// 设置异常处理方法</span></span>\n<span class="line"><span>\tSetPanicHandler(f func(context.Context, interface{}))</span></span>\n<span class="line"><span>\t// 返回当前 running 状态的 worker</span></span>\n<span class="line"><span>\tWorkerCount() int32</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同时在这个文件里定义了名为 pool 的结构体，并实现了上述 Pool 接口</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>type pool struct {</span></span>\n<span class="line"><span>\t// 当前 pool 的名称</span></span>\n<span class="line"><span>\tname string</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>\t// 当前 pool 的容量</span></span>\n<span class="line"><span>\tcap int32</span></span>\n<span class="line"><span>\t// 配置信息</span></span>\n<span class="line"><span>\tconfig *Config</span></span>\n<span class="line"><span>\t// 由 task 组成的链表</span></span>\n<span class="line"><span>\ttaskHead  *task</span></span>\n<span class="line"><span>\ttaskTail  *task</span></span>\n<span class="line"><span>\ttaskLock  sync.Mutex</span></span>\n<span class="line"><span>\ttaskCount int32</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>\t// 记录当前处于 running 状态的 worker 数量</span></span>\n<span class="line"><span>\tworkerCount int32</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>\t// worker 异常时的恢复方法</span></span>\n<span class="line"><span>\tpanicHandler func(context.Context, interface{})</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>让我们深入看一下 CtxGo 这个接口方法是怎么实现的：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>func (p *pool) CtxGo(ctx context.Context, f func()) {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>   // 从 taskPool 中获取一个 task</span></span>\n<span class="line"><span>\tt := taskPool.Get().(*task)</span></span>\n<span class="line"><span>\tt.ctx = ctx</span></span>\n<span class="line"><span>\tt.f = f</span></span>\n<span class="line"><span>\t</span></span>\n<span class="line"><span>\t// 更新 taskHead 和 taskTail 两个指针的指向</span></span>\n<span class="line"><span>\tp.taskLock.Lock()</span></span>\n<span class="line"><span>\tif p.taskHead == nil {</span></span>\n<span class="line"><span>\t\tp.taskHead = t</span></span>\n<span class="line"><span>\t\tp.taskTail = t</span></span>\n<span class="line"><span>\t} else {</span></span>\n<span class="line"><span>\t\tp.taskTail.next = t</span></span>\n<span class="line"><span>\t\tp.taskTail = t</span></span>\n<span class="line"><span>\t}</span></span>\n<span class="line"><span>\tp.taskLock.Unlock()</span></span>\n<span class="line"><span>\tatomic.AddInt32(&amp;p.taskCount, 1)</span></span>\n<span class="line"><span>\t\t</span></span>\n<span class="line"><span>\t// 如果 task 的数量比设置的阈值大，并且 p 的 worker 的数量小于 pool 的容量</span></span>\n<span class="line"><span>\t// 或者 p 的 worker 数量为 0</span></span>\n<span class="line"><span>\tif (atomic.LoadInt32(&amp;p.taskCount) &gt;= p.config.ScaleThreshold &amp;&amp; p.WorkerCount() &lt; atomic.LoadInt32(&amp;p.cap)) || p.WorkerCount() == 0 {</span></span>\n<span class="line"><span>\t</span></span>\n<span class="line"><span>\t   //  从 workerPool 中获取一个 worker，并启动</span></span>\n<span class="line"><span>\t\tp.incWorkerCount()</span></span>\n<span class="line"><span>\t\tw := workerPool.Get().(*worker)</span></span>\n<span class="line"><span>\t\tw.pool = p</span></span>\n<span class="line"><span>\t\tw.run()</span></span>\n<span class="line"><span>\t}</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>taskPool 和 workerPool 是两个 sync.Pool 类型的全局对象，分别负责 task 和 worker 对象的复用。CtxGo 方法中首先会从 taskPool 的池子中取出一个 task 来复用，并调整 p 的 taskHead/taskTail/taskCount 等属性的值。在满足一些前提的情况下，还需要从 workerPool 中取出 worker，将 worker 的 pool 属性指向当前的 p，并调用 worker.run 方法。</p><h3 id="task" tabindex="-1"><a class="header-anchor" href="#task"><span>task</span></a></h3><p>task 是一个结构体，封装了用户传入的 func，同时还有一个指向下一个任务的属性</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>type task struct {</span></span>\n<span class="line"><span>\tctx context.Context</span></span>\n<span class="line"><span>\tf   func()</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>\tnext *task</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>func (t *task) zero() {</span></span>\n<span class="line"><span>\tt.ctx = nil</span></span>\n<span class="line"><span>\tt.f = nil</span></span>\n<span class="line"><span>\tt.next = nil</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>func (t *task) Recycle() {</span></span>\n<span class="line"><span>\tt.zero()</span></span>\n<span class="line"><span>\ttaskPool.Put(t)</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="worker" tabindex="-1"><a class="header-anchor" href="#worker"><span>worker</span></a></h3><p>worker 其实就是嵌入了一个 pool 的结构体：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>type worker struct {</span></span>\n<span class="line"><span>\tpool *pool</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>run 方法的实现如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>func (w *worker) run() {</span></span>\n<span class="line"><span>   // 启动一个 goroutine</span></span>\n<span class="line"><span>\tgo func() {</span></span>\n<span class="line"><span>\t   // 在这个 goroutine 中，循环执行如下逻辑</span></span>\n<span class="line"><span>\t\tfor {</span></span>\n<span class="line"><span>\t\t   // 从 w.pool 的队头取出一个 task </span></span>\n<span class="line"><span>\t\t\tvar t *task</span></span>\n<span class="line"><span>\t\t\tw.pool.taskLock.Lock()</span></span>\n<span class="line"><span>\t\t\tif w.pool.taskHead != nil {</span></span>\n<span class="line"><span>\t\t\t\tt = w.pool.taskHead</span></span>\n<span class="line"><span>\t\t\t\tw.pool.taskHead = w.pool.taskHead.next</span></span>\n<span class="line"><span>\t\t\t\tatomic.AddInt32(&amp;w.pool.taskCount, -1)</span></span>\n<span class="line"><span>\t\t\t}</span></span>\n<span class="line"><span>\t\t\tif t == nil {</span></span>\n<span class="line"><span>\t\t\t\t// 如果 w.pool 的队头取不到 task 了，说明当前没有需要执行的 task 了，清理当前 worker</span></span>\n<span class="line"><span>\t\t\t\tw.close()</span></span>\n<span class="line"><span>\t\t\t\tw.pool.taskLock.Unlock()</span></span>\n<span class="line"><span>\t\t\t\t// 将当前 worker 放回 workerPool 中，供之后复用</span></span>\n<span class="line"><span>\t\t\t\tw.Recycle()</span></span>\n<span class="line"><span>\t\t\t\treturn</span></span>\n<span class="line"><span>\t\t\t}</span></span>\n<span class="line"><span>\t\t\tw.pool.taskLock.Unlock()</span></span>\n<span class="line"><span>\t\t\tfunc() {</span></span>\n<span class="line"><span>\t\t\t\tdefer func() {</span></span>\n<span class="line"><span>\t\t\t\t   // 如果在执行 t.f 的过程中发生了异常，进行异常恢复或记录现场</span></span>\n<span class="line"><span>\t\t\t\t\tif r := recover(); r != nil {</span></span>\n<span class="line"><span>\t\t\t\t\t\tif w.pool.panicHandler != nil {</span></span>\n<span class="line"><span>\t\t\t\t\t\t\tw.pool.panicHandler(t.ctx, r)</span></span>\n<span class="line"><span>\t\t\t\t\t\t} else {</span></span>\n<span class="line"><span>\t\t\t\t\t\t\tmsg := fmt.Sprintf(&quot;GOPOOL: panic in pool: %s: %v: %s&quot;, w.pool.name, r, debug.Stack())</span></span>\n<span class="line"><span>\t\t\t\t\t\t\tlogger.CtxErrorf(t.ctx, msg)</span></span>\n<span class="line"><span>\t\t\t\t\t\t}</span></span>\n<span class="line"><span>\t\t\t\t\t}</span></span>\n<span class="line"><span>\t\t\t\t}()</span></span>\n<span class="line"><span>\t\t\t\t</span></span>\n<span class="line"><span>\t\t\t   // 执行 task 上的 func</span></span>\n<span class="line"><span>\t\t\t\tt.f()</span></span>\n<span class="line"><span>\t\t\t}()</span></span>\n<span class="line"><span>\t\t\t</span></span>\n<span class="line"><span>\t\t\t// 将 t 放回到 taskPool 中，供之后复用</span></span>\n<span class="line"><span>\t\t\tt.Recycle()</span></span>\n<span class="line"><span>\t\t}</span></span>\n<span class="line"><span>\t}()</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="sync-pool" tabindex="-1"><a class="header-anchor" href="#sync-pool"><span>sync.Pool</span></a></h3><p>频繁地分配、回收内存会给 GC 带来一定的负担，严重的时候会引起 CPU 的毛刺，而 sync.Pool 可以将暂时不用的对象缓存起来到一个池子中，待下次需要的时候直接使用，不用再次经过内存分配，可以减轻 GC 的压力，提升系统的性能。</p><p>使用 sync.Pool的步骤非常简单：</p><ol><li>声明需要缓存对象的 new 方法</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>var taskPool sync.Pool</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>func init() {</span></span>\n<span class="line"><span>\ttaskPool.New = newTask</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>func newTask() interface{} {</span></span>\n<span class="line"><span>\treturn &amp;task{}</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>使用 Get 方法来从缓存池中获取一个对象</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>t := taskPool.Get().(*task)</span></span>\n<span class="line"><span>t.ctx = ctx</span></span>\n<span class="line"><span>t.f = f</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>对象不再使用时，放回到缓存池中</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>func (t *task) zero() {</span></span>\n<span class="line"><span>\tt.ctx = nil</span></span>\n<span class="line"><span>\tt.f = nil</span></span>\n<span class="line"><span>\tt.next = nil</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>func (t *task) Recycle() {</span></span>\n<span class="line"><span>\tt.zero()</span></span>\n<span class="line"><span>\ttaskPool.Put(t)</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>以上逻辑就是 gopool 实现 goroutine 复用的核心逻辑。我们来总结下它的原理：</p><ol><li>当使用 gopool.Go 来执行用户传入的逻辑 func 时，这个 func 会被包装成为一个 task，添加到 defaultPool 的 task 链表中</li><li>task 由 defaultPool 中的 worker 来实际负责执行。</li><li>当满足以下两种情况之一时，会新建一个 worker，并立即执行 worker 的调度逻辑：</li></ol><ul><li>task 的数量比设置的阈值大，并且 p 的 worker 的数量小于 pool 的容量</li><li>p 的 worker 数量为 0</li></ul><ol start="4"><li>不满足上述条件时，现有 worker 会按照 FIFO 顺序依次执行 task 链表中的 task。</li><li>task 和 worker 实例都会通过 sync.Pool 来实现复用，减少内存分配，降低 GC 压力。</li></ol><p>下面用一个泳道图来展示 Gopool 的核心工作流程：</p>',46)),(0,i.bF)(a,{id:"mermaid-154",code:"eJx9UstOwkAU3fsVs8QFfAALNpq41cTEdYMDaaidWtq41ShSiYILBKKJQjTRmJjWDaAY+JlOGf7CmTulFKp00c7jnHtOz71lfGxjPY+3VaVoKkcbiD+GYlpqXjUU3UJbmor5J3G+S4iWPD0gZgmbyfN9pVzas7GN0QbcyarpXE6UySLmnU+bb6hIDL7N7JBUwdbzm4AUAI6LCmSRP6oji2/BAasPaKMFe0TdL/bZA1YETy80Jk368EgbLn254WLT+4sEK9SSeOpdImGDL87Yc8UffgP+H1MCDeWCwYjWutTx/BFf9GadJ+q0gQQvRbNC3J03qzZYv8Im1VnHoac/KHBaKGh3uUURxglECaSYpAxYhiAR8RhWOBK8NoL1KvTWpbWEFY0QgxsQvxdcvbLeNR2/T+tudB+TXspImpSJ+MOPeQeWeEuNm9sIfY8rUu5PYiQ4J0ksADOFlBymde64QtDshzPheNGIRUSsH64mG0tKsmVSwF90B1iC/QsE0V4O"})])}]]),p=JSON.parse('{"path":"/Backend/gopool.html","title":"Gopool 实现分析","lang":"en-US","frontmatter":{"category":"Backend","tags":["源码分析"]},"git":{"createdTime":1742112620000,"updatedTime":1742112620000,"contributors":[{"name":"Tamarous","username":"Tamarous","email":"hiwangzewei@qq.com","commits":1,"url":"https://github.com/Tamarous"}]},"readingTime":{"minutes":4.84,"words":1453},"filePathRelative":"Backend/gopool.md","localizedDate":"March 16, 2025","excerpt":"\\n<p>Gopool 是字节跳动开源项目 <a href=\\"https://github.com/bytedance/gopkg\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">gopkg</a> 中的一个小工具，作用是以池化的思想来实现 goroutine 的复用，限制应用中 goutine 数量的无限增长。</p>\\n<h2>使用介绍</h2>\\n<p>Gopool 使用起来非常简单，只需要将项目中的 go 关键字替换为 gopool.Go：</p>\\n<div class=\\"language-go line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"go\\" data-title=\\"go\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">go</span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\"> func</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">() {</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic\\">\\t// do your job</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">}()</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>"}')}}]);