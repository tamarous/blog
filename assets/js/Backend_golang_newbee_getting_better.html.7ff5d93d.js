"use strict";(self.webpackChunktamarous_blog=self.webpackChunktamarous_blog||[]).push([[9256],{5071:(n,s,a)=>{a.r(s),a.d(s,{comp:()=>l,data:()=>p});var i=a(641);const e={},l=(0,a(6262).A)(e,[["render",function(n,s){return(0,i.uX)(),(0,i.CE)("div",null,s[0]||(s[0]=[(0,i.Fv)('<h1 id="go-语言精进之路学习笔记" tabindex="-1"><a class="header-anchor" href="#go-语言精进之路学习笔记"><span>Go 语言精进之路学习笔记</span></a></h1><h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h2><p>《Go 语言精进之路》这本书真的非常好，深入讲解了 Go 语言的方方面面，是入门的不二之选。本文是在学习《Go 语言精进之路》时所做的一些摘要和记录。</p><h2 id="理解-go-语言的设计哲学" tabindex="-1"><a class="header-anchor" href="#理解-go-语言的设计哲学"><span>理解 GO 语言的设计哲学</span></a></h2><ul><li>追求简单，少即是多</li><li>偏好组合，正交耦合</li><li>原生并发，轻量高效</li><li>面向工程，自带电池</li></ul><p>Go 特点：</p><ul><li>语法简洁，只有 25 个关键字</li><li>内置垃圾收集，降低内存管理心智负担</li><li>没有头文件</li><li>显式依赖</li><li>没有循环依赖</li><li>常量只是数字</li><li>首字母大小写决定可见性</li><li>任何类型都可以拥有方法</li><li>没有子类型继承</li><li>没有算数转换</li><li>接口是隐式的</li><li>方法就是函数</li><li>接口只是方法集合</li><li>方法仅按照名称匹配</li><li>没有构造或析构函数</li><li>赋值不是表达式</li><li>没有指针算数</li><li>内存总是初始化为零值</li><li>没有类型注解语法</li><li>没有模板或泛型</li><li>没有异常</li><li>内置字符串、切片、map 类型</li><li>内置数据边界检查</li><li>内置并发支持</li><li>……</li></ul><h2 id="使用一致的变量声明形式" tabindex="-1"><a class="header-anchor" href="#使用一致的变量声明形式"><span>使用一致的变量声明形式</span></a></h2><h3 id="包级变量" tabindex="-1"><a class="header-anchor" href="#包级变量"><span>包级变量</span></a></h3><p>只能使用带有 var 关键字的变量声明形式</p><ol><li>声明并同时显式初始化</li><li>声明并延迟初始化</li><li>声明聚类与就近原则</li></ol><ul><li>延迟初始化的变量放在一个 var 块</li><li>声明并显式初始化的变量放在另一个 var 块</li><li>尽可能在第一次使用变量的位置去声明该变量</li></ul><h3 id="局部变量" tabindex="-1"><a class="header-anchor" href="#局部变量"><span>局部变量</span></a></h3><ol><li>对于延迟初始化的局部变量声明，采用带有 var 关键字的声明形式</li><li>对于声明且显式初始化的局部变量，建议使用短变量声明形式</li><li>尽量在分支控制时应用短变量声明形式</li></ol><h2 id="使用无类型常量简化代码" tabindex="-1"><a class="header-anchor" href="#使用无类型常量简化代码"><span>使用无类型常量简化代码</span></a></h2><p>无类型变量在参与变量赋值和计算过程时，无需显式类型转换，从而能够简化代码</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>const (</span></span>\n<span class="line"><span>    SeekStart = 0</span></span>\n<span class="line"><span>    SeekCurrent = 1</span></span>\n<span class="line"><span>    SeekEnd = 2</span></span>\n<span class="line"><span>)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="使用-iota-实现枚举常量" tabindex="-1"><a class="header-anchor" href="#使用-iota-实现枚举常量"><span>使用 iota 实现枚举常量</span></a></h2><p>Go 的 const 提供了隐式重复前一个非空表达式的机制，如</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>const {</span></span>\n<span class="line"><span>    Apple, Banana = 11, 22</span></span>\n<span class="line"><span>    Strawberry, Grape</span></span>\n<span class="line"><span>    Pear, Watermelon</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>等价于</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>const {</span></span>\n<span class="line"><span>    Apple, Banana = 11, 22</span></span>\n<span class="line"><span>    Strawberry, Grape = 11, 22</span></span>\n<span class="line"><span>    Pear, Watermelon = 11, 22</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Itoa 是 Go 中一个预定义标识符，表示的是 const 声明块中每个常量所处位置在块中的偏移量。同时 itoa 也是一个无类型常量，可以向无类型常量那样自动参与不同类型的求值过程，而不需要进行显式类型转换。</p><p>用法：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>const {</span></span>\n<span class="line"><span>    _ = itoa   </span></span>\n<span class="line"><span>    IVP6_ONLY   // 1 </span></span>\n<span class="line"><span>    SOMAXCONN   // 2</span></span>\n<span class="line"><span>    SO_ERROR    // 3</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="尽量定义零值可用的类型" tabindex="-1"><a class="header-anchor" href="#尽量定义零值可用的类型"><span>尽量定义零值可用的类型</span></a></h2><p>当通过声明或调用 new 为变量分配存储空间，或者通过复合文字字面量或调用 make 创建新值，且不提供显式初始化时，Go 会为变量或者值提供默认值。此外，零值初始是递归的，也就是数组、结构体等类型的零值初始化就是对其组成元素逐一进行零值初始化。</p><p>零值可用：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>var zeroSlice []int</span></span>\n<span class="line"><span>zeroSlice = append(zeroSlice, 1)</span></span>\n<span class="line"><span>zeroSlice = append(zeroSlice, 2)</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>var mu sync.Mutex</span></span>\n<span class="line"><span>mu.Lock()</span></span>\n<span class="line"><span>mu.Unlock()</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：并不是所有类型都是零值可用，有几点注意事项：</p><ol><li>在 append 场景下，零值可用的切片不能通过下标操作数据</li><li><strong>Map 这种原生类型没有提供零值可用支持</strong></li><li>零值可用类型要尽量避免值复制</li></ol><h2 id="使用复合字面值作为初值构造器" tabindex="-1"><a class="header-anchor" href="#使用复合字面值作为初值构造器"><span>使用复合字面值作为初值构造器</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>a := [5]int{1,2,3,4,5}</span></span>\n<span class="line"><span>b := []int{1,2,3,4,5}</span></span>\n<span class="line"><span>m := map[int]string {1:&quot;hello&quot;,2:&quot;world&quot;}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="结构体复合字面值" tabindex="-1"><a class="header-anchor" href="#结构体复合字面值"><span>结构体复合字面值</span></a></h3><p>Go 推荐使用 field: value 的复合字面值形式对 struct 类型变量进行值构造</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>type pipe struct {</span></span>\n<span class="line"><span>        wrMu sync.Mutex // Serialize Write operations</span></span>\n<span class="line"><span>        wrCh chan []byte</span></span>\n<span class="line"><span>        rdCh chan int</span></span>\n<span class="line"><span>        </span></span>\n<span class="line"><span>        once       sync.Once // Protects closing localDone</span></span>\n<span class="line"><span>        done  chan struct{}</span></span>\n<span class="line"><span>        rerr onceError</span></span>\n<span class="line"><span>        werr onceError</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>func Pipe() (* PipeReader, * PipeWriter) {</span></span>\n<span class="line"><span>        </span></span>\n<span class="line"><span>        p := &amp;pipe{</span></span>\n<span class="line"><span>            wrCh: make(chan []byte),</span></span>\n<span class="line"><span>            rdCh: make(chan int),</span></span>\n<span class="line"><span>            done: make(chan struct{}),</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>        </span></span>\n<span class="line"><span>        return &amp;PipeReader{p}, &amp;PipeWriter{p}</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>复合字面值使得即便是类型零值，我们也会使用字面值构造器形式：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>s := myStruct{}     // 常用</span></span>\n<span class="line"><span>s := new(myStruct)  // 不常用</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="数组-切面复合字面值" tabindex="-1"><a class="header-anchor" href="#数组-切面复合字面值"><span>数组/切面复合字面值</span></a></h3><p>使用下标 idx 作为 filed: value 中的 field，例</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>s := [5]int{0: -10, 1:2, 2:3, 3:4, 4:5}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="map-复合字面值" tabindex="-1"><a class="header-anchor" href="#map-复合字面值"><span>Map 复合字面值</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>var unitMap = map[string]int64 {</span></span>\n<span class="line"><span>    &quot;ns&quot;: int64(Nanosecond),</span></span>\n<span class="line"><span>    &quot;us&quot;: int64(Microsecond),</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="了解切片实现原理并高效使用" tabindex="-1"><a class="header-anchor" href="#了解切片实现原理并高效使用"><span>了解切片实现原理并高效使用</span></a></h2><h3 id="切片究竟是什么" tabindex="-1"><a class="header-anchor" href="#切片究竟是什么"><span>切片究竟是什么</span></a></h3><p>切片之于数组就像是文件描述符之于文件。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>type slice struct {</span></span>\n<span class="line"><span>    array unsafe.Pointer   // 指向底层数组元素的指针</span></span>\n<span class="line"><span>    len int                // 切片长度</span></span>\n<span class="line"><span>    cap int                // 切片的最大容量</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7a0ca4bd9c540229dc1ada6bb7bd255~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3028&amp;h=1462&amp;s=356830&amp;e=png&amp;a=1&amp;b=fbfbfb" alt="image.png"></p><p>创建切面： s := make([]byte, 5)</p><p>创建对数组的切面：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>u := [10]byte{1,2,3,4,5,6,7,8,9,10}</span></span>\n<span class="line"><span>s := u[3:7]</span></span>\n<span class="line"><span>s.cap = 7, s.len = 4</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于同一个数组，可以创建多个切面，对每个切面的修改，都会反映到其它切面上，因为他们的底层是同一个数组</p><h3 id="动态扩容" tabindex="-1"><a class="header-anchor" href="#动态扩容"><span>动态扩容</span></a></h3><p>Append 会根据切片需要，在当前数组容量无法满足的情况下，动态分配新的数组，新数组长度按照一定算法扩展。新数组建立后，append 会将旧数组中的元素复制到新数组中，之后旧数组会被垃圾回收掉。这样通过数组切面化创建的切面，在切面 cap 触碰到数组的上界，再对切片进行 append 操作，切片就会和原来的数组解除绑定关系</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>func growslice(et *_type, old slice, cap int) slice {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        newcap := old.cap</span></span>\n<span class="line"><span>        doublecap := newcap + newcap</span></span>\n<span class="line"><span>        if cap &gt; doublecap {</span></span>\n<span class="line"><span>                newcap = cap</span></span>\n<span class="line"><span>        } else {</span></span>\n<span class="line"><span>                const threshold = 256</span></span>\n<span class="line"><span>                if old.cap &lt; threshold {</span></span>\n<span class="line"><span>                        newcap = doublecap</span></span>\n<span class="line"><span>                } else {</span></span>\n<span class="line"><span>                        // Check 0 &lt; newcap to detect overflow</span></span>\n<span class="line"><span>                        // and prevent an infinite loop.</span></span>\n<span class="line"><span>                        for 0 &lt; newcap &amp;&amp; newcap &lt; cap {</span></span>\n<span class="line"><span>                                // Transition from growing 2x for small slices</span></span>\n<span class="line"><span>                                // to growing 1.25x for large slices. This formula</span></span>\n<span class="line"><span>                                // gives a smooth-ish transition between the two.</span></span>\n<span class="line"><span>                                newcap += (newcap + 3*threshold) / 4</span></span>\n<span class="line"><span>                        }</span></span>\n<span class="line"><span>                        // Set newcap to the requested cap when</span></span>\n<span class="line"><span>                        // the newcap calculation overflowed.</span></span>\n<span class="line"><span>                        if newcap &lt;= 0 {</span></span>\n<span class="line"><span>                                newcap = cap</span></span>\n<span class="line"><span>                        }</span></span>\n<span class="line"><span>                }</span></span>\n<span class="line"><span>        }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="尽量使用-cap-参数创建切片" tabindex="-1"><a class="header-anchor" href="#尽量使用-cap-参数创建切片"><span>尽量使用 cap 参数创建切片</span></a></h3><p>避免频繁重新创建底层数组及拷贝元素</p><h2 id="了解-map-实现原理并高效使用" tabindex="-1"><a class="header-anchor" href="#了解-map-实现原理并高效使用"><span>了解 map 实现原理并高效使用</span></a></h2><h3 id="了解-map" tabindex="-1"><a class="header-anchor" href="#了解-map"><span>了解 map</span></a></h3><ol><li>map 类型不支持零值可用，未显式赋初值的 map 类型变量的零值为 nil，对于处零值状态的 map 变量进行操作将会导致运行时 panic</li><li>总是使用 comma, ok 惯用法来读取 map 中的值。即使要删除的 key 在 map 中不存在，也不会 panic</li><li>遍历 map 的顺序不可信赖</li><li>Map 实例不是并发写安全的，不支持并发读写</li><li>尽量使用 cap 参数来创建 map，避免频繁扩容导致的性能损耗</li></ol><h3 id="map-的内部实现" tabindex="-1"><a class="header-anchor" href="#map-的内部实现"><span>map 的内部实现</span></a></h3><p>Go 运行时使用一张哈希表来实现抽象的 map 类型</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/035a7f2272b949e388ad2fa7893e21f1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2508&amp;h=2004&amp;s=1357227&amp;e=png&amp;b=fafafa" alt="image.png"></p><ul><li>count：当前 map 中的元素个数；对 map 类型变量运用 len 内置函数时，len 函数返回的就是 count 这个值。</li><li>flags：当前 map 所处的状态标志，目前定义了 4 个状态值 ——iterator、oldIterator、hashWriting 和 sameSizeGrow。</li><li>B：B 的值是 bucket 数量的以 2 为底的对数，即 2^B = bucket 数量。</li><li>noverflow：overflow bucket 的大约数量。</li><li>hash0：哈希函数的种子值。</li><li>buckets：指向 bucket 数组的指针。</li><li>oldbuckets：在 map 扩容阶段指向前一个 bucket 数组的指针。</li><li>nevacuate：在 map 扩容阶段充当扩容进度计数器。所有下标号小于 nevacuate 的 bucket 都已经完成了数据排空和迁移操作。</li><li>extra：可选字段。如果有 overflow bucket 存在，且 key、value 都因不包含指针而被内联（inline）的情况下，该字段将存储所有指向 overflow bucket 的指针，保证 overflow bucket 是始终可用的（不被垃圾回收掉）。</li><li>真正用来存储键值对数据的是 bucket（桶），每个 bucket 中存储的是 Hash 值低 bit 位数值相同的元素，默认的元素个数为 BUCKETSIZE=8。当某个 bucket 的 8 个空槽（slot）都已填满且 map 尚未达到扩容条件时，运行时会建立 overflow bucket，并将该 overflow bucket 挂在上面 bucket 末尾的 overflow 指针上，这样两个 bucket 形成了一个链表结构，该结构的存在将持续到下一次 map 扩容。</li></ul><p>hashcode:</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71c93a1bc7ce41768b844cc8f7c69238~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2508&amp;h=1470&amp;s=1067156&amp;e=png&amp;b=f8f8f8" alt="image.png"></p><p>Go 运行时的 map 实现中引入了一个 LoadFactor（负载因子），当count &gt; LoadFactor * 2^B 或 overflow bucket 过多时，运行时会对 map 进行扩容，并重新在 bucket 间均衡分配数据。</p><h2 id="了解-string-实现原理并高效使用" tabindex="-1"><a class="header-anchor" href="#了解-string-实现原理并高效使用"><span>了解 string 实现原理并高效使用</span></a></h2><p>Go 中 string 的特点：</p><ul><li>string 类型的数据是不可变的</li><li>零值可用</li><li>获取长度的时间复杂度是O(1)级别</li><li>支持通过+/+=操作符进行字符串连接</li><li>支持各种比较关系操作符：==、!= 、&gt;=、&lt;=、&gt;和&lt;</li></ul><p>string 的内部表示：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// $GOROOT/src/runtime/string.go </span></span>\n<span class="line"><span>type stringStruct struct { </span></span>\n<span class="line"><span>    str unsafe.Pointer </span></span>\n<span class="line"><span>    len int</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de6394a601574b97bb6645f9385e3fd9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2482&amp;h=2296&amp;s=695250&amp;e=png&amp;a=1&amp;b=fdfdfd" alt="image.png"></p><h3 id="string-的高效构造" tabindex="-1"><a class="header-anchor" href="#string-的高效构造"><span>string 的高效构造</span></a></h3><p>除了 +，Go还提供了其他一些构造字符串的方法，如</p><ul><li>使用 fmt.Sprintf；</li><li>使用 strings.Join；</li><li>使用 strings.Builder；</li><li>使用 bytes.Buffer。</li></ul><p>基准测试结果：</p><ul><li>做了预初始化的 strings.Builder 连接构建字符串效率最高；</li><li>带有预初始化的 bytes.Buffer 和 strings.Join 这两种方法效率十分接近，分列二三位；</li><li>未做预初始化的 strings.Builder、bytes.Buffer 和操作符连接在第三档次；</li><li>fmt.Sprintf 性能最差，排在末尾。</li></ul><p>由此可以得出一些结论：</p><ul><li>在能预估出最终字符串长度的情况下，使用预初始化的strings.Builder连接构建字符串效率最高；</li><li>strings.Join连接构建字符串的平均性能最稳定，如果输入的多个字符串是以[]string承载的，那么strings.Join也是不错的选择；</li><li>使用操作符连接的方式最直观、最自然，在编译器知晓欲连接的字符串个数的情况下，使用此种方式可以得到编译器的优化处理；</li><li>fmt.Sprintf虽然效率不高，但也不是一无是处，如果是由多种不同类型变量来构建特定格式的字符串，那么这种方式还是最适合的。</li></ul><h2 id="理解-go-语言的包导入" tabindex="-1"><a class="header-anchor" href="#理解-go-语言的包导入"><span>理解 Go 语言的包导入</span></a></h2><ol><li>Go 编译器在编译过程中必然要使用的是编译单元所依赖的包的源码</li><li>Go 源码文件头部的包导入语句中 import 后面的部分是一个路径，路径的最后一个分段是目录名，而不是包名</li><li>Go 编译器的包源码搜索路径由基本搜索路径和包导入路径组成，两者结合在一起后，编译器便可以确定一个包的所有依赖包的源码路径的集合</li><li>同一源码文件的依赖包在同一源码搜索路径空间下的包名冲突问题可以由显式指定包名的方式解决</li></ol><h2 id="理解-go-表达式的求值顺序" tabindex="-1"><a class="header-anchor" href="#理解-go-表达式的求值顺序"><span>理解 Go 表达式的求值顺序</span></a></h2><ol><li>包级别变量声明语句中的表达式求值顺序由变量的声明顺序和初始化依赖关系决定，并且包级变量表达式求值顺序优先级最高</li><li>表达式操作数中的函数、方法及 channel 操作按照普通求值顺序，即从左到右的顺序依次进行</li><li>赋值语句求值分为两个阶段：先按照普通求值规则对等号左边的下标表达式、指针解引用表达式和等号右边的表达式中的操作数进行求值，然后按照从左到右的顺序对变量进行赋值</li><li>重点关注 switch-case 和 select-case 语句中的表达式惰性求值的规则</li></ol><h2 id="理解-go-语言代码块和作用域" tabindex="-1"><a class="header-anchor" href="#理解-go-语言代码块和作用域"><span>理解 Go 语言代码块和作用域</span></a></h2><h2 id="理解-go-语言控制语句惯用法和使用注意事项" tabindex="-1"><a class="header-anchor" href="#理解-go-语言控制语句惯用法和使用注意事项"><span>理解 Go 语言控制语句惯用法和使用注意事项</span></a></h2><h3 id="使用-if-语句时遵循快乐路径原则" tabindex="-1"><a class="header-anchor" href="#使用-if-语句时遵循快乐路径原则"><span>使用 if 语句时遵循快乐路径原则</span></a></h3><ul><li>出现错误时，快速返回</li><li>成功逻辑不要嵌入if-else中</li></ul><h3 id="for-range-循环" tabindex="-1"><a class="header-anchor" href="#for-range-循环"><span>for range 循环</span></a></h3><ol><li>小心 for range 的循环变量重用</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>func main() {</span></span>\n<span class="line"><span>   var m = []int{1, 2, 3, 4, 5}</span></span>\n<span class="line"><span>   for i, v := range m {</span></span>\n<span class="line"><span>      go func() {</span></span>\n<span class="line"><span>         fmt.Println(i, v)</span></span>\n<span class="line"><span>      }()</span></span>\n<span class="line"><span>   }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>   time.Sleep(time.Second * 5)</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>➜  LearnGo go run main.go  </span></span>\n<span class="line"><span>4 5</span></span>\n<span class="line"><span>4 5</span></span>\n<span class="line"><span>4 5</span></span>\n<span class="line"><span>4 5</span></span>\n<span class="line"><span>4 5</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>=&gt;</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>func main() {</span></span>\n<span class="line"><span>   var m = []int{1, 2, 3, 4, 5}</span></span>\n<span class="line"><span>   for i, v := range m {</span></span>\n<span class="line"><span>      go func(i, v int) {</span></span>\n<span class="line"><span>         fmt.Println(i, v)</span></span>\n<span class="line"><span>      }(i, v)</span></span>\n<span class="line"><span>   }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>   time.Sleep(time.Second * 5)</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>➜  LearnGo go run main.go  </span></span>\n<span class="line"><span>0 1</span></span>\n<span class="line"><span>4 5</span></span>\n<span class="line"><span>3 4</span></span>\n<span class="line"><span>2 3</span></span>\n<span class="line"><span>1 2</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>注意参加迭代的是 range 表达式的副本</li><li>String 类型迭代时，每次循环的单位是一个 rune，而不是一个 byte</li><li>Map 类型迭代时，会得到一个 map 内部表示的副本，由于内部表示其实是一个 hmap 描述符结构的指针，因此对副本 map 的操作等同于对源 map 的操作</li><li>Channel 在迭代时，也会创建一个 channel 的指针副本，指向原 channel；for range 会以阻塞读的方式阻塞在 channel 表达式上；当 channel 中无数据时，也会阻塞，直到 channel 关闭。</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>var c chan int</span></span>\n<span class="line"><span>for v := range c {</span></span>\n<span class="line"><span>    fmt.Println(v)</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>将永远阻塞在这个 nil channel 上，直到 go panic</p><h3 id="明确-break-和-continue-执行后的真实目的地" tabindex="-1"><a class="header-anchor" href="#明确-break-和-continue-执行后的真实目的地"><span>明确 break 和 continue 执行后的真实目的地</span></a></h3><p>Break 语句结束执行并跳出的是同一函数内 break 语句所在的最内层的 for switch select 的执行。可以使用 break label来实现定向跳转。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>func main() {</span></span>\n<span class="line"><span>    exit := make(chan interface{})</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    go func() {</span></span>\n<span class="line"><span>    loop:</span></span>\n<span class="line"><span>        for {</span></span>\n<span class="line"><span>            select {</span></span>\n<span class="line"><span>            case &lt;-time.After(time.Second):</span></span>\n<span class="line"><span>                fmt.Println(&quot;tick&quot;)</span></span>\n<span class="line"><span>            case &lt;-exit:</span></span>\n<span class="line"><span>                fmt.Println(&quot;exiting...&quot;)</span></span>\n<span class="line"><span>                break loop</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>        fmt.Println(&quot;exit!&quot;)</span></span>\n<span class="line"><span>    }()</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    time.Sleep(3 * time.Second)</span></span>\n<span class="line"><span>    exit &lt;- struct{}{}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    // 等待子goroutine退出</span></span>\n<span class="line"><span>    time.Sleep(3 * time.Second)</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="尽量使用-case-替换-fallthrough" tabindex="-1"><a class="header-anchor" href="#尽量使用-case-替换-fallthrough"><span>尽量使用 case 替换 fallthrough</span></a></h3><h2 id="在-init-函数中检查包级变量的初始状态" tabindex="-1"><a class="header-anchor" href="#在-init-函数中检查包级变量的初始状态"><span>在 init 函数中检查包级变量的初始状态</span></a></h2><h3 id="init-函数" tabindex="-1"><a class="header-anchor" href="#init-函数"><span>Init 函数</span></a></h3><p>如果一个包定义了 init 函数，Go 运行时会负责在该包初始化时候调用它的 init 函数。一个Go 包可以拥有多个 init 函数，每个源文件中可以定义多个 init 函数。在初始化时，Go 运行时会按照一定次序逐一调用该包的 init 函数。Go 会保证 init 函数的调用是按照一定顺序依次执行的，不会并发执行，每个 init 函数一定只会执行一次。</p><p>多个文件中的 init 函数按照文件编译顺序依次执行，同一个文件中的 init 函数按照声明顺序依次执行。因此，不要依赖 init 函数的执行顺序。</p><h3 id="init-函数的作用" tabindex="-1"><a class="header-anchor" href="#init-函数的作用"><span>Init 函数的作用</span></a></h3><p>适合做包级数据的初始化及初始状态检查工作</p><h3 id="使用-init-函数检查包级变量的初始状态" tabindex="-1"><a class="header-anchor" href="#使用-init-函数检查包级变量的初始状态"><span>使用 init 函数检查包级变量的初始状态</span></a></h3><ol><li>重置包级变量值</li><li>对包级变量进行初始化，保证其后续可用</li><li>Init 函数中的注册模式</li><li>Init 函数中检查失败的处理方法：建议直接让程序 panic，快速退出</li></ol><h2 id="让自己习惯于函数是一等公民" tabindex="-1"><a class="header-anchor" href="#让自己习惯于函数是一等公民"><span>让自己习惯于函数是一等公民</span></a></h2><p>Go 中的函数可以像普通整型值那样被创建和使用</p><h3 id="函数的特殊运用" tabindex="-1"><a class="header-anchor" href="#函数的特殊运用"><span>函数的特殊运用</span></a></h3><p>进行显式类型转换</p><p>我们想将 MyAdd 方法赋值给 BinaryAdd 接口，直接赋值不行，我们就需要一个自定义类，这个自定义类的声明和原方法一致，然后让这个类型实现 BinaryAdd 接口。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>type BinaryAddr interface {</span></span>\n<span class="line"><span>    Add(int, int) int</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>func MyAdd(x, y int) int {</span></span>\n<span class="line"><span>    return x + y</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>func main() {</span></span>\n<span class="line"><span>    var i BinaryAddr = MyAddrFunc(MyAdd)</span></span>\n<span class="line"><span>    fmt.Println(i.Add(5,6))</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>type MyAdderFunc func(int, int) int</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>func (f MyAdderFunc) Add(x, y int) int {</span></span>\n<span class="line"><span>    return f(x, y)</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="使用-defer-让函数更简洁、更健壮" tabindex="-1"><a class="header-anchor" href="#使用-defer-让函数更简洁、更健壮"><span>使用 defer 让函数更简洁、更健壮</span></a></h2><h3 id="运作机制" tabindex="-1"><a class="header-anchor" href="#运作机制"><span>运作机制</span></a></h3><ol><li>在 Go 中，只有在函数和方法内部才能使用 defer</li><li>defer 关键字后面只能接函数或方法，这些函数被称为 deferred 函数，defer 将他们注册在其所在 goroutine 用于存放 defer 函数的栈数据结构中，在执行 defer 的函数退出前，按照后进先出的顺序依次执行</li></ol><h3 id="常见用法" tabindex="-1"><a class="header-anchor" href="#常见用法"><span>常见用法</span></a></h3><ol><li>拦截 panic</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>func makeSlice(n int) []byte {</span></span>\n<span class="line"><span>    defer func() {</span></span>\n<span class="line"><span>        if recover() != nil {</span></span>\n<span class="line"><span>            panic(ErrTooLarge)</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }()</span></span>\n<span class="line"><span>    </span></span>\n<span class="line"><span>    return make([]byte, n)</span></span>\n<span class="line"><span> }</span></span>\n<span class="line"><span> // </span></span>\n<span class="line"><span> func bar() {</span></span>\n<span class="line"><span>     panic(-1)</span></span>\n<span class="line"><span> }</span></span>\n<span class="line"><span> </span></span>\n<span class="line"><span> func foo() {</span></span>\n<span class="line"><span>     defer func() {</span></span>\n<span class="line"><span>         if e := recover(); e != nil {</span></span>\n<span class="line"><span>         }</span></span>\n<span class="line"><span>     }()</span></span>\n<span class="line"><span>     bar()</span></span>\n<span class="line"><span> }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>defer 在出现 panic 的时候仍然能够被调度执行</p><ol start="2"><li>修改函数的具名返回值</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>func foo(a, b int) (x, y int) {</span></span>\n<span class="line"><span>    defer func() {</span></span>\n<span class="line"><span>        x = x * 5</span></span>\n<span class="line"><span>        y = y * 10</span></span>\n<span class="line"><span>    }()</span></span>\n<span class="line"><span>    </span></span>\n<span class="line"><span>    x = a + 5</span></span>\n<span class="line"><span>    y = b + 6</span></span>\n<span class="line"><span>    return</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>输出调试信息</li><li>还原变量旧值</li></ol><h3 id="关于-defer-的几个问题" tabindex="-1"><a class="header-anchor" href="#关于-defer-的几个问题"><span>关于 defer 的几个问题</span></a></h3><ol><li>明确哪些函数可以作为 deferred 函数</li></ol><p>对于有返回值的自定义函数或者方法，返回值会在 defer 函数被调度执行的时候自动被丢弃。</p><ol start="2"><li>掌握 defer 关键字后表达式的求值时机</li></ol><p>Defer 关键字后面的表达式是将 deferred 函数注册到 deferred 函数栈的时候进行求值的。</p><ol start="3"><li>知晓 defer 带来的性能损耗</li></ol><h2 id="理解方法的本质以选择正确的-receiver-类型" tabindex="-1"><a class="header-anchor" href="#理解方法的本质以选择正确的-receiver-类型"><span>理解方法的本质以选择正确的 receiver 类型</span></a></h2><p>Go 方法的一般声明形式：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>func (receiver T/*T) MethodName(param list) (return list) {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Go 方法的特点：</p><ol><li>方法的首字母是否大写决定了该方法是不是导出方法</li><li>方法定义要与类型声明放在同一个包里。因此，不能为原生类型添加方法，只能为自定义类型添加方法。</li></ol><p>Go 方法的本质：一个以方法所绑定类型实例为第一个参数的普通函数。</p><h2 id="方法集合决定接口实现" tabindex="-1"><a class="header-anchor" href="#方法集合决定接口实现"><span>方法集合决定接口实现</span></a></h2><ol><li><p>对于非接口类型的自定义类型 T，其方法集合由所有 receiver 为 T 类型的方法组成；而类型为 * T 的方法集合则包含所有 receiver 为 T 和 T * 类型的方法。</p></li><li><p>类型嵌入：</p></li></ol><ul><li><p>接口类型中嵌入接口类型：嵌入其他接口类型而创建的新接口类型的方法集合包含了被嵌入接口类型的方法集合</p></li><li><p>结构体类型中嵌入接口类型：在结构体类型中嵌入接口类型后，该结构体类型的方法集合中将包含被嵌入接口类型的方法集合</p></li><li><p>结构体类型中嵌入结构体类型：在结构体类型中嵌入结构体类型为 Gopher 提供了一种实现 “继承” 的手段，外部的结构体类型 T 可以 “继承” 嵌入的结构体类型的所有方法的实现，并且无论是 T 类型的变量实例还是 T 指针类型变量实例，都可以调用所有 “继承” 的方法</p></li></ul><ol start="3"><li>Define 类型</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>type MyInterface I</span></span>\n<span class="line"><span>type Mystruct T</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>基于接口类型创建的defined类型与原接口类型的方法集合是一致的</li><li>基于自定义非接口类型创建的 defined 类型则并没有 “继承” 原类型的方法集合，新的 defined 类型的方法集合是空的。方法集合决定接口实现。基于自定义非接口类型的 defined 类型的方法集合为空，这决定了即便原类型实现了某些接口，基于其创建的 defined 类型也没有 “继承” 这一隐式关联。新 defined 类型要想实现那些接口，仍需重新实现接口的所有方法。</li></ul><ol start="4"><li>类型别名</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>type T1 = T</span></span>\n<span class="line"><span>type Interface1 = Interface</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>类型别名与原类型拥有完全相同的方法集合，无论原类型是接口类型还是非接口类型。</p><h2 id="了解变长参数函数的妙用" tabindex="-1"><a class="header-anchor" href="#了解变长参数函数的妙用"><span>了解变长参数函数的妙用</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>func Println(a ...interface{}) (n int, err error)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>变长参数函数只能有一个“...T”类型形式参数，并且该形式参数应该为函数参数列表中的最后一个形式参数</li><li>变长参数函数的“...T”类型形式参数在函数体内呈现为[]T类型的变量，我们可以将其理解为一个Go语法糖：</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// chapter4/sources/variadic_function_1.go</span></span>\n<span class="line"><span>func sum(args ...int) int {</span></span>\n<span class="line"><span>    var total int</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    // 下面的args的类型为[]int</span></span>\n<span class="line"><span>    for _, v := range args {</span></span>\n<span class="line"><span>        total += v</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    return total</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>参数函数可以在有限情况下模拟函数重载、可选参数和默认参数</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// chapter4/sources/variadic_function_5.go</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>func concat(sep string, args ...interface{}) string {</span></span>\n<span class="line"><span>    var result string</span></span>\n<span class="line"><span>    for i, v := range args {</span></span>\n<span class="line"><span>        if i != 0 {</span></span>\n<span class="line"><span>            result += sep</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>        switch v.(type) {</span></span>\n<span class="line"><span>        case int, int8, int16, int32, int64,</span></span>\n<span class="line"><span>            uint, uint8, uint16, uint32, uint64:</span></span>\n<span class="line"><span>            result += fmt.Sprintf(&quot;%d&quot;, v)</span></span>\n<span class="line"><span>        case string:</span></span>\n<span class="line"><span>            result += fmt.Sprintf(&quot;%s&quot;, v)</span></span>\n<span class="line"><span>        case []int:</span></span>\n<span class="line"><span>            ints := v.([]int)</span></span>\n<span class="line"><span>            for i, v := range ints {</span></span>\n<span class="line"><span>                if i != 0 {</span></span>\n<span class="line"><span>                    result += sep</span></span>\n<span class="line"><span>                }</span></span>\n<span class="line"><span>                result += fmt.Sprintf(&quot;%d&quot;, v)</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span>        case []string:</span></span>\n<span class="line"><span>            strs := v.([]string)</span></span>\n<span class="line"><span>            result += strings.Join(strs, sep)</span></span>\n<span class="line"><span>        default:</span></span>\n<span class="line"><span>            fmt.Printf(&quot;the argument type [%T] is not supported&quot;, v)</span></span>\n<span class="line"><span>            return &quot;&quot;</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>    return result</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>func main() {</span></span>\n<span class="line"><span>    println(concat(&quot;-&quot;, 1, 2))</span></span>\n<span class="line"><span>    println(concat(&quot;-&quot;, &quot;hello&quot;, &quot;gopher&quot;))</span></span>\n<span class="line"><span>    println(concat(&quot;-&quot;, &quot;hello&quot;, 1, uint32(2),</span></span>\n<span class="line"><span>        []int{11, 12, 13}, 17,</span></span>\n<span class="line"><span>        []string{&quot;robot&quot;, &quot;ai&quot;, &quot;ml&quot;},</span></span>\n<span class="line"><span>        &quot;hacker&quot;, 33))</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>变长参数函数实现功能选项模式</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// chapter4/sources/variadic_function_9.go</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>type FinishedHouse struct {</span></span>\n<span class="line"><span>    style                  int    // 0: Chinese; 1: American; 2: European</span></span>\n<span class="line"><span>    centralAirConditioning bool   // true或false</span></span>\n<span class="line"><span>    floorMaterial          string  // &quot;ground-tile&quot;或&quot;wood&quot;</span></span>\n<span class="line"><span>    wallMaterial           string // &quot;latex&quot;或&quot;paper&quot;或&quot;diatom-mud&quot;</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>type Option func(*FinishedHouse)</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>func NewFinishedHouse(options ...Option) *FinishedHouse {</span></span>\n<span class="line"><span>    h := &amp;FinishedHouse{</span></span>\n<span class="line"><span>        // default options</span></span>\n<span class="line"><span>        style:                  0,</span></span>\n<span class="line"><span>        centralAirConditioning: true,</span></span>\n<span class="line"><span>        floorMaterial:          &quot;wood&quot;,</span></span>\n<span class="line"><span>        wallMaterial:           &quot;paper&quot;,</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    for _, option := range options {</span></span>\n<span class="line"><span>        option(h)</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    return h</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>func WithStyle(style int) Option {</span></span>\n<span class="line"><span>    return func(h *FinishedHouse) {</span></span>\n<span class="line"><span>        h.style = style</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>func WithFloorMaterial(material string) Option {</span></span>\n<span class="line"><span>    return func(h *FinishedHouse) {</span></span>\n<span class="line"><span>        h.floorMaterial = material</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>func WithWallMaterial(material string) Option {</span></span>\n<span class="line"><span>    return func(h *FinishedHouse) {</span></span>\n<span class="line"><span>        h.wallMaterial = material</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>func WithCentralAirConditioning(centralAirConditioning bool) Option {</span></span>\n<span class="line"><span>    return func(h *FinishedHouse) {</span></span>\n<span class="line"><span>        h.centralAirConditioning = centralAirConditioning</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>func main() {</span></span>\n<span class="line"><span>    fmt.Printf(&quot;%+v\\n&quot;, NewFinishedHouse()) // 使用默认选项</span></span>\n<span class="line"><span>    fmt.Printf(&quot;%+v\\n&quot;, NewFinishedHouse(WithStyle(1),</span></span>\n<span class="line"><span>        WithFloorMaterial(&quot;ground-tile&quot;),</span></span>\n<span class="line"><span>        WithCentralAirConditioning(false)))</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="了解接口类型变量的内部表示" tabindex="-1"><a class="header-anchor" href="#了解接口类型变量的内部表示"><span>了解接口类型变量的内部表示</span></a></h2><p>接口的静态特性</p><ul><li>接口类型变量具有静态类型</li><li>支持在编译阶段的类型检查：当一个接口类型变量被赋值时，编译器会检查右值的类型是否实现了该接口方法集合中的所有方法</li></ul><p>接口的动态特性</p><ul><li>接口类型变量兼具动态类型，即在运行时存储在接口类型变量中的值的真实类型</li><li>接口类型变量在程序运行时可以被赋值为不同的动态类型变量</li></ul><p>接口类型变量在运行时表示为 eface 和 iface</p><p>iface：用于表示其余拥有方法的接口（interface）类型变量。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// $GOROOT/src/runtime/runtime2.go </span></span>\n<span class="line"><span>type iface struct { </span></span>\n<span class="line"><span>    tab *itab </span></span>\n<span class="line"><span>    data unsafe.Pointer </span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>// $GOROOT/src/runtime/runtime2.go </span></span>\n<span class="line"><span>type itab struct { </span></span>\n<span class="line"><span>    inter *interfacetype </span></span>\n<span class="line"><span>    _type *_type </span></span>\n<span class="line"><span>    hash uint32 </span></span>\n<span class="line"><span>    _ [4]byte </span></span>\n<span class="line"><span>    fun [1]uintptr</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>// $GOROOT/src/runtime/type.go </span></span>\n<span class="line"><span>type interfacetype struct {</span></span>\n<span class="line"><span>    typ _type</span></span>\n<span class="line"><span>    pkgpath name</span></span>\n<span class="line"><span>    mhdr []imethod </span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>eface：用于表示没有方法的空接口（empty interface）类型变量，即interface{}类型的变量。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>type eface struct { </span></span>\n<span class="line"><span>    _type *_type </span></span>\n<span class="line"><span>    data unsafe.Pointer</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>// $GOROOT/src/runtime/type.go </span></span>\n<span class="line"><span>type _type struct { </span></span>\n<span class="line"><span>    size uintptr </span></span>\n<span class="line"><span>    ptrdata uintptr </span></span>\n<span class="line"><span>    hash uint32 </span></span>\n<span class="line"><span>    tflag tflag</span></span>\n<span class="line"><span>    align uint8</span></span>\n<span class="line"><span>    fieldalign uint8 </span></span>\n<span class="line"><span>    kind uint8 </span></span>\n<span class="line"><span>    alg *typeAlg </span></span>\n<span class="line"><span>    gcdata *byte </span></span>\n<span class="line"><span>    str nameOff </span></span>\n<span class="line"><span>    ptrToThis typeOff</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看一个例子：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>type T struct { </span></span>\n<span class="line"><span>    n int</span></span>\n<span class="line"><span>    s string</span></span>\n<span class="line"><span>} </span></span>\n<span class="line"><span>func main() { </span></span>\n<span class="line"><span>    var t = T { </span></span>\n<span class="line"><span>        n: 17, s: &quot;hello, interface&quot;,</span></span>\n<span class="line"><span>    } </span></span>\n<span class="line"><span>    var ei interface{} = t // Go运行时使用eface结构表示ei </span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>func (T) M1() {} </span></span>\n<span class="line"><span>func (T) M2() {} </span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>type NonEmptyInterface interface { </span></span>\n<span class="line"><span>    M1() </span></span>\n<span class="line"><span>    M2() </span></span>\n<span class="line"><span>} </span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>func main() { </span></span>\n<span class="line"><span>    var t = T{ </span></span>\n<span class="line"><span>        n: 18, </span></span>\n<span class="line"><span>        s: &quot;hello, interface&quot;, </span></span>\n<span class="line"><span>    } </span></span>\n<span class="line"><span>    var i NonEmptyInterface = t </span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/129fb32e21b14ee3921d392ddd5e0d25~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1852&amp;h=1384&amp;s=467811&amp;e=png&amp;b=fefefe" alt="image.png"></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34844aea24174d7c934798ee7ccd6f0f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3638&amp;h=2290&amp;s=996010&amp;e=png&amp;a=1&amp;b=ffffff" alt="image.png"></p><p>当前仅当两个接口类型变量的类型信息相同，且数据指针所指数据相同时，两个接口类型才是相等的。</p><p>通过 println 可以输出接口类型变量的两部分指针变量的值</p><p>接口类型变量的装箱由 Go 编译器和运行时共同完成</p><h2 id="尽量定义小接口" tabindex="-1"><a class="header-anchor" href="#尽量定义小接口"><span>尽量定义小接口</span></a></h2><ol><li>接口越小，抽象程度越高，被接纳度越高</li><li>易于实现和测试</li><li>契约职责单一，易于复用组合</li></ol><h2 id="尽量避免使用空接口作为函数参数类型" tabindex="-1"><a class="header-anchor" href="#尽量避免使用空接口作为函数参数类型"><span>尽量避免使用空接口作为函数参数类型</span></a></h2><ul><li>仅在处理未知类型数据时使用空接口类型</li><li>在其他情况下，尽可能将你需要的行为抽象为带有方法的接口，并使用这样的非空接口类型作为函数或方法的参数</li></ul><h2 id="使用接口作为程序水平组合的连接点" tabindex="-1"><a class="header-anchor" href="#使用接口作为程序水平组合的连接点"><span>使用接口作为程序水平组合的连接点</span></a></h2><p>偏向组合，正交解耦</p><p>通过接口进行水平组合的一种常见模式是使用接受接口类型参数的函数或方法。几种惯用形式：</p><ol><li>基本形式</li></ol><p>接受接口类型参数的函数或方法</p><ol start="2"><li>包裹函数</li></ol><p>接受接口类型参数，并返回与其参数类型相同的返回值，因此可以将多个接受同一接口类型参数的包裹函数组合成一条链来调用</p><ol start="3"><li>适配器函数类型</li></ol><p>是一种类型，可以将一个满足特定函数签名的普通函数显式转换成自身类型的实例，转换后的实例同时也是某个单方法接口类型的实现者。</p><ol start="4"><li>中间件</li></ol><p>中间件就是包裹函数和适配器函数类型结合的产物</p><h2 id="使用接口提高代码的可测试性" tabindex="-1"><a class="header-anchor" href="#使用接口提高代码的可测试性"><span>使用接口提高代码的可测试性</span></a></h2><p>为一段代码编写测试代码的前提是这段代码具有可测试性。如果被测代码耦合了对外部资源的依赖，那么被测代码的可测试性就不高。因此，可以使用接口来降低这种耦合。</p><h2 id="优先考虑并发设计" tabindex="-1"><a class="header-anchor" href="#优先考虑并发设计"><span>优先考虑并发设计</span></a></h2><p>并行：在处理器核数充足的情况下，启动多个单线程应用的实例</p><p>并发：重新做应用结构设计，将应用分解成多个在基本执行单元中执行的，可能有一定关联关系的代码片段。Go 实现了 goroutine 这一由 Go 运行时负责调度的用户层轻量级线程为并发程序提供原生支持。特点：</p><ol><li>资源占用小，每个 goroutine 的初始栈大小仅为 2KB</li><li>由 GO 运行时而不是操作系统调度，上下文切换代价小</li><li>语言原生支持</li><li>语言内置 channel 作为 goroutine 间通信原语</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>chan&lt;- int是一个只能发送的通道，可以发送但是不能接收；</span></span>\n<span class="line"><span>&lt;-chan int是一个只能接收的通道，可以接收但是不能发送。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="了解-goroutine-的调度原理" tabindex="-1"><a class="header-anchor" href="#了解-goroutine-的调度原理"><span>了解 goroutine 的调度原理</span></a></h2><h3 id="goroutine-调度模型与演进过程" tabindex="-1"><a class="header-anchor" href="#goroutine-调度模型与演进过程"><span>Goroutine 调度模型与演进过程</span></a></h3><ol><li>G-M 模型</li></ol><p>每个 goroutine 对应于运行时中的一个抽象结构 G（goroutine），而被视作 “物理 CPU” 的操作系统线程则被抽象为另一个结构 M（machine）</p><ol start="2"><li>G-P-M 模型</li></ol><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f339b58bebba4ac3a2a80dafc798e188~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2566&amp;h=2148&amp;s=1217794&amp;e=png&amp;a=1&amp;b=fcfcfc" alt="image.png"></p><p>P 是一个 “逻辑处理器”，每个 G 要想真正运行起来，首先需要被分配一个 P，即进入 P 的本地运行队列（local runq）中，这里暂忽略全局运行队列（global runq）那个环节。对于 G 来说，P 就是运行它的 “CPU”，可以说在 G 的眼里只有 P。但从 goroutine 调度器的视角来看，真正的 “CPU” 是 M，只有将 P 和 M 绑定才能让 P 的本地运行队列中的 G 真正运行起来。这样的 P 与 M 的关系就好比 Linux 操作系统调度层面用户线程（user thread）与内核线程（kernel thread）的对应关系：多对多（N:M）。</p><h3 id="gmp-调度" tabindex="-1"><a class="header-anchor" href="#gmp-调度"><span>GMP 调度</span></a></h3><ol><li>抢占式调度</li></ol><p>在 Go 程序启动时，运行时会启动一个名为 sysmon 的 M（一般称为监控线程），该 M 的特殊之处在于它无须绑定 P 即可运行（以 g0 这个 G 的形式）。</p><p>sysmon 每 20us~10ms 启动一次，主要完成如下工作：</p><ul><li>释放闲置超过 5 分钟的 span 物理内存</li><li>如果超过 2 分钟没有垃圾回收，强制执行</li><li>将长时间未处理的 netpoll 结果添加到任务队列</li><li>向长时间运行的 G 任务发出抢占调度</li><li>收回因 syscall 长时间阻塞的 P。</li></ul><p>如果一个 G 任务运行超过 10ms，sysmon 就会认为其运行时间太久而发出抢占式调度的请求。一旦 G 的抢占标志位被设为 true，那么在这个 G 下一次调用函数或方法时，运行时便可以将 G 抢占并移出运行状态，放入 P 的本地运行队列中（如果 P 的本地运行队列已满，那么将放在全局运行队列中），等待下一次被调度。</p><ol start="2"><li>channel 阻塞或网络 I/O 情况下的调度</li></ol><p>如果 G 被阻塞在某个 channel 操作或网络 I/O 操作上，那么 G 会被放置到某个等待队列中，而 M 会尝试运行 P 的下一个可运行的 G。如果此时 P 没有可运行的 G 供 M 运行，那么 M 将解绑 P，并进入挂起状态。当 I/O 操作完成或 channel 操作完成，在等待队列中的 G 会被唤醒，标记为 runnable（可运行），并被放入某个 P 的队列中，绑定一个 M 后继续执行。</p><ol start="3"><li>系统调用阻塞情况下的调度</li></ol><p>如果 G 被阻塞在某个系统调用上，那么不仅 G 会阻塞，执行该 G 的 M 也会解绑 P（实质是被 sysmon 抢走了），与 G 一起进入阻塞状态。如果此时有空闲的 M，则 P 会与其绑定并继续执行其他 G；如果没有空闲的 M，但仍然有其他 G 要执行，那么就会创建一个新 M（线程）。当系统调用返回后，阻塞在该系统调用上的 G 会尝试获取一个可用的 P，如果有可用 P，之前运行该 G 的 M 将绑定 P 继续运行 G；如果没有可用的 P，那么 G 与 M 之间的关联将解除，同时 G 会被标记为 runnable，放入全局的运行队列中，等待调度器的再次调度。</p><h2 id="掌握-go-并发模型和常见并发模式" tabindex="-1"><a class="header-anchor" href="#掌握-go-并发模型和常见并发模式"><span>掌握 Go 并发模型和常见并发模式</span></a></h2><p>不要通过共享内存来通信，而应该通过通信来共享内存。</p><p>三种并发原语</p><ul><li>Goroutine，对应 CSP模型中的 P，封装了数据的处理逻辑，是 Go 运行时调度的基本单位</li><li>channel，对应于 CSP 模型中的输入输出原语，用于 goroutine 间的通信和同步</li><li>select，用于多路输入输出，可以让 goroutine 同时协调处理多个 channel</li></ul><p>并发模式</p><ol><li>创建模式：在内部创建一个 goroutine 并返回一个 channel 类型变量的函数</li><li>退出模式</li></ol><ul><li>分离模式：对于分离的 goroutine，创建它的 goroutine 不需要关心它的退出，这类 goroutine 在启动后即与其创建者彻底分离，生命周期由其主函数决定</li><li>Join 模式：goroutine 的创建者需要等待新的 goroutine 的结束</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>var OK = errors.New(&quot;ok&quot;)</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>func worker(args ...interface{}) error {</span></span>\n<span class="line"><span>   if len(args) == 0 {</span></span>\n<span class="line"><span>      return errors.New(&quot;invalid args&quot;)</span></span>\n<span class="line"><span>   }</span></span>\n<span class="line"><span>   interval, ok := args[0].(int)</span></span>\n<span class="line"><span>   if !ok {</span></span>\n<span class="line"><span>      return errors.New(&quot;invalid interval args&quot;)</span></span>\n<span class="line"><span>   }</span></span>\n<span class="line"><span>   time.Sleep(time.Second * (time.Duration(interval)))</span></span>\n<span class="line"><span>   return OK</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>func spawn(f func(args ...interface{}) error, args ...interface{}) chan error {</span></span>\n<span class="line"><span>   c := make(chan error)</span></span>\n<span class="line"><span>   go func() {</span></span>\n<span class="line"><span>      c &lt;- f(args...)</span></span>\n<span class="line"><span>   }()</span></span>\n<span class="line"><span>   return c</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>func main() {</span></span>\n<span class="line"><span>   done := spawn(worker, 5)</span></span>\n<span class="line"><span>   println(&quot;spawn worker1&quot;)</span></span>\n<span class="line"><span>   err := &lt;-done</span></span>\n<span class="line"><span>   fmt.Println(&quot;worker 1 done: &quot;, err)</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>   done = spawn(worker)</span></span>\n<span class="line"><span>   println(&quot;spawn worker2&quot;)</span></span>\n<span class="line"><span>   err = &lt;- done</span></span>\n<span class="line"><span>   println(&quot;worker2 done: &quot;, err)</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>sync.WaitGroup 可以用来等待多个 goroutine 退出</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>func worker(args ...interface{}) {</span></span>\n<span class="line"><span>   if len(args) == 0 {</span></span>\n<span class="line"><span>      return</span></span>\n<span class="line"><span>   }</span></span>\n<span class="line"><span>   interval, ok := args[0].(int)</span></span>\n<span class="line"><span>   if !ok {</span></span>\n<span class="line"><span>      return</span></span>\n<span class="line"><span>   }</span></span>\n<span class="line"><span>   time.Sleep(time.Second * (time.Duration(interval)))</span></span>\n<span class="line"><span>   return</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>func spawnGroup(n int, f func(args ...interface{}), args ...interface{}) chan struct{} {</span></span>\n<span class="line"><span>   c := make(chan struct{})</span></span>\n<span class="line"><span>   var wg sync.WaitGroup</span></span>\n<span class="line"><span>   for i := 0; i &lt; n; i++ {</span></span>\n<span class="line"><span>      wg.Add(1)</span></span>\n<span class="line"><span>      go func(i int) {</span></span>\n<span class="line"><span>         name := fmt.Sprintf(&quot;worker-%d&quot;, i)</span></span>\n<span class="line"><span>         f(args)</span></span>\n<span class="line"><span>         println(name, &quot;done&quot;)</span></span>\n<span class="line"><span>         wg.Done()</span></span>\n<span class="line"><span>      }(i)</span></span>\n<span class="line"><span>   }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>   go func() {</span></span>\n<span class="line"><span>      wg.Wait()</span></span>\n<span class="line"><span>      c &lt;- struct{}{}</span></span>\n<span class="line"><span>   }()</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>   return c</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>func main() {</span></span>\n<span class="line"><span>   done := spawnGroup(5, worker, 3)</span></span>\n<span class="line"><span>   println(&quot;spawn a group of workers&quot;)</span></span>\n<span class="line"><span>   &lt;-done</span></span>\n<span class="line"><span>   println(&quot;group workers done&quot;)</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>超时等待机制：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>func main() {</span></span>\n<span class="line"><span>   done := spawnGroup(100000, worker, 3)</span></span>\n<span class="line"><span>   println(&quot;spawn a group of workers&quot;)</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>   timer := time.NewTimer(time.Second * 1)</span></span>\n<span class="line"><span>   defer timer.Stop()</span></span>\n<span class="line"><span>   select {</span></span>\n<span class="line"><span>   case &lt;-timer.C:</span></span>\n<span class="line"><span>      println(&quot;wait group workers exit timeout&quot;)</span></span>\n<span class="line"><span>   case &lt;-done:</span></span>\n<span class="line"><span>      println(&quot;group workers done&quot;)</span></span>\n<span class="line"><span>   }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Notify-and-wait 模式</li></ul><p>通知单一 goroutine 退出</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>func worker(i int) {</span></span>\n<span class="line"><span>   time.Sleep(time.Second * (time.Duration(i)))</span></span>\n<span class="line"><span>   return</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>func spawn(f func(i int)) chan string {</span></span>\n<span class="line"><span>   quit := make(chan string)</span></span>\n<span class="line"><span>   go func() {</span></span>\n<span class="line"><span>      var job chan int</span></span>\n<span class="line"><span>      for {</span></span>\n<span class="line"><span>         select {</span></span>\n<span class="line"><span>         case j := &lt;-job:</span></span>\n<span class="line"><span>            f(j)</span></span>\n<span class="line"><span>         case &lt;-quit:</span></span>\n<span class="line"><span>            quit &lt;- &quot;Ok&quot;</span></span>\n<span class="line"><span>         }</span></span>\n<span class="line"><span>      }</span></span>\n<span class="line"><span>   }()</span></span>\n<span class="line"><span>   return quit</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>func main() {</span></span>\n<span class="line"><span>   quit := spawn(worker)</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>   time.Sleep(time.Second * 5)</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>   quit &lt;- &quot;quit&quot;</span></span>\n<span class="line"><span>   timer := time.NewTimer(time.Second * 10)</span></span>\n<span class="line"><span>   defer timer.Stop()</span></span>\n<span class="line"><span>   select {</span></span>\n<span class="line"><span>   case status := &lt;-quit:</span></span>\n<span class="line"><span>      println(&quot;workder done: &quot;, status)</span></span>\n<span class="line"><span>   case &lt;-timer.C:</span></span>\n<span class="line"><span>      println(&quot;wait for worker exit timeout&quot;)</span></span>\n<span class="line"><span>   }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通知并等待多个 goroutine 退出：当使用 close 关闭 channel 时，所有阻塞在该 channel 上的 goroutine 都会得到通知</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>func worker(i int) {</span></span>\n<span class="line"><span>   time.Sleep(time.Second * (time.Duration(i)))</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>func spawnGroup(n int, f func(int)) chan struct{} {</span></span>\n<span class="line"><span>   quit := make(chan struct{})</span></span>\n<span class="line"><span>   job := make(chan int)</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>   var wg sync.WaitGroup</span></span>\n<span class="line"><span>   for i := 0; i &lt; n; i++ {</span></span>\n<span class="line"><span>      wg.Add(1)</span></span>\n<span class="line"><span>      go func(i int) {</span></span>\n<span class="line"><span>         defer wg.Done()</span></span>\n<span class="line"><span>         name := fmt.Sprintf(&quot;worker %d&quot;, i)</span></span>\n<span class="line"><span>         for {</span></span>\n<span class="line"><span>            j, ok := &lt;-job</span></span>\n<span class="line"><span>            if !ok {</span></span>\n<span class="line"><span>               println(name, &quot;done&quot;)</span></span>\n<span class="line"><span>               return</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span>            worker(j)</span></span>\n<span class="line"><span>         }</span></span>\n<span class="line"><span>      }(i)</span></span>\n<span class="line"><span>   }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>   go func() {</span></span>\n<span class="line"><span>      &lt;-quit</span></span>\n<span class="line"><span>      close(job)</span></span>\n<span class="line"><span>      wg.Wait()</span></span>\n<span class="line"><span>      quit &lt;- struct{}{}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>   }()</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>   return quit</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>func main() {</span></span>\n<span class="line"><span>   quit := spawnGroup(5, worker)</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>   time.Sleep(time.Second * 5)</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>   quit &lt;- struct{}{}</span></span>\n<span class="line"><span>   timer := time.NewTimer(time.Second * 5)</span></span>\n<span class="line"><span>   defer timer.Stop()</span></span>\n<span class="line"><span>   select {</span></span>\n<span class="line"><span>   case &lt;-quit:</span></span>\n<span class="line"><span>      println(&quot;workder done: &quot;)</span></span>\n<span class="line"><span>   case &lt;-timer.C:</span></span>\n<span class="line"><span>      println(&quot;wait for worker exit timeout&quot;)</span></span>\n<span class="line"><span>   }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>管道模式</li></ol><p>Goroutine 从数据输入 channel 获取前一个环节生产的数据，进行处理后，通过 channel 发往下一个环节</p><p>扇出模式：在某个处理环节，多个功能相同的 goroutine 从同一个 channel 读取数据并处理，直到该 channel 关闭</p><p>扇入模式：将所有输入 channel 的数据汇聚到一个统一的输入 channel，然后处理程序再从这个 channel中读取数据并处理，直到该 channel 因为所有输入 channel 关闭而关闭</p><ol start="4"><li>超时与取消模式</li></ol><p>使用 context 包来实现取消模式</p><h2 id="了解-channel-的妙用" tabindex="-1"><a class="header-anchor" href="#了解-channel-的妙用"><span>了解 channel 的妙用</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>c := make(chan int)</span></span>\n<span class="line"><span>c := make(chan int, 5)</span></span>\n<span class="line"><span>c &lt;- x</span></span>\n<span class="line"><span>&lt;- c</span></span>\n<span class="line"><span>x = &lt;- c</span></span>\n<span class="line"><span>x, ok = &lt;- c</span></span>\n<span class="line"><span>for i := range c</span></span>\n<span class="line"><span>close(c)</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>c := make(chan chan int) // 一个无缓冲的chan int 类型的 channel</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过 select，可以同时在多个 channel 上进行发送接收操作</p><h3 id="无缓冲-channel" tabindex="-1"><a class="header-anchor" href="#无缓冲-channel"><span>无缓冲 channel</span></a></h3><p>不带有缓冲区，因此对无缓冲 channel 的接收和发送操作是同步的，因此发送和接收必须同时存在，否则就会陷入阻塞状态</p><p>结论</p><ul><li>发送动作一定<strong>发生</strong>在接受动作<strong>完成</strong>之前</li><li>接受动作一定<strong>发生</strong>在发送动作<strong>完成</strong>之前</li></ul><p>应用：</p><ol><li>用作信号传递</li><li>用作替代锁机制</li></ol><h3 id="带缓冲-channel" tabindex="-1"><a class="header-anchor" href="#带缓冲-channel"><span>带缓冲 channel</span></a></h3><p>对带缓冲 channel 的发送操作在缓冲区未满、接收操作在缓冲区非空的情况下是异步的。也就是说，当缓冲区无数据或者没满的时候，进行发送不会阻塞；当缓冲区满的时候，进行发送会阻塞；当缓冲区空的时候，进行接收会阻塞</p><p>应用：</p><ol><li>用作消息队列</li><li>用作计数信号量：当前数据个数代表的是当前同时处于活动状态的 goroutine 的数量，容量代表允许同时处于活动状态的 goroutine 的最大数量。一个发往带缓冲 channel 的发送操作表示获得一个信号量槽位，一个来自带缓冲 channel 的接收操作表示释放一个信号量槽位。</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>var active = make(chan struct{}, 3)</span></span>\n<span class="line"><span>var jobs = make(chan int, 10)</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>func main() {</span></span>\n<span class="line"><span>   go func() {</span></span>\n<span class="line"><span>      for i := 0; i &lt; 10; i++ {</span></span>\n<span class="line"><span>         jobs &lt;- i + 1</span></span>\n<span class="line"><span>      }</span></span>\n<span class="line"><span>      close(jobs)</span></span>\n<span class="line"><span>   }()</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>   var wg sync.WaitGroup</span></span>\n<span class="line"><span>   for j := range jobs {</span></span>\n<span class="line"><span>      wg.Add(1)</span></span>\n<span class="line"><span>      go func(j int) {</span></span>\n<span class="line"><span>         active &lt;- struct{}{}</span></span>\n<span class="line"><span>         log.Printf(&quot;Handle job :%d&quot;, j)</span></span>\n<span class="line"><span>         time.Sleep(2 * time.Second)</span></span>\n<span class="line"><span>         &lt;-active</span></span>\n<span class="line"><span>         wg.Done()</span></span>\n<span class="line"><span>      }(j)</span></span>\n<span class="line"><span>   }</span></span>\n<span class="line"><span>   wg.Wait()</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>len(channel) 的应用</li></ol><p>当 channel 是无缓冲 channel 时，len(channel) 总是返回 0</p><p>当 channel 为带缓冲 channel 时，len(channel) 返回当前 channel 中尚未被读取的元素个数</p><p>使用 len(channel) 来判空后，多个 goroutine 之间可能存在竞态，导致判断失效。</p><p>因此常见的方法是将判空与读取放在一个事务中，将判满和写入放在一个事务中，这类事务可以通过 select 来实现。当是单接收多发送或者单发送多接收这两种场景时，可以使用 len(channel)</p><h3 id="nil-channel-的使用" tabindex="-1"><a class="header-anchor" href="#nil-channel-的使用"><span>Nil channel 的使用</span></a></h3><p>对没有初始化的 channel 进行读写操作将会发生阻塞</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>对一个关闭的通道再发送值就会导致panic。</span></span>\n<span class="line"><span>对一个关闭的通道进行接收会一直获取值直到通道为空。</span></span>\n<span class="line"><span>对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。</span></span>\n<span class="line"><span>关闭一个已经关闭的通道会导致panic。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="与-select-结合使用的一些惯用法" tabindex="-1"><a class="header-anchor" href="#与-select-结合使用的一些惯用法"><span>与 select 结合使用的一些惯用法</span></a></h3><ol><li>利用 default 分支避免阻塞</li></ol><p>select 的 default 分支会在其它分支均因通信未就绪而无法被选择的时候执行，因此可以利用此特性来避免阻塞</p><ol start="2"><li>实现超时机制</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>func worker() {</span></span>\n<span class="line"><span>   select {</span></span>\n<span class="line"><span>   case &lt;-c:</span></span>\n<span class="line"><span>   // ...</span></span>\n<span class="line"><span>   case &lt;-time.After(30 * time.Second):</span></span>\n<span class="line"><span>      return</span></span>\n<span class="line"><span>   }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>实现心跳机制</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>func worker() {</span></span>\n<span class="line"><span>   heartbeat := time.NewTicker(30 * time.Second)</span></span>\n<span class="line"><span>   defer heartbeat.Stop()</span></span>\n<span class="line"><span>   for {</span></span>\n<span class="line"><span>      select {</span></span>\n<span class="line"><span>      case &lt;-c:</span></span>\n<span class="line"><span>      //</span></span>\n<span class="line"><span>      case &lt;-heartbeat.C:</span></span>\n<span class="line"><span>         //...</span></span>\n<span class="line"><span>      }</span></span>\n<span class="line"><span>   }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="了解-sync-包的正确用法" tabindex="-1"><a class="header-anchor" href="#了解-sync-包的正确用法"><span>了解 Sync 包的正确用法</span></a></h2><p>Go 提倡不通过共享内存来通信，而是通过通信来共享内存。</p><ul><li>在使用 sync 包中类型时，推荐通过闭包方式或传递类型实例的地址或者指针的方式进行</li><li>读写锁适用于具有一定并发量并且读多写少的场合</li><li>synx.Cond 实例的初始化需要一个满足实现了 sync.Locker 接口的类型实例，通常使用 sync.Mutex</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>groupSignal := sync.NewCond(&amp;sync.Mutex{})</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>使用 sync.Once 来实现单例模式</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>var instance *Foo</span></span>\n<span class="line"><span>var once sync.Once</span></span>\n<span class="line"><span>func getInstance() *Foo {</span></span>\n<span class="line"><span>   once.Do(func() {</span></span>\n<span class="line"><span>      instance = &amp;Foo{}  </span></span>\n<span class="line"><span>   })</span></span>\n<span class="line"><span>   return instance</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>使用 sync.Pool 来减轻垃圾回收压力</li></ul><p>sync.Pool 是一个数据对象缓冲池，具有如下特点：</p><ul><li>是 goroutine 并发安全的，可以被多个 goroutine 同时使用</li><li>放入该缓存池的数据对象的生命是暂时的，随时都可能被垃圾回收掉</li><li>缓存池中的对象是可以被重复利用的</li></ul><p>存在问题：如果从 pool 中返回的 buffer 是刚刚被大数据撑大的，并且即将长期被用于处理一些小数据，那么这个 buffer 占用的大内存将长时间得不到释放。Go 标准库的做法：</p><ol><li>限制要放回缓存池中的数据对象的大小</li><li>建立多级缓冲池</li></ol><h2 id="使用-atomic-包实现伸缩性更好的并发读取" tabindex="-1"><a class="header-anchor" href="#使用-atomic-包实现伸缩性更好的并发读取"><span>使用 atomic 包实现伸缩性更好的并发读取</span></a></h2><p>适合一些对性能十分敏感、并发量较大且读多写少的场合</p><h2 id="了解错误处理的-4-种策略" tabindex="-1"><a class="header-anchor" href="#了解错误处理的-4-种策略"><span>了解错误处理的 4 种策略</span></a></h2><ul><li>构造错误值</li><li>透明错误处理策略</li></ul><p>使用 Go 标准库提供的两个基本错误值构造方法 errors.New 和 fmt.Errorf构造出来的错误值，对错误处理方是透明的，这种策略被称为透明错误处理策略</p><ul><li>哨兵错误处理策略</li></ul><p>通过定义导出的错误值的方式，避免字符串的硬编码，这种值就称为哨兵值</p><ul><li>错误值类型检视策略</li></ul><h2 id="尽量优化反复出现的-if-err-nil" tabindex="-1"><a class="header-anchor" href="#尽量优化反复出现的-if-err-nil"><span>尽量优化反复出现的 if err != nil</span></a></h2><h2 id="不要使用-panic-进行正常的错误处理" tabindex="-1"><a class="header-anchor" href="#不要使用-panic-进行正常的错误处理"><span>不要使用 panic 进行正常的错误处理</span></a></h2>',282)]))}]]),p=JSON.parse('{"path":"/Backend/golang_newbee_getting_better.html","title":"Go 语言精进之路学习笔记","lang":"en-US","frontmatter":{"category":"Backend","tags":["基础知识"]},"git":{"createdTime":1741514883000,"updatedTime":1741514883000,"contributors":[{"name":"Tamarous","username":"Tamarous","email":"hiwangzewei@qq.com","commits":1,"url":"https://github.com/Tamarous"}]},"readingTime":{"minutes":31.88,"words":9564},"filePathRelative":"Backend/golang_newbee_getting_better.md","localizedDate":"March 9, 2025","excerpt":"\\n<h2>前言</h2>\\n<p>《Go 语言精进之路》这本书真的非常好，深入讲解了 Go 语言的方方面面，是入门的不二之选。本文是在学习《Go 语言精进之路》时所做的一些摘要和记录。</p>\\n<h2>理解 GO 语言的设计哲学</h2>\\n<ul>\\n<li>追求简单，少即是多</li>\\n<li>偏好组合，正交耦合</li>\\n<li>原生并发，轻量高效</li>\\n<li>面向工程，自带电池</li>\\n</ul>\\n<p>Go 特点：</p>\\n<ul>\\n<li>语法简洁，只有 25 个关键字</li>\\n<li>内置垃圾收集，降低内存管理心智负担</li>\\n<li>没有头文件</li>\\n<li>显式依赖</li>\\n<li>没有循环依赖</li>\\n<li>常量只是数字</li>\\n<li>首字母大小写决定可见性</li>\\n<li>任何类型都可以拥有方法</li>\\n<li>没有子类型继承</li>\\n<li>没有算数转换</li>\\n<li>接口是隐式的</li>\\n<li>方法就是函数</li>\\n<li>接口只是方法集合</li>\\n<li>方法仅按照名称匹配</li>\\n<li>没有构造或析构函数</li>\\n<li>赋值不是表达式</li>\\n<li>没有指针算数</li>\\n<li>内存总是初始化为零值</li>\\n<li>没有类型注解语法</li>\\n<li>没有模板或泛型</li>\\n<li>没有异常</li>\\n<li>内置字符串、切片、map 类型</li>\\n<li>内置数据边界检查</li>\\n<li>内置并发支持</li>\\n<li>……</li>\\n</ul>"}')},6262:(n,s)=>{s.A=(n,s)=>{const a=n.__vccOpts||n;for(const[n,i]of s)a[n]=i;return a}}}]);