(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{403:function(t,e,n){"use strict";n.r(e);var i=n(42),a=Object(i.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"masonry-源代码剖析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#masonry-源代码剖析"}},[t._v("#")]),t._v(" Masonry 源代码剖析")]),t._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/SnapKit/Masonry",target:"_blank",rel:"noopener noreferrer"}},[t._v("Masonry"),n("OutboundLink")],1),t._v(" 是一个用来代替苹果原生的AutoLayout 的自动布局框架。这个库的代码量不是很多，而且使用也很简单方便，那么就让我们深入到这个库的内部，看看它是怎么实现的。")]),t._v(" "),n("h2",{attrs:{id:"使用范例"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#使用范例"}},[t._v("#")]),t._v(" 使用范例")]),t._v(" "),n("p",[t._v("下面是一个使用Masonry 的范例：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("[view mas_makeConstraints: ^(MASConstraintMaker *make) {\n    make.top.equalTo(superview.mas_top).with.offset(padding.top);\n    make.left.equalTo(superview.mas_left).with.offset(padding.left);\n    make.bottom.equalTo(superview.mas_bottom).with.offset(-padding.bottom);\n    make.right.equalTo(superview.mas_right).with.offset(-padding.right);\n}];\n")])])]),n("p",[t._v("可以看到，view 与superview 之间的约束，是通过一个block 设置的。这个block 接受一个类型为MASConstraintMaker 的参数make，然后在block 函数体内通过make 来实现约束设置。make 看起来像是view 的一个替身，当我们写")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("make.top.equalTo(superview.mas_top).with.offset(padding.top);\n")])])]),n("p",[t._v("时，实际效果是")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("view.top.equalTo(superview.mas_top).with.offset(padding.top);\n")])])]),n("h2",{attrs:{id:"内部实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#内部实现"}},[t._v("#")]),t._v(" 内部实现")]),t._v(" "),n("h3",{attrs:{id:"mas-makeconstraints"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#mas-makeconstraints"}},[t._v("#")]),t._v(" mas_makeConstraints:")]),t._v(" "),n("p",[t._v("在Xcode 中，按住Command，在方法上点击鼠标左键就可以进入方法的内部实现。我们进入"),n("code",[t._v("mas_makeConstraints:")]),t._v("，可以看到这个方法的实现如下：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *))block       {\n    self.translatesAutoresizingMaskIntoConstraints = NO;\n    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView: self];\n    block(constraintMaker);\n    return [constraintMaker install];\n}\n")])])]),n("p",[t._v("首先要将被设置的view 的"),n("code",[t._v("translatesAutoresizingMaskIntoConstraints")]),t._v("属性设置成NO，这样才可以成功添加约束。")]),t._v(" "),n("p",[t._v("然后，创建一个"),n("code",[t._v("MASConstraintMaker")]),t._v("的实例。block 接受这个实例，然后执行block 块内的内容。最后返回"),n("code",[t._v("[constraintMaker install]")]),t._v("的结果。")]),t._v(" "),n("h3",{attrs:{id:"masconstraintmaker"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#masconstraintmaker"}},[t._v("#")]),t._v(" MASConstraintMaker")]),t._v(" "),n("h4",{attrs:{id:"初始化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#初始化"}},[t._v("#")]),t._v(" 初始化")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("// MASContraintMaker.m\n\n// MAS_VIEW 是UIView 的别名\n@property (nonatomic, weak) MAS_VIEW *view;\n\n- (id) initWithView:(MAS_VIEW *) view {\n    self = [super init];\n    if (! self) {\n        return nil;\n    }\n    self.view = view;\n    self.constraints = NSMutableArray.new;\n    return self;\n}\n")])])]),n("p",[t._v("在初始化方法中，"),n("code",[t._v("MASContraintMaker")]),t._v(" 将要设置的视图赋值给它的属性view，因此 "),n("code",[t._v("MASContraintMaker")]),t._v(" 对将要设置的视图拥有了一个弱引用。")]),t._v(" "),n("h4",{attrs:{id:"block-的执行"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#block-的执行"}},[t._v("#")]),t._v(" block 的执行")]),t._v(" "),n("p",[t._v("block 中实际进行了约束的设置工作。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("    make.top.equalTo(superview.mas_top).with.offset(padding.top);\n    make.left.equalTo(superview.mas_left).with.offset(padding.left);\n    make.bottom.equalTo(superview.mas_bottom).with.offset(-padding.bottom);\n    make.right.equalTo(superview.mas_right).with.offset(-padding.right);\n")])])]),n("p",[t._v("这个调用过程是链式的，即每次调用都是作用于"),n("code",[t._v("MASConstraint")]),t._v(" 类型上，而本次调用的返回类型仍然是"),n("code",[t._v("MASConstraint")]),t._v(" 类型。")]),t._v(" "),n("h5",{attrs:{id:"right-left-bottom-top"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#right-left-bottom-top"}},[t._v("#")]),t._v(" right,left,bottom,top")]),t._v(" "),n("p",[t._v("right，left，bottom和top 实际上是"),n("code",[t._v("MASConstraintMaker")]),t._v("中的相应属性的getter 方法，以top 为例，其定义如下：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("- (MASConstraint *) top {\n    return [self addConstraintWithLayoutAttribute: NSLayoutAttributeTop];\n}\n")])])]),n("p",[t._v("这个方法中还涉及到一些其他方法：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("- (MASContraint *) addConstraintWithLayoutAttribute:(NSLayoutAttribute) layoutAttribute {\n    return [self constraint: nil addConstraintWithLayoutAttribute: layoutAttribute];\n}\n\n- (MASConstraint *) constraint:(MASContraint *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute) layoutAttribute {\n    MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] initWithView:self.view layoutAttribute:layoutAttribute]; // 1\n    MASViewAttribute *newAttribute = [[MASViewAttribute alloc] initWithFirstViewAttribute:viewAttribute]; // 2\n    if ([constraint isKindOfClass: MASViewConstraint.class]) {\n        NSArray *children = @[constraint, newConstraint];\n        MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] initWithChildren: children];\n        compositeConstraint.delegate = self;\n        [self constraint: constraint shouleBeReplaceWithConstraint: compositeConstraint];\n        return compositeConstraint;\n    }\n    // 因为传入的constraint 为nil，所以直接进入下面的判断\n    if (! constraint) {\n        newConstraint.delegate = self;\n        [self.constraints addObject: newConstraint]; // 3\n    }\n    return newConstraint;\n}\n")])])]),n("p",[t._v("在上面这个方法中：")]),t._v(" "),n("ol",[n("li",[t._v("根据传入的要设置的"),n("code",[t._v("NSLayoutAttribute")]),t._v(" 生成对应的"),n("code",[t._v("MASViewAttribute")]),t._v("。")]),t._v(" "),n("li",[t._v("根据"),n("code",[t._v("MASViewAttribute")]),t._v(" 生成当前视图的新约束。")]),t._v(" "),n("li",[t._v("将2中生成的新约束加入"),n("code",[t._v("MASContraintMaker")]),t._v(" 的约束数组中。")])]),t._v(" "),n("h5",{attrs:{id:"equalto-greaterthanorequalto-lessthanorequalto"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#equalto-greaterthanorequalto-lessthanorequalto"}},[t._v("#")]),t._v(" equalTo, greaterThanOrEqualTo, lessThanOrEqualTo")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("- (MASConstraint * (^)(id attr))equalTo;\n- (MASConstraint * (^)(id attr))greaterThanOrEqualTo;\n- (MASConstraint * (^)(id attr))lessThanOrEqualTo; \n")])])]),n("p",[t._v("这三个方法的参数是id 类型的，因此它们既可以接受NSValue 类型的参数，如NSNumber，CGPoint，CGSize等，也可以接受"),n("code",[t._v("UIView")]),t._v(" 类型的参数，还可以接受"),n("code",[t._v("MASViewConstraint")]),t._v(" 类型的参数。\n当接受NSValue 类型的参数时，如")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("make.top.equalTo(@100)\n")])])]),n("p",[t._v("表示当前视图的top与它的superview 的top相距100；\n当接受"),n("code",[t._v("UIView")]),t._v(" 类型的参数时，会和"),n("code",[t._v("UIView")]),t._v(" 的对应属性做比较，如")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("make.top.equalTo(secondView)\n")])])]),n("p",[t._v("表示当前视图和secondView 的top是平齐的；\n当接受"),n("code",[t._v("MASViewConstraint")]),t._v(" 类型的参数时，如")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("make.bottom.equalTo(secondView.mas_bottom)\n")])])]),n("p",[t._v("表示当前视图和secondView 的bottom 是平齐的。")]),t._v(" "),n("p",[t._v("这个特性的实现原理会在稍后进行介绍。")]),t._v(" "),n("p",[t._v("以上方法虽然定义不同，但是内部实现相似，都是调用了"),n("code",[t._v("MASConstraint")]),t._v(" 的"),n("code",[t._v("equalToWithRelation")]),t._v(" 方法，但是传入了不同的参数：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("- (MASConstraint * (^)(id attr))equalTo 「\n    return ^id(id attribute) {\n        return self.equalToWithRelation(attribute, NSLayoutRelationEqual);\n    };\n}\n- (MASConstraint * (^)(id attr))greaterThanOrEqualTo {\n    return ^id(id attribute) {\n        return self.equalToWithRelation(attribute, NSLayoutRelationGreaterThanOrEqual);\n    };\n}\n- (MASConstraint * (^)(id attr)) lessThanOrEqualTo{\n    return ^id(id attribute) {\n        return self.equalToWithRelation(attribute,\n        NSLayoutRelationLessThanOrEqual);\n    };\n}\n")])])]),n("p",[t._v("继续向下寻找"),n("code",[t._v("equalToWithRelation")]),t._v(" 的定义。使用Command + 鼠标左键，我们发现这个方法在三个地方有定义：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("[MASConstraint(Abstract) equalToWithRelation];\n[MASViewConstraint equalToWithRelation];\n[MASCompositeConstraint equalToWithRelation];\n")])])]),n("p",[n("code",[t._v("MASCompositeConstraint")]),t._v(" 和"),n("code",[t._v("MASViewContraint")]),t._v(" 是"),n("code",[t._v("MASConstraint")]),t._v(" 的子类。在"),n("code",[t._v("MASConstraint")]),t._v(" 中定义了很多抽象方法，都是需要在这两个子类中进行实现的。")]),t._v(" "),n("blockquote",[n("p",[t._v("MASCompositeConstraint: A composite with a predefined array of children.")])]),t._v(" "),n("p",[t._v("从定义和名称中可以看出，"),n("code",[t._v("MASCompositeConstraint")]),t._v(" 是约束的组合。按照我的理解，它的作用可以看作是一颗树的根，这个根确定了哪些节点位于这棵树上，而树的子节点的类型都是"),n("code",[t._v("MASViewConstraint")]),t._v("。")]),t._v(" "),n("p",[n("code",[t._v("equalToWithRelation")]),t._v(" 是一个抽象方法，在"),n("code",[t._v("MASContraint")]),t._v(" 中没有实现，如果调用此方法就会抛出一个异常：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v('- (MASConstraint * (^)(id, NSLayoutRelation))equalToWithRelation { MASMethodNotImplemented(); }\n\n#define MASMethodNotImplemented() \\\n@throw [NSException exceptionWithName:NSInternalInconsistencyException \\\n                               reason:[NSString stringWithFormat:@"You must override %@ in a subclass.", NSStringFromSelector(_cmd)] \\\n                             userInfo:nil]\n')])])]),n("p",[n("code",[t._v("MASViewConstraint")]),t._v(" 重载了此方法：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v('    - (MASConstraint * (^)(id, NSLayoutRelation))equalToWithRelation {\nreturn ^id(id attribute, NSLayoutRelation relation) {\n    if ([attribute isKindOfClass:NSArray.class]) { // 1\n        NSAssert(!self.hasLayoutRelation, @"Redefinition of constraint relation");\n        NSMutableArray *children = NSMutableArray.new;\n        for (id attr in attribute) {\n            MASViewConstraint *viewConstraint = [self copy];\n            viewConstraint.layoutRelation = relation;\n            viewConstraint.secondViewAttribute = attr;\n            [children addObject:viewConstraint];\n        }\n        MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] initWithChildren:children];\n        compositeConstraint.delegate = self.delegate;\n        [self.delegate constraint:self shouldBeReplacedWithConstraint:compositeConstraint];\n        return compositeConstraint;\n    } else {\n        NSAssert(!self.hasLayoutRelation || self.layoutRelation == relation && [attribute isKindOfClass:NSValue.class], @"Redefinition of constraint relation");\n        self.layoutRelation = relation;\n        self.secondViewAttribute = attribute;  // 2\n        return self;\n    }\n};\n}\n')])])]),n("ol",[n("li",[n("p",[t._v("判断传入的attribute 是否为NSArray 类型。")])]),t._v(" "),n("li",[n("p",[t._v("如果不是，则将传入的参数赋值给某些属性。注意secondViewAttribute 这个属性的setter 方法，它并不是一个简单的赋值过程，而是会根据传入的attribute 的类型进行额外的设置。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v(' - (void)setSecondViewAttribute:(id)secondViewAttribute {\n\n     if ([secondViewAttribute isKindOfClass:NSValue.class]) {\n     \n     // 1 对应于上文中的equalTo(@100) 这种情况\n         [self setLayoutConstantWithValue:secondViewAttribute]; \n     } else if ([secondViewAttribute isKindOfClass:MAS_VIEW.class]) {\n     \n     // 2 对应于上文中的equalTo(secondView) 这种情况\n         _secondViewAttribute = [[MASViewAttribute alloc] initWithView:secondViewAttribute layoutAttribute:self.firstViewAttribute.layoutAttribute]; // 2\n     } else if ([secondViewAttribute isKindOfClass:MASViewAttribute.class]) {\n     \n     // 3 对应于上文中的equalTo(secondView.mas_bottom) 这种情况\n         _secondViewAttribute = secondViewAttribute;\n     } else {\n         NSAssert(NO, @"attempting to add unsupported attribute: %@", secondViewAttribute);\n     }\n }\n')])])])])]),t._v(" "),n("p",[n("code",[t._v("MASCompositeConstraint")]),t._v(" 对此方法的实现则要简单得多：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("- (MASConstraint * (^)(id, NSLayoutRelation))equalToWithRelation {\n    return ^id(id attr, NSLayoutRelation relation) {\n        for (MASConstraint *constraint in self.childConstraints.copy) {\n            constraint.equalToWithRelation(attr, relation);\n    }\n        return self;\n    };\n}\n")])])]),n("p",[t._v("可以看出，这个方法的实现是递归的，它对当前"),n("code",[t._v("MASCompositeConstraint")]),t._v(" 的每一个childConstraint 调用对应的"),n("code",[t._v("equalToWithRelation")]),t._v(" 方法，如果当前某一个constraint 的childConstraint 为空，就返回这个constraint。怎么样，是不是有点类似于后续遍历？\n因为实际的工作都是由"),n("code",[t._v("MASViewConstraint")]),t._v(" 类型完成的，下面我们就只关心方法在这个类中的实现。")]),t._v(" "),n("h4",{attrs:{id:"安装约束"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#安装约束"}},[t._v("#")]),t._v(" 安装约束")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("- (NSArray *)install {\n    if (self.removeExisting) {\n        NSArray *installedConstraints = [MASViewConstraint installedConstraintsForView: self.view]; // 1\n        for (MASConstraint *constraint in installedConstraints) {\n            [constraint uninstall]; // 2\n        }\n    }\n    NSArray *constraints = self.constraints.copy;\n    for (MASConstraint *constraint in constraints) {\n        constraint.updateExisting = self.updateExisting;\n        [constraint install]; // 3\n    }\n    [self.constraints removeAllObjects]; // 4\n    return constraints;\n}\n")])])]),n("p",[t._v("在"),n("code",[t._v("MASConstraintMaker")]),t._v("的"),n("code",[t._v("install")]),t._v("方法中，有如下几个过程：")]),t._v(" "),n("ol",[n("li",[t._v("查看当前视图上已经安装的约束。")]),t._v(" "),n("li",[t._v("对于"),n("strong",[t._v("已经")]),t._v("安装的约束，逐一进行卸载。")]),t._v(" "),n("li",[t._v("对于"),n("strong",[t._v("将要")]),t._v("安装的约束，逐一"),n("code",[t._v("[constaint install]")]),t._v("，进行安装。")]),t._v(" "),n("li",[t._v("将自身的"),n("code",[t._v("constraints")]),t._v("数组中的所有元素清除掉。")])]),t._v(" "),n("h3",{attrs:{id:"masviewconstraint"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#masviewconstraint"}},[t._v("#")]),t._v(" MASViewConstraint")]),t._v(" "),n("p",[t._v("我们着重来看上一节描述的"),n("code",[t._v("[constraintMaker install]")]),t._v("中的第三点。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v('// MASViewConstraint.m\n- (void)install {\nif (self.hasBeenInstalled) {\n    return;\n}\n\n// 1\nif ([self supportsActiveProperty] && self.layoutConstraint) {\n    self.layoutConstraint.active = YES;\n    [self.firstViewAttribute.view.mas_installedConstraints addObject:self];\n    return;\n}\n\n// 2\nMAS_VIEW *firstLayoutItem = self.firstViewAttribute.item;\nNSLayoutAttribute firstLayoutAttribute = self.firstViewAttribute.layoutAttribute;\nMAS_VIEW *secondLayoutItem = self.secondViewAttribute.item;\nNSLayoutAttribute secondLayoutAttribute = self.secondViewAttribute.layoutAttribute;\n\n// 3\n// alignment attributes must have a secondViewAttribute\n// therefore we assume that is refering to superview\n// eg make.left.equalTo(@10)\nif (!self.firstViewAttribute.isSizeAttribute && !self.secondViewAttribute) {\n    secondLayoutItem = self.firstViewAttribute.view.superview;\n    secondLayoutAttribute = firstLayoutAttribute;\n}\n\n// 4\nMASLayoutConstraint *layoutConstraint\n    = [MASLayoutConstraint constraintWithItem:firstLayoutItem\n                                    attribute:firstLayoutAttribute\n                                    relatedBy:self.layoutRelation\n                                       toItem:secondLayoutItem\n                                    attribute:secondLayoutAttribute\n                                   multiplier:self.layoutMultiplier\n                                     constant:self.layoutConstant];\n\nlayoutConstraint.priority = self.layoutPriority;\nlayoutConstraint.mas_key = self.mas_key;\n\n\n// 5\nif (self.secondViewAttribute.view) {\n    MAS_VIEW *closestCommonSuperview = [self.firstViewAttribute.view mas_closestCommonSuperview:self.secondViewAttribute.view];\n    NSAssert(closestCommonSuperview,\n             @"couldn\'t find a common superview for %@ and %@",\n             self.firstViewAttribute.view, self.secondViewAttribute.view);\n    self.installedView = closestCommonSuperview;\n} else if (self.firstViewAttribute.isSizeAttribute) {\n    self.installedView = self.firstViewAttribute.view;\n} else {\n    self.installedView = self.firstViewAttribute.view.superview;\n}\n\n\nMASLayoutConstraint *existingConstraint = nil;\nif (self.updateExisting) {\n    existingConstraint = [self layoutConstraintSimilarTo:layoutConstraint];\n}\nif (existingConstraint) {\n    // just update the constant\n    existingConstraint.constant = layoutConstraint.constant;\n    self.layoutConstraint = existingConstraint;\n} else {\n    [self.installedView addConstraint:layoutConstraint];\n    self.layoutConstraint = layoutConstraint;\n    [firstLayoutItem.mas_installedConstraints addObject:self];\n}\n}\n')])])]),n("p",[t._v("在对代码进行分析之前，我们需要知道：因为每个约束需要处理的，是两个item 之间的关系。")]),t._v(" "),n("blockquote",[n("p",[t._v("item1.attribute1 = multiplier × item2.attribute2 + constant // 约束等式")])]),t._v(" "),n("p",[t._v("所以"),n("code",[t._v("MASViewConstraint")]),t._v(" 有两个属性，分别是")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("@property (nonatomic, strong, readonly) MASViewAttribute *firstViewAttribute;\n")])])]),n("p",[t._v("和")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("@property (nonatomic, strong, readonly) MASViewAttribute *secondViewAttribute;\n")])])]),n("p",[t._v("这两个属性分别描述了约束等式的左边和右边。\n因此，代码的执行过程为：")]),t._v(" "),n("ol",[n("li",[t._v("将当前约束加入约束等式左边的view 的已安装约束列表中。")]),t._v(" "),n("li",[t._v("获取当前约束的左右两边的item 和它们对应的layoutAttribute。")]),t._v(" "),n("li",[t._v("如果item1 描述的不是数值，并且item2 为nil，则当前约束对应着前面所说的"),n("code",[t._v("equalTo(@100)")]),t._v("这种情况，所以当前的约束的item2 应该是item1中view 的superview。这和我们平时手写UI时的逻辑是相同的。")]),t._v(" "),n("li",[t._v("调用系统API 来进行约束设置。")]),t._v(" "),n("li",[t._v("如果item2 是一个view，那么这个约束应该被安装在item1 和item2 的共同superview 上，因此需要找到item1 和item2 的最近共同superview。其他情况同理。")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("- (instancetype)mas_closestCommonSuperview:(MAS_VIEW *)view {\n    MAS_VIEW *closestCommonSuperview = nil;\n\n    MAS_VIEW *secondViewSuperview = view;\n    while (!closestCommonSuperview && secondViewSuperview) {\n        MAS_VIEW *firstViewSuperview = self;\n        while (!closestCommonSuperview && firstViewSuperview) {\n            if (secondViewSuperview == firstViewSuperview) {\n                closestCommonSuperview = secondViewSuperview;\n            }\n            firstViewSuperview = firstViewSuperview.superview;\n        }\n        secondViewSuperview = secondViewSuperview.superview;\n    }\n    return closestCommonSuperview;\n}\n")])])]),n("h2",{attrs:{id:"小结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[t._v("#")]),t._v(" 小结")]),t._v(" "),n("p",[t._v("本文简要分析了用"),n("code",[t._v("Masonry")]),t._v(" 设置视图间布局约束时的代码的内部实现。从分析过程中，我感受到了写一个库的难度，也体会到了那句话的含义：“将简洁留给用户，将复杂留给自己”。无论是"),n("code",[t._v("SDWebImage")]),t._v(" 的一行代码设置图片还是"),n("code",[t._v("Masonry")]),t._v(" 的链式设置方法，其简洁的背后藏有复杂的逻辑，恼人的边界处理和多种策略的应用。")])])}),[],!1,null,null,null);e.default=a.exports}}]);