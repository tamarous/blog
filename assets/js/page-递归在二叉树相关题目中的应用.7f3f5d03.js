(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{485:function(e,r,t){"use strict";t.r(r);var n=t(1),o=Object(n.a)({},(function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"递归在二叉树相关题目中的应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#递归在二叉树相关题目中的应用"}},[e._v("#")]),e._v(" 递归在二叉树相关题目中的应用")]),e._v(" "),t("p",[e._v("最近集中刷了几道和二叉树有关的题目。由于二叉树本身就是递归定义的，因此使用递归算法解决二叉树的相关问题，不仅思路清晰，算法简单，而且代码量也比非递归的解法要小很多。在此将这些题目一并总结和记录一下。在介绍一般性的做法之前，先说一下自己总结出的经验。\n"),t("strong",[e._v("经验一")]),e._v("：使用一个辅助函数，在这个辅助函数中进行递归的操作，可以使代码变得更加简单。\n"),t("strong",[e._v("经验二")]),e._v("：在递归函数的开始处先处理特殊情况，也就是所谓的递归返回点。")]),e._v(" "),t("p",[e._v("下面是本文中二叉树的数据结构定义:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("struct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x):val(x)，left(NULL)，right(NULL){}\n};\n")])])]),t("ul",[t("li",[t("p",[e._v("合并两个二叉树，"),t("a",{attrs:{href:"https://leetcode.com/problems/merge-two-binary-trees/",target:"_blank",rel:"noopener noreferrer"}},[e._v("LeetCode-617-Merge Two Binary Trees"),t("OutboundLink")],1),e._v("。给出两个二叉树，将这个二叉树合并成一个新的二叉树。合并规则是对应位置上的值相加。最后返回新的二叉树的根节点。\n思路: 使用递归算法，在合并当前节点之前，先合并当前节点的左孩子和右孩子。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  class Solution {\n  public:\n      TreeNode *mergeTrees(TreeNode *t1, TreeNode *t2) {\n          if( !t1 && !t2) {\n              return NULL;\n          }\n          struct TreeNode *node = (TreeNode *)malloc(sizeof(TreeNode));\n          if (!t1 && t2) {\n              node->val = t2->val;\n              node->left = mergeTrees(NULL, t2->left);\n              node->right = mergeTrees(NULL, t2->right);\n          } \n          if (t1 && !t2) {\n              node->val = t1->val;\n              node->left = mergeTrees(t1->left, NULL);\n              node->right = mergeTrees(t1->right, NULL);\n          }\n          if (t1 && t2) {\n              node->val = t1->val + t2->val;\n              node->left = mergeTrees(t1->left, t2->left);\n              node->right = mergeTrees(t1->right, t2->right);\n          }\n          return node;\n      }\n  };\n")])])])]),e._v(" "),t("li",[t("p",[e._v("前中后各种遍历。使用递归算法时这三种遍历的思路都是一样的，区别只是访问root节点的顺序。另外这几种遍历方法也可以使用非递归的方式实现，不过需要借助栈、队列等额外的数据结构，详见我的另一篇"),t("a",{attrs:{href:"http://www.tamarous.com/2017/10/09/several-ways-of-travel-tree/",target:"_blank",rel:"noopener noreferrer"}},[e._v("博客"),t("OutboundLink")],1),e._v("。")])])]),e._v(" "),t("ol",[t("li",[t("p",[e._v("前序遍历")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v(" class Solution {\n public:\n     void preOrder(TreeNode *root) {\n         if(root == NULL) {\n             return;\n         }\n         cout << root->val << endl;\n         preOrder(root->left);\n         preOrder(root->right);\n     }\n }\n")])])])]),e._v(" "),t("li",[t("p",[e._v("中序遍历")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v(" class Solution {\n public:\n     void inOrder(TreeNode *root) {\n         if(root == NULL) {\n             return;\n         }\n         inOrder(root->left);\n         cout << root->val << endl;\n         inOrder(root->right);\n     }\n }\n")])])])]),e._v(" "),t("li",[t("p",[e._v("后序遍历")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v(" class Solution {\n public:\n     void postOrder(TreeNode *root) {\n         if(root == NULL) {\n             return;\n         }\n         postOrder(root->left);\n         postOrder(root->right);\n         cout << root->val << endl;\n     }\n }\n")])])])])]),e._v(" "),t("ul",[t("li",[t("p",[e._v("判断两个二叉树是否是相同的，"),t("a",{attrs:{href:"https://leetcode.com/problems/same-tree/",target:"_blank",rel:"noopener noreferrer"}},[e._v("LeetCode-100-Same Tree"),t("OutboundLink")],1),e._v("。 两个二叉树相同的定义是这两个二叉树的结构相同，并且对应位置上的节点的数值也相同。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  class Solution {\n  public:\n      bool isSameTree(TreeNode* p, TreeNode* q) {\n          if (!p && !q) {\n              return true;\n          }\n          if (p == NULL || q == NULL) {\n              return false;\n          }\n          if (p->val != q->val) {\n              return false;\n          }\n          return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\n      }\n  }; \n")])])])]),e._v(" "),t("li",[t("p",[e._v("判断一棵二叉树是否是对称的，"),t("a",{attrs:{href:"https://leetcode.com/problems/symmetric-tree/description/",target:"_blank",rel:"noopener noreferrer"}},[e._v("LeetCode-101-Symmetric Tree"),t("OutboundLink")],1),e._v("。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  class Solution {\n  public:\n      bool isSymmetric(TreeNode *root) {\n          if (root == NULL) {\n              return true;\n          }\n          return isSymmetricHelper(root->left, root->right);\n      }\n  private:\n      bool isSymmetricHelper(TreeNode *p,  TreeNode *q) {\n          if (!p && !q) {\n              return true;\n          }\n          if (p == NULL || q == NULL) {\n              return false;\n          }\n          return (p->val == q->val) && isSymmetricHelper(p->left, q->right) && isSymmetricHelper(p->right, q->left);\n      }\n  };\n")])])])]),e._v(" "),t("li",[t("p",[e._v("将一棵二叉树展平成一个单链表，"),t("a",{attrs:{href:"https://leetcode.com/problems/flatten-binary-tree-to-linked-list/description/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Flatten Binary Tree to Linked List"),t("OutboundLink")],1),e._v("。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  class Solution {\n  public:\n      void flatten(TreeNode* root) {\n          if(root == NULL) {\n              return;\n          }\n          flatten(root->right);\n          flatten(root->left);\n          root->right = prev;\n          root->left = NULL;\n          prev = root;\n      }   \n  private:\n      TreeNode *prev;\n  };\n")])])])]),e._v(" "),t("li",[t("p",[e._v("判断一棵树上是否存在一条路径，使得该路径上的所有节点的值的和等于给定的数字，"),t("a",{attrs:{href:"https://leetcode.com/problems/path-sum/",target:"_blank",rel:"noopener noreferrer"}},[e._v("LeetCode-112-Path Sum"),t("OutboundLink")],1),e._v("。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  class Solution {\n      public:\n          bool hasPathSum(TreeNode* root, int sum) {\n              bool hasSum = false;\n              helper(root, sum, hasSum);\n              return hasSum;\n          }\n      private:\n          void helper(TreeNode *root, int sum, bool &flag) {\n              if (root == NULL) {\n                  return;\n              }\n              sum -= root->val;\n              if (root->left == NULL && root->right == NULL) {\n                  if (sum == 0) {\n                      flag = true;\n                  }\n              } else {\n                  if (root->left != NULL) {\n                      helper(root->left, sum, flag);\n                  } \n                  if (root->right != NULL) {\n                      helper(root->right, sum, flag);\n                  }\n              }\n              \n              sum += root->val;\n          }\n  };\n")])])])]),e._v(" "),t("li",[t("p",[e._v("和上道题非常类似，但是要求求出所有的符合条件的路径，"),t("a",{attrs:{href:"https://leetcode.com/problems/path-sum-ii/description/",target:"_blank",rel:"noopener noreferrer"}},[e._v("LeetCode-437-Path Sum II"),t("OutboundLink")],1),e._v("。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("   class Solution {\n   public:\n       vector<vector<int> > pathSum(TreeNode *root, int sum) {\n           vector< vector<int> > results;\n           vector<int> result;\n           helper(root, sum, results,result);\n           return results;\n       }\n  \n   private:\n       void helper(TreeNode *root, int sum, vector<vector<int> > &paths,vector<int>& path) {\n           if (root == NULL) {\n               return;\n           }\n           sum -= root->val;\n           path.push_back(root->val);\n           if (root->left == NULL && root->right == NULL) {\n               if (sum == 0) {\n                   paths.push_back(path);\n               }\n           }\n           else {\n               if (root->left != NULL) {\n                   helper(root->left, sum, paths,path);\n               }\n               if (root->right != NULL) {\n                   helper(root->right, sum, paths,path);\n               }\n           }\n           sum += root->val;\n           path.pop_back();\n       }\n   };\n")])])])]),e._v(" "),t("li",[t("p",[e._v("修剪一棵二叉搜索树，"),t("a",{attrs:{href:"https://leetcode.com/problems/trim-a-binary-search-tree/description/",target:"_blank",rel:"noopener noreferrer"}},[e._v("LeetCode-669-Trim a Binary Search Tree"),t("OutboundLink")],1),e._v("。题干明确说明了该树是一棵二叉搜索树，所以具有如下的性质：某个节点的左子树上的每个节点的值都比该节点值小，而右子树上的每个节点的值都比该节点值大。因此，如果判断出当前节点的值在[L,R]之间，那么该节点就是一个子树的根节点；如果当前节点的值大于 R，那么根节点需要从它的左子树中寻找；如果当前节点的值小于 L，那么根节点需要从它的右子树中寻找。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  class Solution {\n  public:\n     TreeNode *trimBST(TreeNode *root ,int L, int R) {\n         if (root == NULL) {\n             return NULL;\n         }\n         if (root->val <= R && root->val >= L) {\n             root->left = trimBST(root->left, L, R);\n             root->right = trimBST(root->right, L, R);\n             return root;\n         } else {\n             if(root->val > R) {\n                 return trimBST(root->left,L,R);\n             } else if (root->val < L) {\n                 return trimBST(root->right, L, R);\n             }\n         }\n     }\n  };\n")])])])]),e._v(" "),t("li",[t("p",[e._v("求一棵二叉树的最大深度，"),t("a",{attrs:{href:"https://leetcode.com/problems/maximum-depth-of-binary-tree/description/",target:"_blank",rel:"noopener noreferrer"}},[e._v("LeetCode-104-Maximum Depth of Binary Tree"),t("OutboundLink")],1),e._v("。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  class Solution {\n  public:\n      int maxDepth(TreeNode* root) {\n          if (root == NULL) {\n              return 0;\n          }\n          return 1 + max(maxDepth(root->left),maxDepth(root->right));\n      }\n  };\n")])])])]),e._v(" "),t("li",[t("p",[e._v("求一棵二叉树的最小深度，"),t("a",{attrs:{href:"https://leetcode.com/problems/minimum-depth-of-binary-tree/description/",target:"_blank",rel:"noopener noreferrer"}},[e._v("LeetCode-111-Minimum Depth of Binary Tree"),t("OutboundLink")],1),e._v("。\n思路与上一题类似，不过要注意的是如果一个节点的左孩子或者右孩子为空的话，那么以这个节点为根节点的子树的 minDepth 为它的左孩子或右孩子的 minDepth。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  class Solution {\n  public:\n      int minDepth(TreeNode* root) {\n          if (root == NULL) {\n              return 0;\n          }\n          int left = minDepth(root->left);\n          int right = minDepth(root->right);\n          return (left == 0 || right == 0) ? (left+right+1):min(left,right)+1;\n      }\n  };\n")])])])]),e._v(" "),t("li",[t("p",[e._v("翻转一棵二叉树，"),t("a",{attrs:{href:"https://leetcode.com/problems/invert-binary-tree/description/",target:"_blank",rel:"noopener noreferrer"}},[e._v("LeetCode-226-Invert Binary Tree"),t("OutboundLink")],1),e._v("。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  class Solution {\n  public:\n      TreeNode *invertTree(TreeNode *root) {\n          if (root == NULL) {\n              return NULL;\n          }\n          // 先递归翻转该节点的左右子树\n          root->right = invertTree(root->right);\n          root->left = invertTree(root->left);\n          // 再交换该节点的左右孩子\n          TreeNode *node = root->left;\n          root->left = root->right;\n          root->right = node;\n          \n          \n          return root;\n      }\n  };\n")])])])]),e._v(" "),t("li",[t("p",[e._v("将一棵二叉搜索树变为一棵大树，"),t("a",{attrs:{href:"https://leetcode.com/problems/convert-bst-to-greater-tree/description/",target:"_blank",rel:"noopener noreferrer"}},[e._v("LeetCode-538-Convert BST to Greater Tree"),t("OutboundLink")],1),e._v("。也就是将一个节点的值更新为所有值大于该节点的节点的值之和。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  class Solution {\n  public:\n      TreeNode * convertBST(TreeNode *root) {\n          vector<int> nodes;\n          record(root, nodes);\n          helper(root, nodes);\n          return root;\n      }\n  \n  private:\n      void record(TreeNode *root, vector<int> &result) {\n          if (root == NULL) {\n              return;\n          }\n          result.push_back(root->val);\n          record(root->left, result);\n          record(root->right, result);\n      }\n      void helper(TreeNode *root, vector<int> &result) {\n          if (root == NULL) {\n              return;\n          }\n          int value = root->val;\n          vector<int>::iterator iter = result.begin();\n          for(iter; iter != result.end();iter++) {\n              if(*iter > value) {\n                  root->val += *iter;\n              }\n          }\n          helper(root->left,result);\n          helper(root->right,result);\n      }\n  };\n")])])])]),e._v(" "),t("li",[t("p",[e._v("求一棵二叉树所有左叶子节点的数值之和，"),t("a",{attrs:{href:"https://leetcode.com/problems/sum-of-left-leaves/description/",target:"_blank",rel:"noopener noreferrer"}},[e._v("LeetCode-404-Sum of Left Leaves"),t("OutboundLink")],1),e._v("。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("   class Solution {\n   public:\n       int sumOfLeftLeaves(TreeNode *root) {\n           if(root == NULL) {\n               return 0;\n           }\n           \n           // 当前节点的左孩子为叶子节点\n           if (root->left && !root->left->left && !root->left->right) {\n               return root->left->val + sumOfLeftLeaves(root->right);\n           }\n           \n           return sumOfLeftLeaves(root->left)+sumOfLeftLeaves(root->right);\n       }\n   };\n")])])])]),e._v(" "),t("li",[t("p",[e._v("对一棵二叉树进行层序遍历，"),t("a",{attrs:{href:"https://leetcode.com/problems/binary-tree-level-order-traversal/description/",target:"_blank",rel:"noopener noreferrer"}},[e._v("LeetCode-102-Binary Tree Level Order Traversal"),t("OutboundLink")],1),e._v("。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  class Solution {\n  public:\n      vector<vector<int>  > levelOrder(TreeNode *root) {\n          vector<vector<int> > result;\n          levelTravel(root, 1, result);\n          return result;\n      }\n  private:\n      void levelTravel(TreeNode *root, int level, vector<vector<int> > &result) {\n          if (root == NULL) {\n              return;\n          }\n          if (level > result.size()) {\n              result.push_back(vector<int>());\n          }\n          result[level-1].push_back(root->val);\n          levelTravel(root->left, level+1, result);\n          levelTravel(root->right, level+1, result);\n      }\n  }\n")])])])]),e._v(" "),t("li",[t("p",[e._v("求一棵二叉树的根节点到各个叶子节点的路径表示的值的和，"),t("a",{attrs:{href:"https://leetcode.com/problems/sum-root-to-leaf-numbers/description/",target:"_blank",rel:"noopener noreferrer"}},[e._v("LeetCode-129-Sum Root to Leaf Numbers"),t("OutboundLink")],1),e._v("。")])])]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("class Solution {\npublic:\n    int sumNumbers(TreeNode* root) {\n        return dfs(root, 0);\n        \n    }\n    int dfs(TreeNode *root, int sum) {\n        if (root == NULL) {\n            return 0;\n        }\n        if (! root->left && ! root->right) {\n            return sum * 10 + root->val;\n        }\n        return dfs(root->left, sum * 10 + root->val) + dfs(root->right, sum * 10 + root->val);\n    }\n};\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br"),t("span",{staticClass:"line-number"},[e._v("7")]),t("br"),t("span",{staticClass:"line-number"},[e._v("8")]),t("br"),t("span",{staticClass:"line-number"},[e._v("9")]),t("br"),t("span",{staticClass:"line-number"},[e._v("10")]),t("br"),t("span",{staticClass:"line-number"},[e._v("11")]),t("br"),t("span",{staticClass:"line-number"},[e._v("12")]),t("br"),t("span",{staticClass:"line-number"},[e._v("13")]),t("br"),t("span",{staticClass:"line-number"},[e._v("14")]),t("br"),t("span",{staticClass:"line-number"},[e._v("15")]),t("br"),t("span",{staticClass:"line-number"},[e._v("16")]),t("br")])])])}),[],!1,null,null,null);r.default=o.exports}}]);