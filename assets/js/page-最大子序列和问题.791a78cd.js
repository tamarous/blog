(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{510:function(n,t,i){"use strict";i.r(t);var r=i(1),a=Object(r.a)({},(function(){var n=this,t=n.$createElement,i=n._self._c||t;return i("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[i("h1",{attrs:{id:"最大子序列和问题"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#最大子序列和问题"}},[n._v("#")]),n._v(" 最大子序列和问题")]),n._v(" "),i("p",[n._v("最大子序列和问题是「数据结构与算法分析」一书开篇提出的问题，问题的描述是这样的：给定N个整数，求其中子序列之和的最大值。")]),n._v(" "),i("p",[n._v("那么最简单的方法，当然也是最低效的一种算法便是暴力求解法了，这种方法的思路是对数组进行双重遍历，将每一种可能性都计算出来与当前的最大值进行比较，如果大于该最大值，就将最大值更新为新计算出来的值。代码如下：")]),n._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[n._v("int maxSubSequence(const int array[], int N) {\n    int thisSum,maxSum,i,j,k;\n    thisSum = maxSum = 0;\n    for (i = 0; i < N;i++) {\n        for(j = i;j < N;j++) {\n            thisSum = 0;\n            for (k = i;k <= j;k++) {\n                thisSum += array[k];\n            }\n            if (thisSum > maxSum) {\n                maxSum = thisSum;\n            }\n        }\n    }\n    return maxSum;\n}\n")])])]),i("p",[n._v("易知该算法的时间复杂度为O(N^3)。")]),n._v(" "),i("p",[n._v("显然时间复杂度这么高的算法是不可以被接受的，因此有必要寻找一个更为简单高效的方法。\n书中紧接着给出了一个递归算法，该算法的时间复杂度为O(NlogN)，思路如下：首先我们知道，一个数组的最大子序列，要么出现在这个数组的前一半，要么出现在这个数组的后一半，要么横跨这个数组的左右两半，由两半的最大值求和得到。因此我们就可以缩小这个问题的规模，将这个问题转化为："),i("strong",[n._v("求前后两半以及中间数组的子序列的最大值，然后将这三个值的最大值作为整个数组的最大值")]),n._v("。")]),n._v(" "),i("p",[n._v("实现如下：")]),n._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[n._v("class Solution {\npublic:\n    static int maxSubSum(const int a[], int left, int right) {\n        int leftSum,rightSum,maxLeftSum,maxRightSum,leftPartSum,rightPartSum;\n        int center,i;\n    \n        // 说明数组中只有一个元素，因此直接返回它本身或者是0\n        if (left == right) {\n            return a[left];\n        }\n    \n        center = (left+right)/2;\n        leftSum = maxSubSum(a,left,center);\n        rightSum = maxSubSum(a,center+1,right);\n    \n        leftPartSum = 0;\n        maxLeftSum = INT_MIN;\n        for ( i = center; i >= left; i--) {\n            leftPartSum += a[i];\n            if (leftPartSum >= maxLeftSum) {\n                maxLeftSum = leftPartSum;\n            }\n        }\n    \n        rightPartSum = 0;\n        maxRightSum = INT_MIN;\n        for ( i = center+1;i <= right;i++)  {\n            rightPartSum += a[i];\n            if (rightPartSum >= maxRightSum) {\n                maxRightSum = rightPartSum;\n            }\n        }\n    \n        return max(leftSum,max(rightSum,maxLeftSum+maxRightSum));\n    }\n    \n    int maxSubsequenceSum(const int a[], int N) {\n        return maxSubSum(a,0,N-1);\n    }\n};\n")])])]),i("p",[n._v("该算法思路清晰，实现也比较简单，可以说是一种很不错的算法了。")]),n._v(" "),i("p",[n._v("不过，如果使用动态规划算法的话，那么可以在 O(N) 的时间复杂度内解决此问题：")]),n._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[n._v("class Solution {\npublic:\n    int FindGreatestSumOfSubArray(vector<int> array) {\n        int size = array.size();\n        if (size == 0) {\n            return 0;\n        }\n        if (size == 1) {\n            return array[0];\n        }\n        vector<int> dp(size);\n        dp[0] = array[0];\n        for(int i = 1; i < size; i++) {\n            if (dp[i-1] <= 0) {\n                dp[i] = array[i];\n            } else {\n                dp[i] = dp[i-1] + array[i];\n            }\n        }\n        int result = INT_MIN;\n        for(int i = 0; i < size; i++) {\n            result = max(result,dp[i]);\n        }\n        return result;\n    }\n};\n")])])]),i("p",[n._v("我们声明一个长度和输入数组相同的数组dp, dp[i] 表示以第 i 个数作为结尾的子数组的最大和。那么，如果当第 i-1 个数作为结尾的子数组的和小于0，即 dp[i-1] <= 0，如果把这个负数和 array[i] 相加，那么结果会比 array[i] 还小，因此以第 i 个数作为结尾的子数组的最大和应该为 array[i]；如果 dp[i-1] > 0，那么它与 array[i] 相加得到的就是以第 i 个数作为结尾的子数组的最大和。")])])}),[],!1,null,null,null);t.default=a.exports}}]);