(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{386:function(e,n,t){"use strict";t.r(n);var r=t(42),a=Object(r.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"单链表问题总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单链表问题总结"}},[e._v("#")]),e._v(" 单链表问题总结")]),e._v(" "),t("p",[e._v("这两天比较闲，因此刷了几道HackerRank上的题目，下面就将单链表的一些题目总结一下。首先给出这些题目中通用的单链表节点定义：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("struct Node {\n    int data;\n    struct Node *next;\n}\n")])])]),t("p",[e._v("第一题：顺序打印单链表中的元素。\n思路：从头节点处开始遍历输出，直至NULL。\n代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("void Print(Node *head)\n{\n    if (head == NULL) {\n        return;\n    } \n    Node *ptr = head;\n    while(ptr != NULL) {\n        cout << ptr->data << endl;\n        ptr = ptr->next;\n    }\n}\n")])])]),t("p",[e._v("第二题：给定一个数值，生成一个新数值并插入到单链表的尾部。\n思路：遍历到尾节点，然后创建一个新的节点，让尾节点的next指针指向这个新的节点。\n代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("Node* Insert(Node *head,int data)\n{\n    Node *newCell = (Node *)malloc(sizeof(Node));\n    newCell->data = data;\n    newCell->next = NULL;\n    if (head == NULL) {\n        return newCell;\n    } else {\n        Node *tail = head;\n        while(tail->next != NULL) {\n            tail = tail->next;\n        }\n        tail->next = newCell;\n        return head;\n    }\n}\n")])])]),t("p",[e._v("第三题：给定一个数值，生成一个新节点插入到单链表的头部。\n思路：创建一个新的节点，让这个新节点的next指针指向原来链表的头部。\n代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("Node* Insert(Node *head,int data)\n{\n    Node *newCell = (Node *)malloc(sizeof(Node));\n    newCell->data = data;\n    if (head == NULL) {\n        newCell->next = NULL;\n        return newCell;\n    } else {\n        newCell->next = head;\n        return newCell;\n    }\n}\n")])])]),t("p",[e._v("第四题：给定一个位置和数值，生成一个新节点并插入到单链表的相应位置处。\n思路：保持一个计数器，然后开始遍历单链表，同时计数器进行更新，当计数器的值与位置相等时，表示找到了要插入的位置了，之后的做法类似于第三题。\n代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("Node* InsertNth(Node *head, int data, int position)\n{ \n    Node *newCell = (Node *)malloc(sizeof(Node));\n    newCell->data = data;\n    if (head == NULL) {\n        newCell->next = NULL;\n        return newCell;\n    } else {\n        if (position == 0) {\n            newCell->next = head;\n            return newCell;\n        } else {\n            int i = 1;\n            Node *ptr = head;\n            while(ptr != NULL && i != position) {\n                i++;\n                ptr = ptr->next;\n            }\n            newCell->next = ptr->next;\n            ptr->next = newCell;\n            return head;\n        }\n    }\n}\n")])])]),t("p",[e._v("第五题：从单链表中删除一个给定位置处的节点。\n思路：很简单，不多说了。\n代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("Node* Delete(Node *head, int position)\n{\n    if (head == NULL) {\n        return NULL;\n    } else {\n        Node *ptrToNode;\n        if (position == 0) {\n            ptrToNode = head->next;\n            free(head);\n            return ptrToNode;\n        } else {\n            int i = 1;\n            ptrToNode = head;\n            while(ptrToNode != NULL && i != position) {\n                i++;\n                ptrToNode = ptrToNode->next;\n            }\n            Node *temp = ptrToNode->next;\n            ptrToNode->next = temp->next;\n            free(temp);\n            return head;\n        }\n    }\n}\n")])])]),t("p",[e._v("第六题：逆序打印单链表中的元素。\n思路：使用递归。\n代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("void ReversePrint(Node *head)\n{\n      if(head) {\n        ReversePrint(head->next);\n        cout << head->data << endl;\n    } else {\n        return;\n    }\n}\n")])])]),t("p",[e._v("第七题：将一个单链表中的所有元素逆序。\n思路：首先需要确定这个单链表是带有头节点的还是不带有头节点的，带有头节点的链表在处理起来稍微复杂一点。然后可以用三个指针，分别指向当前节点cur，前一个节点pre，后一个节点next，然后调整这三个节点之间的指向关系。\n代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("Node* Reverse(Node *head)\n{\n    if (head == NULL) {\n        return NULL;\n    } else {\n        Node *reverseHead = NULL;\n        Node *cur = head;\n        Node *pre = NULL;\n        Node *next = NULL;\n        while(cur != NULL) {\n            next = cur->next;\n            if (next == NULL) {\n                reverseHead = cur;\n            }\n            cur->next = pre;\n            pre = cur;\n            cur = next;\n        }\n        return reverseHead;\n    }\n}\n")])])]),t("p",[e._v("第八题：比较两个单链表中的元素是否相同\n思路：用两个指针分别遍历两个链表，然后比较指针指向的节点数值是否相等。\n代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("int CompareLists(Node *headA, Node* headB)\n{\n    if(headA == NULL && headB == NULL) {\n        return 0;\n    } else if ((!headA && headB) || (headA && !headB)){\n        return 0;\n    } else {\n            Node *ptrToA = headA, *ptrToB = headB;\n            while(ptrToA && ptrToB && (ptrToA->data == ptrToB->data)) {\n                ptrToA = ptrToA->next;\n                ptrToB = ptrToB->next;\n            }\n            if(ptrToA == NULL && ptrToB == NULL) {\n                return 1;\n            } else {\n                return 0;\n            }\n    }\n}\n")])])]),t("p",[e._v("第九题：合并两个有序单链表，将合并的结果放在一个新链表中。\n思路：用两个指针来分别遍历两个链表，比较这两个指针指向的节点的数值大小，\n若A<B,那么A++,拷贝A的数据到C,直到A>B;若A>B,则B++,拷贝B的数据到C,直到B>A;若A==B,则A++,B++,拷贝A或B到C。若其中一条链表先遍历完，则将另一条链表的数据直接拷贝到C中。\n代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("Node* MergeLists(Node *headA, Node* headB)\n{\n  if (headA == NULL && headB == NULL) {\n        return NULL;\n    } else if (! headA && headB) {\n        return headB;\n    } else if (headA && !headB) {\n        return headA;\n    } else {\n        Node *ptrToA = headA, *ptrToB = headB;\n        Node *cur = (Node *)malloc(sizeof(Node));\n        Node *head = cur;\n        while(ptrToA && ptrToB) {\n            while(ptrToA && ptrToB && (ptrToA->data < ptrToB->data)) {\n                Node *newCell = (Node *)malloc(sizeof(Node));\n                newCell->data = ptrToA->data;\n                cur->next = newCell;\n                cur = newCell;\n                ptrToA = ptrToA->next;\n            }\n            while(ptrToA && ptrToB && (ptrToA->data > ptrToB->data)) {\n                Node *newCell = (Node *)malloc(sizeof(Node));\n                newCell->data = ptrToB->data;\n                cur->next = newCell;\n                cur = newCell;\n                ptrToB = ptrToB->next;\n            }\n            while(ptrToA && ptrToB && (ptrToA->data == ptrToB->data)) {\n                Node *newCell = (Node *)malloc(sizeof(Node));\n                newCell->data = ptrToA->data;\n                cur->next = newCell;\n                cur = newCell;\n                ptrToA = ptrToA->next;\n                ptrToB = ptrToB->next;\n            }\n        }\n        if(!ptrToA && ptrToB) {\n            while(ptrToB) {\n                Node *newCell = (Node *)malloc(sizeof(Node));\n                newCell->data = ptrToB->data;\n                cur->next = newCell;\n                cur = newCell;\n                ptrToB = ptrToB->next;\n            }\n            cur->next = NULL;\n        } else if(ptrToA && !ptrToB) {\n            while(ptrToA) {\n                Node *newCell = (Node *)malloc(sizeof(Node));\n                newCell->data = ptrToA->data;\n                cur->next = newCell;\n                cur = newCell;\n                ptrToA = ptrToA->next;\n            }\n            cur->next = NULL;\n        } else if (!ptrToA && !ptrToB ) {\n            cur->next = NULL;\n        }\n        return head->next;\n    }\n}\n")])])]),t("p",[e._v("第十题：获得离一个链表尾部距离为K的节点。\n思路：设置两个指针，初始化时均指向头节点，然后让一个指针先往前移动K个节点，然后这两个指针再一起向前移动，当第一个指针指向链表的尾部时，第二个节点所指的位置正好就是离尾部距离为K的节点。\n代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('int GetNode(Node *head,int positionFromTail)\n{\n  // This is a "method-only" submission. \n  // You only need to complete this method. \n    Node *p, *cur;\n    p = cur = head;\n    for(int i = 0; i <= positionFromTail;i++) {\n        if (p != NULL) {\n            p = p->next;\n        }\n    }\n    while(p) {\n        cur = cur->next;\n        p = p->next;\n    }\n    return cur->data;\n}\n')])])]),t("p",[e._v("第十一题：删除一个有序单链表中的重复元素。\n思路：用两个指针分别指向当前节点cur和下一节点fol，当fol和cur的数值相等时，fol++，直到不再相等，调整cur和fol，然后cur++。\n代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("Node* RemoveDuplicates(Node *head)\n{\n    if(head == NULL) {\n        return NULL;\n    } else {\n        Node *cur = head, *fol = cur->next;\n        while(fol != NULL) {\n            while(fol && (fol->data == cur->data)) {\n                fol = fol->next;\n            }\n            cur->next = fol;\n            if(fol) {\n                cur = fol;\n                fol = cur->next;\n            }\n        }\n        return head;\n    }\n}\n")])])]),t("p",[e._v("第十二题：检测链表中是否有环。\n思路：使用两个指针，一个指针每次往前移动一个节点，一个指针每次往前移动两个节点，若是链表中有环的话，那么这两个指针一定会相遇，因此可以用这两个指针是否会相等来检测链表中有没有环。\n代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("bool has_cycle(Node* head) {\n    if(head == NULL) {\n        return false;\n    } else {\n        Node *p = head, *q = head;\n        while(p && q && q->next) {\n            q = q->next->next;\n            p = p->next;\n            if(p == q) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n")])])]),t("p",[e._v("第十三题：找到两个链表的合并点。\n思路：首先计算出这两个链表的长度和长度差，然后设置两个指针分别指向这两个链表的头部，让长的那个指针先移动长度差个节点，然后两个指针再一起向前移动，当这两个指针相等的时候，所指的点就是这两个链表的合并点。\n代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("int FindMergeNode(Node *headA, Node *headB)\n{\n    Node *ptrToA = headA,*ptrToB = headB;\n    int lenA,lenB;\n    lenA = lenB = 0;\n    while(ptrToA) {\n        lenA++;\n        ptrToA = ptrToA->next;\n    }\n    while(ptrToB) {\n        lenB++;\n        ptrToB = ptrToB->next;\n    }\n    ptrToA = headA,ptrToB = headB;\n    if(lenA < lenB) {\n        Node *temp = ptrToB;\n        ptrToB = ptrToA;\n        ptrToA = temp;\n        int x = lenA;\n        lenA = lenB;\n        lenB = x;\n    }\n    for(int i = 0; i < lenA-lenB;i++) {\n        ptrToA = ptrToA->next;\n    }\n    while(ptrToA && ptrToA != ptrToB) {\n        ptrToA = ptrToA->next;\n        ptrToB = ptrToB->next;\n    }\n    return ptrToA->data;\n}\n")])])]),t("p",[e._v("第十四题：向一个有序双向链表中插入一个节点。\n思路：和向单链表中插入节点思路相同，只不过节点的前后关系设置多了几步。\n代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("Node* SortedInsert(Node *head,int data)\n{\n    Node *newNode = (Node *)malloc(sizeof(Node));\n    newNode->data = data;\n    if(head == NULL) {\n        newNode->next = NULL;\n        newNode->prev = NULL;\n        return newNode;\n    } else {\n        if(data < head->data) {\n            newNode->next = head;\n            head->prev = newNode;\n            newNode->prev = NULL;\n            return newNode;\n        } else {\n            Node *ptr = head,*cur;\n            while(ptr && (data > ptr->data)) {\n                cur = ptr;\n                ptr = ptr->next;\n            }\n            if(! ptr) {\n                cur->next = newNode;\n                newNode->next = NULL;\n                newNode->prev = cur;\n                return head;\n            } else {\n                cur->next = newNode;\n                newNode->next = ptr;\n                newNode->prev = cur;\n                ptr->prev = newNode;\n            }\n            return head;\n        }\n    }\n}\n")])])]),t("p",[e._v("第十五题：逆序一个双向链表。\n思路：和逆序一个单链表思路一致，并且由于节点中本身就有prev和next信息，因此只需要用一个指针指向当前节点即可。\n代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("Node* Reverse(Node* head)\n{  \n    if (head == NULL) {\n        return NULL;\n    } \n    Node *cur = head, *next = NULL,*reversedHead = NULL;\n    while(cur) {\n        next = cur->next;\n        if (next == NULL) {\n            reversedHead = cur;\n        }\n        cur->next = cur->prev;\n        cur->prev = next;\n        cur = next;\n    }\n    return reversedHead;\n}\n")])])])])}),[],!1,null,null,null);n.default=a.exports}}]);