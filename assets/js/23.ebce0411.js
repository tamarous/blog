(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{379:function(t,e,n){"use strict";n.r(e);var s=n(42),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"leetcode-494-target-sum"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#leetcode-494-target-sum"}},[t._v("#")]),t._v(" LeetCode-494-Target Sum")]),t._v(" "),n("p",[n("a",{attrs:{href:"https://leetcode.com/problems/target-sum/description/",target:"_blank",rel:"noopener noreferrer"}},[t._v("这个题"),n("OutboundLink")],1),t._v("也是一道动态规划题目。题意是：给出一系列数和一个目标数，使用"),n("code",[t._v("+")]),t._v("和"),n("code",[t._v("-")]),t._v("来使这些数字的和等于给定的目标数，求总共可行的方法数。")]),t._v(" "),n("p",[t._v("例子：输入"),n("code",[t._v("[1, 1, 1, 1, 1]")]),t._v("，"),n("code",[t._v("target = 3")]),t._v("，那么：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("-1+1+1+1+1 = 3\n+1-1+1+1+1 = 3\n+1+1-1+1+1 = 3\n+1+1+1-1+1 = 3\n+1+1+1+1-1 = 3\n")])])]),n("p",[t._v("所以最后的输出结果是：5")]),t._v(" "),n("p",[t._v("思路：\n这个题比较类似于之前做过的求"),n("a",{attrs:{href:"http://www.tamarous.com/2017/11/26/path-sum/",target:"_blank",rel:"noopener noreferrer"}},[n("code",[t._v("二叉树上和为指定数值的路径")]),n("OutboundLink")],1),t._v("。我们可以写一个辅助函数")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("int process(vector<int> &nums, int target, int left, int right);\n")])])]),n("p",[t._v("这个函数计算：以 nums 的位于 left 和 right 之间的元素为输入，使用"),n("code",[t._v("+")]),t._v("和"),n("code",[t._v("-")]),t._v("使得这些数字之和等于 target 的方法数。声明一个 int 型变量 res，初始时 "),n("code",[t._v("res = 0")]),t._v("，表示总的方法数。对于当前区间"),n("code",[t._v("[i,j)")]),t._v("来说，如果我们对第一个数 "),n("code",[t._v("nums[i]")]),t._v("使用"),n("code",[t._v("+")]),t._v("，那么剩余的目标数为 "),n("code",[t._v("target - nums[i]")]),t._v("，如果我们对第一个数 "),n("code",[t._v("nums[i]")]),t._v("使用"),n("code",[t._v("-")]),t._v("，那么剩余的目标数为 "),n("code",[t._v("target+nums[i]")]),t._v("，所以有：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("res = process(nums,target-nums[i],left+1, right) + process(nums,target+nums[i],left+1,right)\n")])])]),n("p",[t._v("如果"),n("code",[t._v("left > right")]),t._v(", 此时如果 "),n("code",[t._v("target = 0")]),t._v("的话，那么这种方法就可以使得和为 target，返回1，否则就返回0。")]),t._v(" "),n("p",[t._v("根据以上分析，不难写出如下的代码：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class Solution {\npublic:\n    int findTargetSumWays(vector<int>& nums, int target) {\n        int size = nums.size();\n        if (size == 0) {\n            return 0;\n        }\n        return process(nums, target, 0, size);\n    }\n    int process(vector<int> &nums, int target, int left, int right) {\n        int size = nums.size();\n        if (left >= size) {\n            if (target == 0) {\n                return 1;\n            } else {\n                return 0;\n            }\n        }\n        int res = 0;\n        int cur = nums[i];\n        res = process(nums, target - nums[left], left + 1, right) + \n        process(nums, target + nums[left], left + 1, right);\n        return res;\n    }\n};\n")])])])])}),[],!1,null,null,null);e.default=r.exports}}]);