"use strict";(self.webpackChunktamarous_blog=self.webpackChunktamarous_blog||[]).push([[707],{2756:(n,s)=>{s.A=(n,s)=>{const a=n.__vccOpts||n;for(const[n,e]of s)a[n]=e;return a}},5364:(n,s,a)=>{a.r(s),a.d(s,{comp:()=>l,data:()=>p});var e=a(5399);const i={},l=(0,a(2756).A)(i,[["render",function(n,s){return(0,e.uX)(),(0,e.CE)("div",null,s[0]||(s[0]=[(0,e.Fv)('<h1 id="sdwebimage-源代码剖析-缓存策略" tabindex="-1"><a class="header-anchor" href="#sdwebimage-源代码剖析-缓存策略"><span>SDWebImage 源代码剖析-缓存策略</span></a></h1><p>今天我们将对另外一个在iOS 开发中广泛使用的库的源代码进行分析，这个库就是鼎鼎大名的<code>SDWebImage</code>。</p><h2 id="使用方法" tabindex="-1"><a class="header-anchor" href="#使用方法"><span>使用方法</span></a></h2><p><code>SDWebImage</code> 的使用非常简洁，往往可以用一行代码来完成图片设置工作。下面列出一些常用设置方法。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>- (void) sd_setImageWithURL:(nullable NSURL *) url;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>- (void) sd_setImageWithURL:(nullable NSURL *) url placeholderImage:(nullable UIImage *) placeholder;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>- (void) sd_setImageWithURL:(nullable NSURL *) url placeholderImage:(nullable UIImage *) placeholder options:(SDWebImageOptions) options;</span></span>\n<span class="line"><span>    </span></span>\n<span class="line"><span>- (void）sd_setImageWithURL:(nullable NSURL *) url completed:(nullable SDExternalCompletionBlock) completedBlock;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>- (void) sd_setImageWithURL:(nullable NSURL *) url placeholderImage:(nullable UIImage *) placeholder options:(SDWebImageOptions) options completed:(nullable SDExternalCompletionBlock) completedBlock;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>url 是远程图片的url 地址，placeholderImage 是远程图片尚未下载完成时显示的占位图片，completedBlock 是远程图片下载完成后将要执行的block，options 是一组NS_OPTIONS枚举值：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>typedef NS_OPTIONS(NSUInteger, SDWebImageOptions) {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    // 当按照给出的url 下载失败后，这个url 会被加入黑名单，</span></span>\n<span class="line"><span>    // 如果下次这个url 再次出现，就不会尝试去下载</span></span>\n<span class="line"><span>    SDWebImageRetryFailed = 1 &lt;&lt; 0,</span></span>\n<span class="line"><span>    </span></span>\n<span class="line"><span>    // 通常来说，图像下载是在UI交互过程中进行的，</span></span>\n<span class="line"><span>    // 如果使用这个flag 的话就会延迟图片的下载</span></span>\n<span class="line"><span>    SDWebImageLowPriority = 1 &lt;&lt; 1,</span></span>\n<span class="line"><span>    </span></span>\n<span class="line"><span>    // 禁止磁盘缓存，只允许内存缓存 </span></span>\n<span class="line"><span>    SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2,</span></span>\n<span class="line"><span>    </span></span>\n<span class="line"><span>    // 允许渐进式加载。默认的是加载完成才显示</span></span>\n<span class="line"><span>    SDWebImageProgressiveDownload = 1 &lt;&lt; 3,</span></span>\n<span class="line"><span>    </span></span>\n<span class="line"><span>    // 磁盘缓存将会由NSURLCache 而不是SDWebImage 来处理，因此可能带来轻微的性能下降。</span></span>\n<span class="line"><span>    // 使用于使用固定的图片url 但是图片内容可能变化的场景</span></span>\n<span class="line"><span>    SDWebImageRefreshCached = 1 &lt;&lt; 4,</span></span>\n<span class="line"><span>    </span></span>\n<span class="line"><span>    // 如果应用进入后台状态，继续图片下载，应用因此将会额外活跃一段时间，</span></span>\n<span class="line"><span>    // 如果这段时间用完但是下载任务尚未完成，那么下载就会被取消</span></span>\n<span class="line"><span>    SDWebImageContinueInBackground = 1 &lt;&lt; 5,</span></span>\n<span class="line"><span>    </span></span>\n<span class="line"><span>    // 处理存储在NSHTTPCookieStore 中的cookie</span></span>\n<span class="line"><span>    SDWebImageHandleCookie = 1 &lt;&lt; 6,</span></span>\n<span class="line"><span>    </span></span>\n<span class="line"><span>    // 允许不受信任的SSL认证。通常用于测试环境，很少用于生产环境</span></span>\n<span class="line"><span>    SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7,</span></span>\n<span class="line"><span>    </span></span>\n<span class="line"><span>    // 提高该图片下载的优先级</span></span>\n<span class="line"><span>    SDWebImageHighPriority = 1 &lt;&lt; 8,</span></span>\n<span class="line"><span>    </span></span>\n<span class="line"><span>    // 通常在图片加载时都会显示placeholder。但是这个flag 会将placeholder 的显示延迟到</span></span>\n<span class="line"><span>    // 图片加载之后（不是很懂这个选项的意思）</span></span>\n<span class="line"><span>    /**</span></span>\n<span class="line"><span>     * By default, placeholder images are loaded while the image is loading. This flag will delay the loading</span></span>\n<span class="line"><span>     * of the placeholder image until after the image has finished loading.</span></span>\n<span class="line"><span>     */</span></span>\n<span class="line"><span>    SDWebImageDelayPlaceholder = 1 &lt;&lt; 9,</span></span>\n<span class="line"><span>    </span></span>\n<span class="line"><span>    // 并不常用的方法。用于对下载的图片进行变换。</span></span>\n<span class="line"><span>    // 这个变换工作由实现了transformDownloadedImage 的协议的类完成</span></span>\n<span class="line"><span>    SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10,</span></span>\n<span class="line"><span>    </span></span>\n<span class="line"><span>    // 在下载完成之后将图片设置成imageView.image 之前，</span></span>\n<span class="line"><span>    // 允许你对下载的图片进行额外的处理</span></span>\n<span class="line"><span>    SDWebImageAvoidAutoSetImage = 1 &lt;&lt; 11,</span></span>\n<span class="line"><span>    </span></span>\n<span class="line"><span>    // 图片默认会被解码成它们的原始尺寸。这个flag 会将图片按照设备的内存来进行缩放。</span></span>\n<span class="line"><span>    // 如果SDWebImageProgressiveDownload 被设置了，那么这个选项就不起作用 </span></span>\n<span class="line"><span>    SDWebImageScaleDownLargeImages = 1 &lt;&lt; 12</span></span>\n<span class="line"><span>};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="内部实现" tabindex="-1"><a class="header-anchor" href="#内部实现"><span>内部实现</span></a></h2><h3 id="uiview-webcache" tabindex="-1"><a class="header-anchor" href="#uiview-webcache"><span>UIView+WebCache</span></a></h3><p>上面列出的方法其实是一个核心方法接受不同参数时的不同版本。</p><pre><code>- (void)sd_setImageWithURL:(nullable NSURL *)url\n      placeholderImage:(nullable UIImage *)placeholder\n               options:(SDWebImageOptions)options\n              progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock\n             completed:(nullable SDExternalCompletionBlock)completedBlock;\n</code></pre><p>这个核心方法内部是这样实现的：</p><pre><code>- (void)sd_setImageWithURL:(nullable NSURL *)url\n      placeholderImage:(nullable UIImage *)placeholder\n               options:(SDWebImageOptions)options\n              progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock\n             completed:(nullable SDExternalCompletionBlock)completedBlock {\n[self sd_internalSetImageWithURL:url\n                placeholderImage:placeholder\n                         options:options\n                    operationKey:nil\n                   setImageBlock:nil\n                        progress:progressBlock\n                       completed:completedBlock];\n}\n</code></pre><p>进入<code>sd_internalSetImageWithURL:</code> 这个方法的内部：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// UIView+WebCache.m</span></span>\n<span class="line"><span>- (void)sd_internalSetImageWithURL:(nullable NSURL *)url</span></span>\n<span class="line"><span>                  placeholderImage:(nullable UIImage *)placeholder</span></span>\n<span class="line"><span>                           options:(SDWebImageOptions)options</span></span>\n<span class="line"><span>                      operationKey:(nullable NSString *)operationKey</span></span>\n<span class="line"><span>                     setImageBlock:(nullable SDSetImageBlock)setImageBlock</span></span>\n<span class="line"><span>                          progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span></span>\n<span class="line"><span>                         completed:(nullable SDExternalCompletionBlock)completedBlock {</span></span>\n<span class="line"><span>    // 1</span></span>\n<span class="line"><span>    NSString *validOperationKey = operationKey ?: NSStringFromClass([self class]); </span></span>\n<span class="line"><span>    </span></span>\n<span class="line"><span>    // 2</span></span>\n<span class="line"><span>    [self sd_cancelImageLoadOperationWithKey:validOperationKey];</span></span>\n<span class="line"><span>    </span></span>\n<span class="line"><span>    // 3</span></span>\n<span class="line"><span>    objc_setAssociatedObject(self, &amp;imageURLKey, url, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span></span>\n<span class="line"><span>    </span></span>\n<span class="line"><span>    // 4</span></span>\n<span class="line"><span>    if (!(options &amp; SDWebImageDelayPlaceholder)) {</span></span>\n<span class="line"><span>        dispatch_main_async_safe(^{</span></span>\n<span class="line"><span>            [self sd_setImage:placeholder imageData:nil basedOnClassOrViaCustomSetImageBlock:setImageBlock];</span></span>\n<span class="line"><span>        });</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>    </span></span>\n<span class="line"><span>    if (url) {</span></span>\n<span class="line"><span>        // check if activityView is enabled or not</span></span>\n<span class="line"><span>        if ([self sd_showActivityIndicatorView]) {</span></span>\n<span class="line"><span>            [self sd_addActivityIndicator];</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>        </span></span>\n<span class="line"><span>        __weak __typeof(self)wself = self;</span></span>\n<span class="line"><span>        </span></span>\n<span class="line"><span>        // 5</span></span>\n<span class="line"><span>        id &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager loadImageWithURL:url options:options progress:progressBlock completed:^(UIImage *image, NSData *data, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) {</span></span>\n<span class="line"><span>            __strong __typeof (wself) sself = wself;</span></span>\n<span class="line"><span>            [sself sd_removeActivityIndicator];</span></span>\n<span class="line"><span>            if (!sself) {</span></span>\n<span class="line"><span>                return;</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span>            dispatch_main_async_safe(^{</span></span>\n<span class="line"><span>                if (!sself) {</span></span>\n<span class="line"><span>                    return;</span></span>\n<span class="line"><span>                }</span></span>\n<span class="line"><span>                // 6</span></span>\n<span class="line"><span>                if (image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage) &amp;&amp; completedBlock) {</span></span>\n<span class="line"><span>                    completedBlock(image, error, cacheType, url);</span></span>\n<span class="line"><span>                    return;</span></span>\n<span class="line"><span>                } else if (image) {</span></span>\n<span class="line"><span>                </span></span>\n<span class="line"><span>                    // 7</span></span>\n<span class="line"><span>                    [sself sd_setImage:image imageData:data basedOnClassOrViaCustomSetImageBlock:setImageBlock];</span></span>\n<span class="line"><span>                    [sself sd_setNeedsLayout];</span></span>\n<span class="line"><span>                } else {</span></span>\n<span class="line"><span>                    // 8</span></span>\n<span class="line"><span>                    if ((options &amp; SDWebImageDelayPlaceholder)) {</span></span>\n<span class="line"><span>                        [sself sd_setImage:placeholder imageData:nil basedOnClassOrViaCustomSetImageBlock:setImageBlock];</span></span>\n<span class="line"><span>                        [sself sd_setNeedsLayout];</span></span>\n<span class="line"><span>                    }</span></span>\n<span class="line"><span>                }</span></span>\n<span class="line"><span>                if (completedBlock &amp;&amp; finished) {</span></span>\n<span class="line"><span>                    completedBlock(image, error, cacheType, url);</span></span>\n<span class="line"><span>                }</span></span>\n<span class="line"><span>            });</span></span>\n<span class="line"><span>        }];</span></span>\n<span class="line"><span>        </span></span>\n<span class="line"><span>        // 9</span></span>\n<span class="line"><span>        [self sd_setImageLoadOperation:operation forKey:validOperationKey];</span></span>\n<span class="line"><span>    } else {</span></span>\n<span class="line"><span>        dispatch_main_async_safe(^{</span></span>\n<span class="line"><span>            [self sd_removeActivityIndicator];</span></span>\n<span class="line"><span>            if (completedBlock) {</span></span>\n<span class="line"><span>                NSError *error = [NSError errorWithDomain:SDWebImageErrorDomain code:-1 userInfo:@{NSLocalizedDescriptionKey : @&quot;Trying to load a nil url&quot;}];</span></span>\n<span class="line"><span>                completedBlock(nil, error, SDImageCacheTypeNone, url);</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span>        });</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>用当前视图的类名来作为一个key。<code>SDWebImage</code> 不仅能用来设置UIImageView，也可以用来设置UIButton。</li><li>在当前视图的operationDictionary 中进行查找，如果已经有key为operationKey 的operation，则取消这个operation。</li><li>将该远程图片的url 与当前视图的imageURLKey 用关联对象设置在一起。关于关联对象，网上也已经有很多不错的分析文章。</li><li>如果没有设置<code>SDWebImageDelayPlaceholder</code>这个选项，那么就先将当前视图设置成placeholder。</li><li>使用<code>SDWebImageManager</code>的<code>loadImageWithURL:</code> 创建一个operation 对象。</li><li>如果image下载完成了，并且设置了<code>SDWebImageAvoidAutoSetImage</code>选项，而且传入了对下载的图片进行处理的block，那么就进行对应处理。</li><li>如果image下载完成了，没有额外处理要求，那么将当前视图设置为image。</li><li>如果image下载失败了，那么还是将当前视图设置为placeholder。</li><li>将5中创建的operation 的key 设置为operationKey，然后加入当前视图的operationDictionary 中。</li></ol><h3 id="sdwebimagemanager" tabindex="-1"><a class="header-anchor" href="#sdwebimagemanager"><span>SDWebImageManager</span></a></h3><p>由代码可知，operation 这个对象是设置过程的核心与关键。既然它是<code>SDWebImageManager</code>创建的，我们自然要去探究下<code>SDWebImageManager</code>的内部秘密。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>- (id &lt;SDWebImageOperation&gt;)loadImageWithURL:(nullable NSURL *)url</span></span>\n<span class="line"><span>                                     options:(SDWebImageOptions)options</span></span>\n<span class="line"><span>                                    progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span></span>\n<span class="line"><span>                                   completed:(nullable SDInternalCompletionBlock)completedBlock {</span></span>\n<span class="line"><span>                                   </span></span>\n<span class="line"><span>    // 1</span></span>\n<span class="line"><span>    // Invoking this method without a completedBlock is pointless</span></span>\n<span class="line"><span>    NSAssert(completedBlock != nil, @&quot;If you mean to prefetch the image, use -[SDWebImagePrefetcher prefetchURLs] instead&quot;);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    ... </span></span>\n<span class="line"><span>    // 2</span></span>\n<span class="line"><span>    @synchronized (self.runningOperations) {</span></span>\n<span class="line"><span>        [self.runningOperations addObject:operation];</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>    </span></span>\n<span class="line"><span>    // 3</span></span>\n<span class="line"><span>    NSString *key = [self cacheKeyForURL:url];</span></span>\n<span class="line"><span>    </span></span>\n<span class="line"><span>    // 4</span></span>\n<span class="line"><span>    ...</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1" tabindex="-1"><a class="header-anchor" href="#_1"><span>1</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// Invoking this method without a completedBlock is pointless</span></span>\n<span class="line"><span>    NSAssert(completedBlock != nil, @&quot;If you mean to prefetch the image, use -[SDWebImagePrefetcher prefetchURLs] instead&quot;);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    // Very common mistake is to send the URL using NSString object instead of NSURL. For some strange reason, Xcode won&#39;t</span></span>\n<span class="line"><span>    // throw any warning for this type mismatch. Here we failsafe this error by allowing URLs to be passed as NSString.</span></span>\n<span class="line"><span>    if ([url isKindOfClass:NSString.class]) {</span></span>\n<span class="line"><span>        url = [NSURL URLWithString:(NSString *)url];</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    // Prevents app crashing on argument type error like sending NSNull instead of NSURL</span></span>\n<span class="line"><span>    if (![url isKindOfClass:NSURL.class]) {</span></span>\n<span class="line"><span>        url = nil;</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    __block SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new];</span></span>\n<span class="line"><span>    __weak SDWebImageCombinedOperation *weakOperation = operation;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    BOOL isFailedUrl = NO;</span></span>\n<span class="line"><span>    if (url) {</span></span>\n<span class="line"><span>        @synchronized (self.failedURLs) {</span></span>\n<span class="line"><span>            isFailedUrl = [self.failedURLs containsObject:url];</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    if (url.absoluteString.length == 0 || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) {</span></span>\n<span class="line"><span>        [self callCompletionBlockForOperation:operation completion:completedBlock error:[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil] url:url];</span></span>\n<span class="line"><span>        return operation;</span></span>\n<span class="line"><span>    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先进行异常处理。这是编程时一个常见的习惯，将可能遇到的各种问题和对应的解决方案放在方法的开头，可以使得逻辑变得清晰，同时也避免了无谓的函数调用开销。SDWebImage 团队贴心地为我们处理了常见的误将NSString 类型的对象传入NSURL 类型的参数的错误。这启示我们，在编写自己的库时，应尽可能考虑到各种常见错误，并对它们进行处理，这样可以使得你的库对于别的开发者更加友好。</p><h4 id="_2" tabindex="-1"><a class="header-anchor" href="#_2"><span>2</span></a></h4><p>将operation 加入<code>SDWebImageManager</code> 的runningOperations 数组中。</p><h4 id="_3" tabindex="-1"><a class="header-anchor" href="#_3"><span>3</span></a></h4><p>获得远程图片url 所对应的key。</p><pre><code>- (nullable NSString *)cacheKeyForURL:(nullable NSURL *)url {\nif (!url) {\n    return @&quot;&quot;;\n}\n\nif (self.cacheKeyFilter) {\n    // 如果定义了用来对url 进行过滤的filter，那么就用filter 来处理\n    return self.cacheKeyFilter(url);\n} else {\n    // 否则就返回url 的string表示\n    return url.absoluteString;\n}\n}\n</code></pre><h4 id="_4" tabindex="-1"><a class="header-anchor" href="#_4"><span>4</span></a></h4><p>先查询operation 的缓存操作。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>- (nullable NSOperation *)queryCacheOperationForKey:(nullable NSString *)key done:(nullable SDCacheQueryCompletedBlock)doneBlock {</span></span>\n<span class="line"><span>    if (!key) {</span></span>\n<span class="line"><span>        if (doneBlock) {</span></span>\n<span class="line"><span>            doneBlock(nil, nil, SDImageCacheTypeNone);</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>        return nil;</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    // First check the in-memory cache...   </span></span>\n<span class="line"><span>    // 首先检查该图片在内存中是否有缓存</span></span>\n<span class="line"><span>    UIImage *image = [self imageFromMemoryCacheForKey:key];</span></span>\n<span class="line"><span>    if (image) {</span></span>\n<span class="line"><span>        NSData *diskData = nil;</span></span>\n<span class="line"><span>        if ([image isGIF]) {</span></span>\n<span class="line"><span>            diskData = [self diskImageDataBySearchingAllPathsForKey:key];</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>        if (doneBlock) {</span></span>\n<span class="line"><span>            doneBlock(image, diskData, SDImageCacheTypeMemory);</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>        // 如果在内存中有缓存，这里就会直接返回了</span></span>\n<span class="line"><span>        return nil;</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    // 当该图片在内存中没有缓存的时候才会执行下面的代码</span></span>\n<span class="line"><span>    NSOperation *operation = [NSOperation new];</span></span>\n<span class="line"><span>    dispatch_async(self.ioQueue, ^{</span></span>\n<span class="line"><span>        if (operation.isCancelled) {</span></span>\n<span class="line"><span>            // do not call the completion if cancelled</span></span>\n<span class="line"><span>            return;</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        @autoreleasepool {</span></span>\n<span class="line"><span>        </span></span>\n<span class="line"><span>            // 获得该图片在磁盘中的缓存</span></span>\n<span class="line"><span>            NSData *diskData = [self diskImageDataBySearchingAllPathsForKey:key];</span></span>\n<span class="line"><span>            UIImage *diskImage = [self diskImageForKey:key];</span></span>\n<span class="line"><span>            if (diskImage &amp;&amp; self.config.shouldCacheImagesInMemory) {</span></span>\n<span class="line"><span>                NSUInteger cost = SDCacheCostForImage(diskImage);</span></span>\n<span class="line"><span>                // 将磁盘缓存保存在内存中</span></span>\n<span class="line"><span>                [self.memCache setObject:diskImage forKey:key cost:cost];</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>            if (doneBlock) {</span></span>\n<span class="line"><span>                dispatch_async(dispatch_get_main_queue(), ^{</span></span>\n<span class="line"><span>                    doneBlock(diskImage, diskData, SDImageCacheTypeDisk);</span></span>\n<span class="line"><span>                });</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    });</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    return operation;</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在查询到operation 的缓存操作后，设置doneBlock:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>operation.cacheOperation = [self.imageCache queryCacheOperationForKey:key done:^(UIImage *cachedImage, NSData *cachedData, SDImageCacheType cacheType) {</span></span>\n<span class="line"><span>        if (operation.isCancelled) {</span></span>\n<span class="line"><span>            [self safelyRemoveOperationFromRunning:operation];</span></span>\n<span class="line"><span>            return;</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>        // 1</span></span>\n<span class="line"><span>        if ((!cachedImage || options &amp; SDWebImageRefreshCached) &amp;&amp; (![self.delegate respondsToSelector:@selector(imageManager:shouldDownloadImageForURL:)] || [self.delegate imageManager:self shouldDownloadImageForURL:url])) {</span></span>\n<span class="line"><span>        </span></span>\n<span class="line"><span>            // 2</span></span>\n<span class="line"><span>            if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) {</span></span>\n<span class="line"><span>                // If image was found in the cache but SDWebImageRefreshCached is provided, notify about the cached image</span></span>\n<span class="line"><span>                // AND try to re-download it in order to let a chance to NSURLCache to refresh it from server.</span></span>\n<span class="line"><span>                [self callCompletionBlockForOperation:weakOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url];</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>            // download if no image or requested to refresh anyway, and download allowed by delegate</span></span>\n<span class="line"><span>            // 3</span></span>\n<span class="line"><span>            SDWebImageDownloaderOptions downloaderOptions = 0;</span></span>\n<span class="line"><span>            if (options &amp; SDWebImageLowPriority) downloaderOptions |= SDWebImageDownloaderLowPriority;</span></span>\n<span class="line"><span>            if (options &amp; SDWebImageProgressiveDownload) downloaderOptions |= SDWebImageDownloaderProgressiveDownload;</span></span>\n<span class="line"><span>            if (options &amp; SDWebImageRefreshCached) downloaderOptions |= SDWebImageDownloaderUseNSURLCache;</span></span>\n<span class="line"><span>            if (options &amp; SDWebImageContinueInBackground) downloaderOptions |= SDWebImageDownloaderContinueInBackground;</span></span>\n<span class="line"><span>            if (options &amp; SDWebImageHandleCookies) downloaderOptions |= SDWebImageDownloaderHandleCookies;</span></span>\n<span class="line"><span>            if (options &amp; SDWebImageAllowInvalidSSLCertificates) downloaderOptions |= SDWebImageDownloaderAllowInvalidSSLCertificates;</span></span>\n<span class="line"><span>            if (options &amp; SDWebImageHighPriority) downloaderOptions |= SDWebImageDownloaderHighPriority;</span></span>\n<span class="line"><span>            if (options &amp; SDWebImageScaleDownLargeImages) downloaderOptions |= SDWebImageDownloaderScaleDownLargeImages;</span></span>\n<span class="line"><span>            </span></span>\n<span class="line"><span>            // 4</span></span>\n<span class="line"><span>            if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) {</span></span>\n<span class="line"><span>                // force progressive off if image already cached but forced refreshing</span></span>\n<span class="line"><span>                downloaderOptions &amp;= ~SDWebImageDownloaderProgressiveDownload;</span></span>\n<span class="line"><span>                // ignore image read from NSURLCache if image if cached but force refreshing</span></span>\n<span class="line"><span>                downloaderOptions |= SDWebImageDownloaderIgnoreCachedResponse;</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span>            </span></span>\n<span class="line"><span>            // 5</span></span>\n<span class="line"><span>            SDWebImageDownloadToken *subOperationToken = [self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage *downloadedImage, NSData *downloadedData, NSError *error, BOOL finished) {</span></span>\n<span class="line"><span>                __strong __typeof(weakOperation) strongOperation = weakOperation;</span></span>\n<span class="line"><span>                if (!strongOperation || strongOperation.isCancelled) {</span></span>\n<span class="line"><span>                    // Do nothing if the operation was cancelled</span></span>\n<span class="line"><span>                    // See #699 for more details</span></span>\n<span class="line"><span>                    // if we would call the completedBlock, there could be a race condition between this block and another completedBlock for the same object, so if this one is called second, we will overwrite the new data</span></span>\n<span class="line"><span>                } else if (error) {</span></span>\n<span class="line"><span>                    [self callCompletionBlockForOperation:strongOperation completion:completedBlock error:error url:url];</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>                    // 6</span></span>\n<span class="line"><span>                    if (   error.code != NSURLErrorNotConnectedToInternet</span></span>\n<span class="line"><span>                        &amp;&amp; error.code != NSURLErrorCancelled</span></span>\n<span class="line"><span>                        &amp;&amp; error.code != NSURLErrorTimedOut</span></span>\n<span class="line"><span>                        &amp;&amp; error.code != NSURLErrorInternationalRoamingOff</span></span>\n<span class="line"><span>                        &amp;&amp; error.code != NSURLErrorDataNotAllowed</span></span>\n<span class="line"><span>                        &amp;&amp; error.code != NSURLErrorCannotFindHost</span></span>\n<span class="line"><span>                        &amp;&amp; error.code != NSURLErrorCannotConnectToHost</span></span>\n<span class="line"><span>                        &amp;&amp; error.code != NSURLErrorNetworkConnectionLost) {</span></span>\n<span class="line"><span>                        @synchronized (self.failedURLs) {</span></span>\n<span class="line"><span>                            [self.failedURLs addObject:url];</span></span>\n<span class="line"><span>                        }</span></span>\n<span class="line"><span>                    }</span></span>\n<span class="line"><span>                }</span></span>\n<span class="line"><span>                else {</span></span>\n<span class="line"><span>                    if ((options &amp; SDWebImageRetryFailed)) {</span></span>\n<span class="line"><span>                        @synchronized (self.failedURLs) {</span></span>\n<span class="line"><span>                            [self.failedURLs removeObject:url];</span></span>\n<span class="line"><span>                        }</span></span>\n<span class="line"><span>                    }</span></span>\n<span class="line"><span>                    </span></span>\n<span class="line"><span>                    </span></span>\n<span class="line"><span>                    BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>                    // 7</span></span>\n<span class="line"><span>                    if (options &amp; SDWebImageRefreshCached &amp;&amp; cachedImage &amp;&amp; !downloadedImage) {</span></span>\n<span class="line"><span>                        // Image refresh hit the NSURLCache cache, do not call the completion block</span></span>\n<span class="line"><span>                    } else if (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)]) {</span></span>\n<span class="line"><span>                        </span></span>\n<span class="line"><span>// 8</span></span>\n<span class="line"><span>dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{</span></span>\n<span class="line"><span>                            UIImage *transformedImage = [self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url];</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>                            if (transformedImage &amp;&amp; finished) {</span></span>\n<span class="line"><span>                                BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage];</span></span>\n<span class="line"><span>                                // pass nil if the image was transformed, so we can recalculate the data from the image</span></span>\n<span class="line"><span>                                [self.imageCache storeImage:transformedImage imageData:(imageWasTransformed ? nil : downloadedData) forKey:key toDisk:cacheOnDisk completion:nil];</span></span>\n<span class="line"><span>                            }</span></span>\n<span class="line"><span>                            </span></span>\n<span class="line"><span>                            [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:transformedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url];</span></span>\n<span class="line"><span>                        });</span></span>\n<span class="line"><span>                    } else {</span></span>\n<span class="line"><span>                        if (downloadedImage &amp;&amp; finished) {</span></span>\n<span class="line"><span>                            [self.imageCache storeImage:downloadedImage imageData:downloadedData forKey:key toDisk:cacheOnDisk completion:nil];</span></span>\n<span class="line"><span>                        }</span></span>\n<span class="line"><span>                        [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:downloadedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url];</span></span>\n<span class="line"><span>                    }</span></span>\n<span class="line"><span>                }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>                if (finished) {</span></span>\n<span class="line"><span>                    [self safelyRemoveOperationFromRunning:strongOperation];</span></span>\n<span class="line"><span>                }</span></span>\n<span class="line"><span>            }];</span></span>\n<span class="line"><span>            operation.cancelBlock = ^{</span></span>\n<span class="line"><span>                [self.imageDownloader cancel:subOperationToken];</span></span>\n<span class="line"><span>                __strong __typeof(weakOperation) strongOperation = weakOperation;</span></span>\n<span class="line"><span>                [self safelyRemoveOperationFromRunning:strongOperation];</span></span>\n<span class="line"><span>            };</span></span>\n<span class="line"><span>        } else if (cachedImage) {</span></span>\n<span class="line"><span>        </span></span>\n<span class="line"><span>            // 9</span></span>\n<span class="line"><span>            __strong __typeof(weakOperation) strongOperation = weakOperation;</span></span>\n<span class="line"><span>            [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url];</span></span>\n<span class="line"><span>            [self safelyRemoveOperationFromRunning:operation];</span></span>\n<span class="line"><span>        } else {</span></span>\n<span class="line"><span>            // Image not in cache and download disallowed by delegate</span></span>\n<span class="line"><span>            </span></span>\n<span class="line"><span>            // 10</span></span>\n<span class="line"><span>            __strong __typeof(weakOperation) strongOperation = weakOperation;</span></span>\n<span class="line"><span>            [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:nil data:nil error:nil cacheType:SDImageCacheTypeNone finished:YES url:url];</span></span>\n<span class="line"><span>            [self safelyRemoveOperationFromRunning:operation];</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }];</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>由if条件，假设后一条件成立，如果缓存存在，那么只有在设置了<code>SDWebImageRefreshCache</code>才会进入if 语句体中；如果缓存不存在，那么肯定会进入if 语句体中。</li><li>如果说缓存存在，而且设置了<code>SDWebImageRefreshCache</code>，那么就应该从server 上重新下载图片以更新本地缓存。</li><li>设置下载时的选项。</li><li>如果设置了<code>SDWebImageRefreshCache</code>，那么必须取消渐进式下载，而且还要忽略从NSURLCache 中获得的缓存响应。</li><li>调用imageDownloader 进行图片下载。</li><li>如果发生了错误，且错误原因不是列出来的这些原因中的一个，那么就把这个url 加入黑名单中。</li><li>如果缓存存在，设置了<code>SDWebImageRefreshCache</code>，而且downloadedImage为nil，那么说明命中了 NSURLCache 缓存，什么事也不做。</li><li>如果downloadedImage非nil，并且设置了<code>SDWebImageTransformAnimatedImage</code>，那么就在主线程中对图片进行变换，然后将变换后的图片存储在内存中或内存和磁盘上。如果不需要变换，那么直接将downloadedImage 存储在内存中或内存和磁盘上。</li><li>如果缓存存在，且其他条件都不成立，那么直接取出缓存中的图片，然后在主线程中更新视图。</li><li>如果缓存不存在，并且也不允许下载，那么直接调用completedBlock。</li></ol><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结"><span>小结</span></a></h2><p>我们来小结一下<code>SDWebImage</code>的缓存策略。在给一个UIimageView 或者UIButton 设置了远端图片的url 后，<code>SDWebImage</code>首先以url 为key 在内存中寻找图片缓存，如果在内存中没找到就会去磁盘中寻找，如果找到了，则将磁盘中的缓存拷贝一份到内存中，然后使用缓存来设置视图。如果在 磁盘和内存中都没有找到，那么才会下载远程图片，然后将远程图片缓存在内存中或者是内存和磁盘上。</p>',35)]))}]]),p=JSON.parse('{"path":"/iOS/sdwebimage_cache.html","title":"SDWebImage 源代码剖析-缓存策略","lang":"en-US","frontmatter":{"category":"iOS","tags":["源码分析"]},"git":{"createdTime":1740831350000,"updatedTime":1740831350000,"contributors":[{"name":"wangzewei","username":"wangzewei","email":"hiwangzewei@qq.com","commits":1,"url":"https://github.com/wangzewei"}]},"readingTime":{"minutes":10.13,"words":3040},"filePathRelative":"iOS/sdwebimage_cache.md","localizedDate":"March 1, 2025","excerpt":"\\n<p>今天我们将对另外一个在iOS 开发中广泛使用的库的源代码进行分析，这个库就是鼎鼎大名的<code>SDWebImage</code>。</p>\\n<h2>使用方法</h2>\\n<p><code>SDWebImage</code> 的使用非常简洁，往往可以用一行代码来完成图片设置工作。下面列出一些常用设置方法。</p>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>- (void) sd_setImageWithURL:(nullable NSURL *) url;</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>- (void) sd_setImageWithURL:(nullable NSURL *) url placeholderImage:(nullable UIImage *) placeholder;</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>- (void) sd_setImageWithURL:(nullable NSURL *) url placeholderImage:(nullable UIImage *) placeholder options:(SDWebImageOptions) options;</span></span>\\n<span class=\\"line\\"><span>    </span></span>\\n<span class=\\"line\\"><span>- (void）sd_setImageWithURL:(nullable NSURL *) url completed:(nullable SDExternalCompletionBlock) completedBlock;</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>- (void) sd_setImageWithURL:(nullable NSURL *) url placeholderImage:(nullable UIImage *) placeholder options:(SDWebImageOptions) options completed:(nullable SDExternalCompletionBlock) completedBlock;</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>"}')}}]);