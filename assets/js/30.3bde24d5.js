(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{386:function(e,n,r){"use strict";r.r(n);var t=r(42),o=Object(t.a)({},(function(){var e=this,n=e.$createElement,r=e._self._c||n;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"前中后序遍历的非递归实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#前中后序遍历的非递归实现"}},[e._v("#")]),e._v(" 前中后序遍历的非递归实现")]),e._v(" "),r("p",[e._v("前、中、后序遍历是对树进行的基础操作，当使用递归来实现时代码非常简单。但是由于递归时会不断将当前状态保存下来，因此在这些状态之间进行切换也非常耗费时间。下面就介绍一下用非递归的方式如何来实现这些操作。另外在本文最后还介绍了一下层序遍历。")]),e._v(" "),r("p",[r("img",{attrs:{src:"http://7xnyik.com1.z0.glb.clouddn.com/binaryTree.png",alt:"Binary Tree Travel"}})]),e._v(" "),r("p",[e._v("二叉树的数据结构定义如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v("struct TreeNode {\n    TreeNode *left;\n    TreeNode *right;\n    int val;\n    TreeNode(int x): val(x), left(NULL),right(NULL) {}\n}\n")])])]),r("ul",[r("li",[r("p",[e._v("前序遍历：非递归遍历通过栈来实现，并且有两种不同的实现方式。思路一是先将根节点压入栈，然后当栈不为空的时候，先将栈顶元素出栈并访问这个节点，然后依次将该节点的"),r("strong",[e._v("右孩子")]),e._v("和"),r("strong",[e._v("左孩子")]),e._v("入栈。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v("  void preOrder(TreeNode *root) {\n      if(root == NULL) {\n          return;\n      }\n      stack<struct TreeNode *> s;\n      s.push(root);\n      while(! s.empty()) {\n          TreeNode *node = s.top();\n          s.pop();\n          cout << node->val << endl;\n          if (node->right) {\n              s.push(node->right);\n          }\n          if (node->left) {\n              s.push(node->left);\n          }\n      }\n  }\n")])])])])]),e._v(" "),r("p",[e._v("思路二则是使用回溯，先遍历完左子树，然后回溯遍历右子树。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v("    void preOrder_(TreeNode *root) {\n        if (root == NULL) {\n            return;\n        }\n        stack<TreeNode *> s;\n        TreeNode *ptr = root;\n        while(ptr != NULL && ! s.empty()) {\n            if(ptr != NULL) {\n            \n                // 访问当前节点\n                cout << ptr->val << endl;\n                s.push(ptr);\n                ptr = ptr->left;\n            } else {\n            // 当 ptr 为空的时候，说明刚刚入栈的那个节点的左子树已经遍历完了\n            // 因此应该把它弹出来然后遍历它的右子树了\n                ptr = s.top();\n                s.pop();\n                ptr = ptr->right;\n            }\n        }\n    }\n")])])]),r("ul",[r("li",[r("p",[e._v("中序遍历：和前序遍历的实现非常类似，只不过访问节点的时机不同。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v("  void inOrder(TreeNode *root) {\n      if (root == NULL) {\n          return;\n      }\n      stack<TreeNode *> s;\n      TreeNode *ptr = root;\n      while(ptr != NULL && ! s.empty()) {\n          if (ptr != NULL) {\n              s.push(ptr);\n              ptr = ptr->left;\n          } else {\n              ptr = s.top();\n              s.pop();\n              cout << ptr->val << endl;\n              ptr = ptr->right;\n          }\n      }\n  }\n")])])])]),e._v(" "),r("li",[r("p",[e._v("后序遍历：后序遍历是这几种遍历方式中比较麻烦的一种。前面的算法的规律是，当一个节点的左子树已经访问完了后，会将当前节点从栈中直接弹出并访问这个节点，然后再遍历它的右子树。但是后序遍历时，当访问完一个节点的左子树后，先得从栈顶获得这个节点，得到它的右子树并访问右子树，当右子树访问之后，再从栈顶获得这个节点，然后去访问这个节点自身，然后将该节点出栈。可以看出，访问该节点的过程发生了两次，但是只有访问了它的右子树后才可以将这个节点从栈中弹出。因此我们需要标记该节点是否被访问过。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v("  void postOrder(TreeNode *root) {\n      if (root == NULL) {\n          return NULL;\n      }\n      stack<TreeNode *> s;\n      TreeNode *cur = root, *lastVisited = NULL;\n      while(cur) {\n          s.push(cur);\n          cur = cur->left;\n      }\n      while(! s.empty()) {\n          cur = s.top();\n          s.pop(); // 将某个节点第一次从栈中 pop 出来\n  \n          // 如果这个节点没有右子树，或者是这个节点的右子树已经被访问过了\n          // 那么就直接访问这个节点\n          if (cur->right == NULL || cur->right == lastVisited) {\n              cout << cur->val << endl;\n              lastVisited = cur;\n          } else {\n  \n              // 将这个节点再次入栈\n              s.push(cur);\n              cur = cur->right;\n              while(cur) {\n                  s.push(cur);\n                  cur = cur->right;\n              }\n          }\n      }\n  }\n")])])])]),e._v(" "),r("li",[r("p",[e._v("层序遍历：作为树的遍历方式的一种，虽然不如前面三种方式常见，但是也是非常有必要了解的。与前面三种方式不同的是，层序遍历使用了队列而不是栈这种结构。思路是：先将根节点入队，当队列不为空的时候，从队列头出队一个元素并访问它，然后将它的左右孩子依次入队。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v("  void levelOrder(TreeNode *root) {\n      if (root == NULL) {\n          return NULL;\n      }\n      Queue<TreeNode *> queue = new Queue<>();\n      queue.push(root);\n      while (! queue.empty()) {\n          TreeNode *node = queue.front();\n          queue.pop();\n          cout << node->val << endl;\n          if (node->left) {\n              queue.push(node->left);\n          }\n          if (node->right) {\n              queue.push(node->right);\n          }\n      }\n  }\n")])])])])])])}),[],!1,null,null,null);n.default=o.exports}}]);