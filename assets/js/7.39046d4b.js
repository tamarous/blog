(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{363:function(t,n,e){"use strict";e.r(n);var i=e(42),r=Object(i.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"leetcode-上几道经典的排列组合题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#leetcode-上几道经典的排列组合题"}},[t._v("#")]),t._v(" LeetCode 上几道经典的排列组合题")]),t._v(" "),e("p",[t._v("LeetCode 上有几道题都和排列组合有关，非常经典，值得放在一起总结一下。这几道题分别是：")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://leetcode.com/problems/permutations/description/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Permutations"),e("OutboundLink")],1),t._v("。给定一组各不相同的数字，求这些数字的所有排列。")]),t._v(" "),e("li",[e("a",{attrs:{href:"https://leetcode.com/problems/permutations-ii/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Permutations II"),e("OutboundLink")],1),t._v("。给定一组数字，这些数字中可能有重复的，求这些数字的所有不重复的排列。")]),t._v(" "),e("li",[e("a",{attrs:{href:"https://leetcode.com/problems/next-permutation/description/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Next Permutation"),e("OutboundLink")],1),t._v("。给定一组数字的全排列中的一个排列，求这个排列的下一个排列。")]),t._v(" "),e("li",[e("a",{attrs:{href:"https://leetcode.com/problems/permutation-sequence/description/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Permutation Sequence"),e("OutboundLink")],1),t._v("。给定一组数字和一个数字 K，求这组数字的全排列中，按照字典序顺序排序的第 K 个排列。")])]),t._v(" "),e("h2",{attrs:{id:"permutations"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#permutations"}},[t._v("#")]),t._v(" Permutations")]),t._v(" "),e("p",[t._v("对于一个集合来说，它的全排列是指集合内元素的所有可能的排列。以输入"),e("code",[t._v("[1,2,3]")]),t._v("为例，它的全排列是"),e("code",[t._v("[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]")]),t._v("这六种情况。求一个集合的全排列有很多种方法，本文中将介绍一下最为常见的两种方法，字典序法和递归法。")]),t._v(" "),e("h3",{attrs:{id:"字典序法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#字典序法"}},[t._v("#")]),t._v(" 字典序法")]),t._v(" "),e("p",[t._v("字典序法，就是将元素按照字典的顺序进行排列，而对于数字来说，就是将较小的数字排在较大的数字的前面。上面列出的"),e("code",[t._v("[1,2,3]")]),t._v("的全排列就是按照字典序的顺序排列的。由输入排列产生下一排列时，字典序法要求它与当前排列有尽可能长的公共前缀，因此针对输入的"),e("code",[t._v("1,2,3")]),t._v("，使用字典序法生成全排列，就是依次生成"),e("code",[t._v("1,3,2")]),t._v("，"),e("code",[t._v("2,1,3")]),t._v("，"),e("code",[t._v("2,3,1")]),t._v("，"),e("code",[t._v("3,1,2")]),t._v("，"),e("code",[t._v("3,2,1")]),t._v("。那么如何根据当前排列来生成下一排列呢？")]),t._v(" "),e("p",[t._v("已知当前排列，求下一排列的算法过程：")]),t._v(" "),e("ol",[e("li",[t._v("对于给定排列nums,从左向右，找出第一个违反从左到右是递增顺序的数字，记为i。以"),e("code",[t._v("[6,8,7,4,3,2]")]),t._v("为例，从右向左一直是增加的，直到6的出现打破了这一规律，因此i = 6。")]),t._v(" "),e("li",[t._v("从右向左，找出第一个比刚刚找到的数字大的数字，记为j。对于"),e("code",[t._v("[6,8,7,4,3,2]")]),t._v("，从右到左一次是2,3,4,7，因此这个数字是7，j=7。")]),t._v(" "),e("li",[t._v("交换这两个数字。即将"),e("code",[t._v("[6,8,7,4,3,2]")]),t._v("中的6和7进行交换，变为"),e("code",[t._v("[7,8,6,4,3,2]")]),t._v("。")]),t._v(" "),e("li",[t._v("将j右边的所有数字进行逆序，即将7右边的"),e("code",[t._v("[8,6,4,3,2]")]),t._v("逆序，"),e("code",[t._v("[7,8,6,4,3,2]")]),t._v("变为"),e("code",[t._v("[7,2,3,4,6,8]")]),t._v("。算法结束。")])]),t._v(" "),e("p",[t._v("这里引用一下"),e("a",{attrs:{href:"http://fisherlei.blogspot.com/2012/12/leetcode-next-permutation.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("水中的鱼"),e("OutboundLink")],1),t._v("的图片，可以对整个过程有更加直观的认识：\n"),e("img",{attrs:{src:"http://4.bp.blogspot.com/-4zN0u5JG0vs/UN0xPEkP5yI/AAAAAAAAG9Q/O48ZfwB1i_c/s1600/Picture4.png",alt:"水中的鱼"}})]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class Solution {\npublic:\n    void nextPermutation(vector<int>& nums) {\n        if (nums.size() <= 0) {\n            return;\n        }\n        int size = nums.size();\n        int violationIndex = size-1;\n        while(violationIndex > 0) {\n            if (nums[violationIndex] > nums[violationIndex-1]) {\n                break;\n            } \n            violationIndex --;\n        } \n        if (violationIndex > 0) {\n            violationIndex--;\n            int changeIndex = size -1 ;\n            for(;changeIndex>= 0 ;changeIndex--) {\n                if (nums[changeIndex] > nums[violationIndex]) {\n                    break;\n                }\n            }\n            swap(nums[changeIndex],nums[violationIndex]);   \n            violationIndex++;\n        }\n        reverse(nums.begin()+violationIndex, nums.end());\n    }  \n};\n")])])]),e("p",[t._v("另外其实在 STL 中也有一个"),e("code",[t._v("next_permutation")]),t._v("算法，它的源代码如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("template <class _Compare, class _BidirectionalIterator>\nbool\n__next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n    _BidirectionalIterator __i = __last;\n    if (__first == __last || __first == --__i)\n        return false;\n    while (true)\n    {\n        _BidirectionalIterator __ip1 = __i;\n        if (__comp(*--__i, *__ip1))\n        {\n            \n            _BidirectionalIterator __j = __last;\n            while (!__comp(*__i, *--__j))\n                ;\n            swap(*__i, *__j);\n            _VSTD::reverse(__ip1, __last);\n            return true;\n        }\n        if (__i == __first)\n        {\n            _VSTD::reverse(__first, __last);\n            return false;\n        }\n    }\n}\n")])])]),e("p",[t._v("从代码中我们可以看出 STL 中的这个算法也是按照上述步骤来实现的。")]),t._v(" "),e("p",[t._v("通过对当前排列不断调用上述算法求出其下一排列，再令求出的排列为当前排列，就可以得到一个基于字典序的全排列了。")]),t._v(" "),e("h3",{attrs:{id:"递归法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#递归法"}},[t._v("#")]),t._v(" 递归法")]),t._v(" "),e("p",[t._v("从集合中依次选出每一个元素，作为排列的第一个元素，然后对剩余的元素进行全排列，如此递归处理，从而得到所有元素的全排列。以对"),e("code",[t._v("[1,2,3]")]),t._v("进行全排列为例，我们可以这么做：")]),t._v(" "),e("p",[t._v("固定1，求后面23的排列："),e("code",[t._v("[1,2,3]")]),t._v("，"),e("code",[t._v("[1,3,2]")]),t._v("；\n固定2，求后面13的排列："),e("code",[t._v("[2,1,3]")]),t._v("，"),e("code",[t._v("[2,3,1]")]),t._v("；\n固定3，求后面21的排列："),e("code",[t._v("[3,2,1]")]),t._v("，"),e("code",[t._v("[3,1,2]")]),t._v("。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class Solution {\npublic:\n    vector<vector<int>> permute(vector<int>& nums) {\n        vector<vector<int> > result;\n        if (nums.size() <= 0) {\n            return result;\n        }\n        // 从索引号为0的元素开始，到最后一个元素截止\n        permutation(result,nums,0,nums.size());\n        return result;\n    }\n    \n    // p 表示从索引为 p 的元素开始逐一与后面的元素交换，q 表示最后一个元素的索引\n    void permutation(vector<vector<int> > &results,vector<int> &nums, int i, int j) {\n        // 如果当前元素已经是最后一个元素了，那么nums 存放了一个全新的排列，此时应该回溯返回\n        if(i == j-1) {\n            results.push_back(nums);\n            return;\n        }\n        for(int k = i; k < j; k++) {\n            swap(nums, i, k);\n            permutation(results,nums,i+1, j);\n            swap(nums, i, k);\n        }\n    }\n    \n    void swap(vector<int> &nums, int i, int k) {\n        int temp = nums[i];\n        nums[i] = nums[k];\n        nums[k] = temp;\n    }\n};\n")])])]),e("h2",{attrs:{id:"permutations-ii"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#permutations-ii"}},[t._v("#")]),t._v(" Permutations II")]),t._v(" "),e("p",[t._v("我们选用递归法的框架。首先需要对输入进行排序，以将所有有重复的数字安排在相邻的位置。之后代码的处理过程就和上面的问题类似了，具体实现请看下面的代码和注释。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class Solution {\npublic:\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        vector<vector<int> > results;\n        sort(nums.begin(), nums.end());\n        permutation(results, nums, 0, nums.size()-1);\n        return results;\n    }\n    \n    // 注意 nums 的参数传递方式是值传递而非引用传递\n    void permutation(vector<vector<int> > &results, vector<int> nums, int i , int j )  {\n        if (i == j) {\n            results.push_back(nums);\n            return;\n        } else {\n            for(int k = i; k < j; k++) {\n            \n                // 因为已经对输入进行排序，将重复的数字安排在相邻的位置，所以如果nums[i] == nums[k]，就表示遇到重复数字了，可以跳过\n                if (i != k && nums[i] == nums[k]) {\n                    continue;\n                }\n                swap(nums, i, k);\n                backtrace(results, nums, i+1, j);\n            }\n        }\n    }\n    \n    void swap(vector<int> &nums, int i, int k) {\n        int temp = nums[i];\n        nums[i] = nums[k];\n        nums[k] = temp;\n    }\n\n};\n")])])]),e("h2",{attrs:{id:"next-permutation"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#next-permutation"}},[t._v("#")]),t._v(" Next Permutation")]),t._v(" "),e("p",[t._v("给定一组数字的全排列中的一个排列，求这个排列的下一个排列。这个题其实就是全排列的字典序法中的一个子步骤，在上文中已经介绍过了，因此不再赘述。")]),t._v(" "),e("h2",{attrs:{id:"permutation-sequence"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#permutation-sequence"}},[t._v("#")]),t._v(" Permutation Sequence")]),t._v(" "),e("p",[t._v("对于一个集合"),e("code",[t._v("[1,2,3,...,n]")]),t._v("来说，它的全排列有n!种。现在给定n 和 k，求"),e("code",[t._v("[1,2,3,...,n]")]),t._v("的全排列中的第k个排列。")]),t._v(" "),e("p",[t._v("其实这个题目的解法非常简单，直接利用利用求下一排列的算法即可：维护一个从1开始的计数器，当计数器的数值小于 K 时，就重复计算下一排列并将计数器加一，当计数器数值为 k 时停止，此时计算出的排列就是第 K 个排列。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('class Solution {\npublic:\n\tint maxOfK() {\n\t\tint result = 1;\n\t\tfor(int i = 1; i < 10 ;i++) {\n\t\t\tresult *= i;\n\t\t}\n\t\treturn result;\n\t}\n\tstring getString(int n) {\n\t\tint i = 1;\n\t\tstring s = to_string(i);\n\t\twhile(++i <= n) {\n\t\t\ts += to_string(i);\n\t\t}\n\t\treturn s;\n\t}\n\tstring getPermutation(int n, int k) {\n\t\tstring s;\n\t\tif (k <= 0 || k > maxOfK()) {\n\t\t\treturn s;\n\t\t}\n\t\t\n\t\t// 输入n,那么s="123...n"\n\t\ts = getString(n);\n\t\tint i = 1;\n\t\twhile(i++ < k) {\n\t\t   // 通过 STL 函数来对 s 进行排列，这个排列是按照字典序进行的\n\t\t\tstd::next_permutation(s.begin(),s.end());\n\t\t}\n\t\treturn s;\n\t}\n};\n')])])])])}),[],!1,null,null,null);n.default=r.exports}}]);